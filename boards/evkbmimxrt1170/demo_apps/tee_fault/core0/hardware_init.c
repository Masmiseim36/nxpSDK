/*
 * Copyright 2022 NXP
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */
/*${header:start}*/
#include "fsl_common.h"
#include "fsl_soc_src.h"
#include "pin_mux.h"
#include "board.h"
#include "resource_config.h"
#include "app.h"
/*${header:end}*/

/*${function:start}*/
/*
 * For the dual core project, generally primary core starts first, initializes
 * the system, then starts the secondary core to run.
 * In the case that debugging dual-core at the same time (for example, using IAR+DAPLink),
 * the secondary core is started by debugger. Then the secondary core might
 * run when the primary core initialization not finished. The SRC->GPR is used
 * here to indicate whether secondary core could go. When started, the secondary core
 * should check and wait the flag in SRC->GPR, the primary core sets the
 * flag in SRC->GPR when its initialization work finished.
 */
#define DEMO_SECONDARY_CORE_GO_FLAG 0xa5a5a5a5u
#define DEMO_SECONDARY_CORE_SRC_GPR kSRC_GeneralPurposeRegister20

void DEMO_SetSecondaryCoreGoFlag(void)
{
    SRC_SetGeneralPurposeRegister(SRC, DEMO_SECONDARY_CORE_SRC_GPR, DEMO_SECONDARY_CORE_GO_FLAG);
}

/*
 * XRDC2 domain is decided by the MATCH and MASK. The MATCH for each master is:
 *
 * xrdc2_mdac_axi_m7  For READ access
 *                    M7MCM.pid[7:0] (MCM register)
 *                    apc_axi_m7.r_xid[5] (AXI bus ARPROT[2]: 1-instruction, 0-data)
 *                    apc_axi_m7.r_xid[4] (reserved)
 *                    apc_axi_m7.r_xid[3] (APC region hit: 1-hit, 0-no hit)
 *                    apc_axi_m7.r_xid[2:0] (AXI bus ARID[3:0])
 *
 *                    For WRITE access
 *                    M7MCM.pid[7:0] (MCM register)
 *                    apc_axi_m7.w_xid[5] (AXI bus AWPROT[2]: 1-instruction, 0-data)
 *                    apc_axi_m7.w_xid[4] (reserved)
 *                    apc_axi_m7.w_xid[3] (APC region hit: 1-hit, 0-no hit)
 *                    apc_axi_m7.w_xid[2] (reserved)
 *                    apc_axi_m7.w_xid[1:0] (AXI bus AWID[2:0])
 *
 * xrdc2_mdac_ahb_m7  Both READ and WRITE access
 *                    apc_ahb_m7.xid[5] (AHBP bus ~HPROT[0]: 1-instruction, 0-data)
 *                    apc_ahb_m7.xid[4] (reserved)
 *                    apc_ahb_m7.xid[3] (APC region hit: 1-hit, 0-no hit)
 *                    apc_ahb_m7.xid[2:0] (APC region hit number: 000-region 0 hit, 001-region 1 hit,111-region 7 hit)
 *
 * xrdc2_mdac_edma_m7 Both READ and WRITE access
 *                    edma.dma_channel_id[4:0]
 *                    edma.dma_hmaster[3:0] (depends on DCHMID enable bit in eDMA)
 *                    apc_edma_m7.xid[5] (AHB bus ~HPROT[0]: 1-instruction, 0-data)
 *                    apc_edma_m7.xid[4] (reserved)
 *                    apc_edma_m7.xid[3] (APC region hit: 1-hit, 0-no hit)
 *                    apc_edma_m7.xid[2:0] (APC region hit number: 000-region 0 hit, 001-region 1 hit,111-region 7 hit)
 *
 * xrdc2_mdac_caam   For READ access
 *                   caam.caam_mst_aricid[3:0] (generated by CAAM)
 *                   apc_caam.r_xid[5] (AXI bus ARPROT[2]: 1-instruction, 0-data)
 *                   apc_caam.r_xid[4] (reserved)
 *                   apc_caam.r_xid[3] (APC region hit: 1-hit, 0-no hit)
 *                   apc_caam.r_xid[2:0] (APC region hit number: 000-region 0 hit, 001-region 1 hit,111-region 7 hit)
 *
 *                   For WRITE access
 *                   caam.caam_mst_awicid[3:0] (generated by CAAM)
 *                   apc_caam.w_xid[5] (AXI bus AWPROT[2]: 1-instruction, 0-data)
 *                   apc_caam.w_xid[4] (reserved)
 *                   apc_caam.w_xid[3] (APC region hit: 1-hit, 0-no hit)
 *                   apc_caam.w_xid[2:0] (APC region hit number: 000-region 0 hit, 001-region 1 hit,111-region 7 hit)
 *
 * xrdc2_mdac_enet_1g_tx    apc_enet_1g_tx.r_xid[5:0]    apc_enet_1g_tx.w_xid[5:0]
 * xrdc2_mdac_enet_1g_rx    apc_enet_1g_rx.r_xid[5:0]    apc_enet_1g_rx.w_xid[5:0]
 * xrdc2_mdac_enet          apc_enet.xid[5:0]
 * xrdc2_mdac_enet_qos      apc_enet_qos.r_xid[5:0]      apc_enet_qos.w_xid[5:0]
 * xrdc2_mdac_usdhc1        apc_usdhc1.r_xid[5:0]        apc_usdhc1.w_xid[5:0]
 * xrdc2_mdac_usdhc2        apc_usdhc2.r_xid[5:0]        apc_usdhc2.w_xid[5:0]
 * xrdc2_mdac_usb           apc_usb.r_xid[5:0]           apc_usb.w_xid[5:0]
 * xrdc2_mdac_gc355         apc_gc355.r_xid[5:0]         apc_gc355.w_xid[5:0]
 * xrdc2_mdac_pxp           apc_pxp.r_xid[5:0]           apc_pxp.w_xid[5:0]
 * xrdc2_mdac_lcdif1        apc_lcdif1.r_xid[5:0]        apc_lcdif1.w_xid[5:0]
 * xrdc2_mdac_lcdif2        apc_lcdif2.r_xid[5:0]        apc_lcdif2.w_xid[5:0]
 * xrdc2_mdac_csi           apc_csi.r_xid[5:0]           apc_csi.w_xid[5:0]
 *
 * xrdc2_mdac_ahbc_m4 Both READ and WRITE access
 *                    cm4_imxrt.mcm_pid[7:0] (M4 MCM register)
 *                    apc_ahbc_m4.xid[5] (AHBC bus ~HPROT[0]: 1-instruction, 0-data)
 *                    apc_ahbc_m4.xid[4] (reserved)
 *                    apc_ahbc_m4.xid[3] (APC region hit: 1-hit, 0-no hit)
 *                    apc_ahbc_m4.xid[2:0] (APC region hit number: 000-region 0 hit, 001-region 1 hit,111-region 7 hit)
 *
 * xrdc2_mdac_ahbs_m4 Both READ and WRITE access
 *                    cm4_imxrt.mcm_pid[7:0] (M4 MCM register)
 *                    apc_ahbs_m4.xid[5] (AHBS bus ~HPROT[0]: 1-instruction, 0-data)
 *                    apc_ahbs_m4.xid[4] (reserved)
 *                    apc_ahbs_m4.xid[3] (APC region hit: 1-hit, 0-no hit)
 *                    apc_ahbs_m4.xid[2:0] (APC region hit number: 000-region 0 hit, 001-region 1 hit,111-region 7 hit)
 *
 * xrdc2_mdac_edma_m4 edma_lpsr.dma_channel_id[4:0]
 *                    edma_lpsr.dma_hmaster[3:0]
 *                    apc_edma_m4.xid[5:0]
 *
 * ============================================================================
 *
 * AXI bug ARID and AWID used for xrdc2_mdac_axi_m7:
 *
 * ARID[2:0]
 * 0b000         Normal Non-cacheable, Device and Strong-ordered reads.
 * 0b011, 0b010  Data cache line fill
 * 0b100         Instruction fetch
 *
 * AWID[1:0]
 * 0b00          Normal Non-cacheable writes, all shared exclusive writes,
 *               for example from STREX.
 * 0b01          Normal cacheable writes to Write-Through and Write-Back,
 *               Non Write-Allocate memory.
 * 0b10          Device and Strong-ordered writes.
 * 0b11          Evictions to Normal cacheable Write-Back memory.
 *
 * ============================================================================
 *
 * For CM7, in XRDC2 configuration, the M7MCM.pid determines the domain ID.
 * M7MCM.pid = 0 is Domain 0 (trusted domain).
 * M7MCM.pid = 1 is Domain 1 (untrusted domain).
 *
 * M7MCM.pid address is 0xE0080030.
 */
void DEMO_SwitchToUntrustedDomain(void)
{
    *(volatile uint32_t *)0xe0080030 = 1;
}

void DEMO_BootCore1(void)
{
    IOMUXC_LPSR_GPR->GPR0 = IOMUXC_LPSR_GPR_GPR0_CM4_INIT_VTOR_LOW(CORE1_BOOT_ADDRESS >> 3);
    IOMUXC_LPSR_GPR->GPR1 = IOMUXC_LPSR_GPR_GPR1_CM4_INIT_VTOR_HIGH(CORE1_BOOT_ADDRESS >> 16);

    /* Read back to make sure write takes effect. */
    (void)IOMUXC_LPSR_GPR->GPR0;
    (void)IOMUXC_LPSR_GPR->GPR1;

    /* If CM4 is already running (released by debugger), then reset it.
       If CM4 is not running, release it. */
    if ((SRC->SCR & SRC_SCR_BT_RELEASE_M4_MASK) == 0)
    {
        SRC_ReleaseCoreReset(SRC, kSRC_CM4Core);
    }
    else
    {
        SRC_AssertSliceSoftwareReset(SRC, kSRC_M4CoreSlice);
    }

    DEMO_SetSecondaryCoreGoFlag();
}

#ifdef CORE1_IMAGE_COPY_TO_RAM
uint32_t get_core1_image_size()
{
    uint32_t image_size;
#if defined(__CC_ARM) || defined(__ARMCC_VERSION)
    image_size = (uint32_t)&Image$$CORE1_REGION$$Length;
#elif defined(__ICCARM__)
#pragma section = "__core1_image"
    image_size = (uint32_t)__section_end("__core1_image") - (uint32_t)&core1_image_start;
#elif defined(__GNUC__)
    image_size = (uint32_t)core1_image_size;
#endif
    return image_size;
}
#endif

void BOARD_InitHardware(void)
{
    BOARD_InitBootTEE();
    BOARD_InitBootPins();
    BOARD_InitBootClocks();
    BOARD_InitDebugConsole();
}
/*${function:end}*/
