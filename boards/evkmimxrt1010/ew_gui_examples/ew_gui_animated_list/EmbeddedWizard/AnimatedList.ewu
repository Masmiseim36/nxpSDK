$version 10.00

// This is a font resource.
$rect <40,580,240,620>
$output false
resource Resources::Font ListFontS
{
  attr fontname FontName = Segoe UI;
  attr fontheight Height = 32;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0x7F;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
}

// This is a font resource.
$rect <40,540,240,580>
$output false
resource Resources::Font DescrFont
{
  attr fontname FontName = Roboto;
  attr fontheight Height = 24;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0x7F;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
}

// This is a font resource.
$rect <240,540,440,580>
$output false
resource Resources::Font ListFontM
{
  attr fontname FontName = Segoe UI;
  attr fontheight Height = 38;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0x7F;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
}

// Color constant according UI design.
$rect <440,340,640,380>
$output false
const color ButtonBgColor = #E7EAEAFF;

// Color constant according UI design.
$rect <240,340,440,380>
$output false
const color CaptionColor = #343B56FF;

// Color constant according UI design.
$rect <440,380,640,420>
$output false
const color ButtonTextColor = #69D4B8FF;

// Color constant according UI design.
$rect <240,380,440,420>
$output false
const color ListBgColor = #FFFFFF40;

// Color constant according UI design.
$rect <240,420,440,460>
$output false
const color ListTextColor = #FFFFFFFF;

// Constant to define a common animation time for list animations.
$rect <40,340,240,380>
$output false
const int32 FadeInTime = 300;

// Constant to define a common animation time for list animations.
$rect <40,380,240,420>
$output false
const int32 HoldTime = 2000;

// Constant to define a common animation time for list animations.
$rect <40,420,240,460>
$output false
const int32 FadeOutTime = 1000;

// This is a font resource.
$rect <240,580,440,620>
$output false
resource Resources::Font ListFontL
{
  attr fontname FontName = Segoe UI;
  attr fontheight Height = 96;
  attr fontquality Quality = High;
  attr fontranges Ranges = '0'-'9',':';
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
}

// This is a GUI component.
$rect <40,190,240,230>
$output false
class HourItemS : Core::Group
{
  $rect <140,90,340,130>
  inherited property Bounds = <0,0,110,40>;

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,110,40>;
    preset Color = AnimatedList::ListBgColor;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Right
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeVert];
    preset Bounds = <109,0,110,40>;
    preset Color = AnimatedList::ButtonLineColor;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,110,40>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Text";
    preset Font = AnimatedList::ListFontS;
    preset Color = AnimatedList::ListTextColor;
  }

  // The property 'Caption' contains the text of the list item.
  $rect <140,0,340,40>
  property string Caption = "";

  $rect <140,40,340,80>
  onset Caption
  {
    pure Caption = value;
    Text.String = value;
  }
}

// This is a GUI component.
$rect <40,230,440,270>
$output false
class TimeList : Core::Group
{
  $rect <0,270,200,310>
  inherited property Bounds = <0,0,220,240>;

  // This is a slide gesture handler.
  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandlerH
  {
    preset Bounds = <0,0,110,240>;
    preset OnEnd = OnEnd;
    preset OnStart = OnStart;
    preset SnapNext = <0,160>;
    preset Friction = 0.1;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandlerH
  {
    preset Point4 = <0,239>;
    preset Point3 = <110,239>;
    preset Point2 = <110,0>;
    preset Point1 = <0,0>;
    preset OnRelease = OnReleaseH;
    preset OnPress = OnStart;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeUp];
  }

  // This is a slide gesture handler.
  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandlerM
  {
    preset Bounds = <110,0,220,240>;
    preset OnEnd = OnEnd;
    preset OnStart = OnStart;
    preset SnapNext = <0,160>;
    preset Friction = 0.1;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandlerM
  {
    preset Point4 = <110,239>;
    preset Point3 = <219,239>;
    preset Point2 = <219,0>;
    preset Point1 = <110,0>;
    preset OnRelease = OnReleaseM;
    preset OnPress = OnStart;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeUp];
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,40,220,200>;
    preset Color = AnimatedList::ButtonBgColor;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList BottomListH
  {
    preset Bounds = <0,200,110,240>;
    preset Opacity = 0;
    preset OnLoadItem = OnLoadBottomH;
    preset Endless = true;
    preset ItemHeight = 40;
    preset NoOfItems = 24;
    preset ItemClass = AnimatedList::HourItemS;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList MainListH
  {
    preset Bounds = <0,40,110,200>;
    preset OnUpdate = OnUpdateH;
    preset OnLoadItem = OnLoadMainH;
    preset Endless = true;
    preset SlideHandler = SlideTouchHandlerH;
    preset ItemHeight = 160;
    preset NoOfItems = 24;
    preset ItemClass = AnimatedList::HourItemL;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList TopListH
  {
    preset Bounds = <0,0,110,40>;
    preset Opacity = 0;
    preset OnLoadItem = OnLoadTopH;
    preset Endless = true;
    preset ItemHeight = 40;
    preset NoOfItems = 24;
    preset ItemClass = AnimatedList::HourItemS;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList BottomListM
  {
    preset Bounds = <110,200,220,240>;
    preset Opacity = 0;
    preset OnLoadItem = OnLoadBottomM;
    preset Endless = true;
    preset ItemHeight = 40;
    preset NoOfItems = 60;
    preset ItemClass = AnimatedList::MinItemS;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList MainListM
  {
    preset Bounds = <110,40,220,200>;
    preset OnUpdate = OnUpdateM;
    preset OnLoadItem = OnLoadMainM;
    preset Endless = true;
    preset SlideHandler = SlideTouchHandlerM;
    preset ItemHeight = 160;
    preset NoOfItems = 60;
    preset ItemClass = AnimatedList::MinItemL;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList TopListM
  {
    preset Bounds = <110,0,220,40>;
    preset Opacity = 0;
    preset OnLoadItem = OnLoadTopM;
    preset Endless = true;
    preset ItemHeight = 40;
    preset NoOfItems = 60;
    preset ItemClass = AnimatedList::MinItemS;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Caption
  {
    preset Bounds = <10,40,90,80>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Time";
    preset Font = AnimatedList::DescrFont;
    preset Color = AnimatedList::CaptionColor;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text DotText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <100,40,120,195>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = ":";
    preset Font = AnimatedList::ListFontL;
    preset Color = AnimatedList::ButtonTextColor;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text TimezoneText
  {
    preset Bounds = <10,160,210,200>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Munich, Bavaria";
    preset Font = AnimatedList::DescrFont;
    preset Color = AnimatedList::CaptionColor;
  }

  // Slot property to signal that upper/lower list will appear.
  $rect <840,130,1040,170>
  property slot OnAppear = null;

  // Slot property to signal that upper/lower list has disappeared.
  $rect <840,170,1040,210>
  property slot OnDisappear = null;

  // Slot method to load content of main scroll list.
  $rect <240,130,440,170>
  slot OnLoadMainH
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var AnimatedList::HourItemL itemView = (AnimatedList::HourItemL)MainListH.View;
    var int32             itemNo   = MainListH.Item;
    var string            caption  = string( itemNo );

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( MainListH.Bounds.w, MainListH.ItemHeight );
  }

  // Slot method to load content of upper scroll list.
  $rect <240,0,440,40>
  slot OnLoadTopH
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var AnimatedList::HourItemS itemView = (AnimatedList::HourItemS)TopListH.View;
    var int32             itemNo   = TopListH.Item;
    var string            caption  = string( itemNo );

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( TopListH.Bounds.w, TopListH.ItemHeight );
  }

  // Slot method to synchronize the scrolling of the upper/lower list with the current \
  // scroll position of the center list.
  $rect <240,170,440,210>
  slot OnUpdateH
  {
    sender; /* the method is called from the sender object */

    /* synchronize upper and lower list  */
    TopListH.ScrollOffset = MainListH.ScrollOffset * TopListH.ItemHeight / MainListH.ItemHeight + TopListH.Bounds.h;
    BottomListH.ScrollOffset = MainListH.ScrollOffset * BottomListH.ItemHeight / MainListH.ItemHeight - BottomListH.ItemHeight;



  }

  // Slot method to load content of lower scroll list.
  $rect <240,220,440,260>
  slot OnLoadBottomH
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var AnimatedList::HourItemS itemView = (AnimatedList::HourItemS)BottomListH.View;
    var int32             itemNo   = BottomListH.Item;
    var string            caption  = string( itemNo );

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( BottomListH.Bounds.w, BottomListH.ItemHeight );
  }

  // Slot method to change the selection, when the item has reached its parking position.
  $rect <640,170,840,210>
  slot OnEnd
  {
    sender; /* the method is called from the sender object */

    /* change the current program according user selection */
    AnimatedList::Device.Hour = -MainListH.ScrollOffset / MainListH.ItemHeight;
    AnimatedList::Device.Minute = -MainListM.ScrollOffset / MainListM.ItemHeight;

    /* fade out upper/lower list */
    FadeListOut.Value1 = TopListH.Opacity;
    FadeListOut.Enabled = true;

    /* fade in the caption after sliding */
    FadeCaption.Enabled = false;
    FadeCaption.Value1 = Caption.Opacity;
    FadeCaption.Value2 = 0xFF;
    FadeCaption.Enabled = true;

  }

  // Slot method to make the upper/lower list visible.
  $rect <640,130,840,170>
  slot OnStart
  {
    sender; /* the method is called from the sender object */

    /* fade in the upper/lower list if not fully opaque */
    if (( TopListH.Opacity != 0xFF ) && !FadeListIn.Enabled )
    {
      FadeListIn.Value1 = TopListH.Opacity;
      FadeListIn.Enabled = true;
    }
    FadeListOut.Enabled = false;

    /* fade out the caption during sliding */
    FadeCaption.Enabled = false;
    FadeCaption.Value1 = Caption.Opacity;
    FadeCaption.Value2 = 0x00;
    FadeCaption.Enabled = true;

    /* fade out the duration during sliding */
    FadeDuration.Enabled = false;
    FadeDuration.Value1 = TimezoneText.Opacity;
    FadeDuration.Value2 = 0x00;
    FadeDuration.Enabled = true;

    if ( TopListH.Opacity == 0x00 )
      postsignal OnAppear;
  }

  // This is an int32 change effect.
  $rect <640,0,840,40>
  object Effects::Int32Effect FadeListIn
  {
    preset OnAnimate = onAnimate;
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = AnimatedList::FadeInTime;
    preset Outlet = ^TopListH.Opacity;
  }

  // This is a slot method.
  $rect <640,40,840,80>
  slot onAnimate
  {
    sender; /* the method is called from the sender object */

    TopListM.Opacity = TopListH.Opacity;
    BottomListH.Opacity = TopListH.Opacity;
    BottomListM.Opacity = TopListH.Opacity;

  }

  // This is an int32 change effect.
  $rect <840,40,1040,80>
  object Effects::Int32Effect FadeCaption
  {
    preset Timing = Effects::Timing.FastIn_FastOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
    preset Outlet = ^Caption.Opacity;
  }

  // Slot method to load content of main scroll list.
  $rect <440,130,640,170>
  slot OnLoadMainM
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var AnimatedList::MinItemL itemView = (AnimatedList::MinItemL)MainListM.View;
    var int32             itemNo   = MainListM.Item;
    var string            caption  = string( itemNo, 2 );

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( MainListM.Bounds.w, MainListM.ItemHeight );
  }

  // Slot method to load content of upper scroll list.
  $rect <440,0,640,40>
  slot OnLoadTopM
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var AnimatedList::MinItemS itemView = (AnimatedList::MinItemS)TopListM.View;
    var int32             itemNo   = TopListM.Item;
    var string            caption  = string( itemNo, 2 );

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( TopListM.Bounds.w, TopListM.ItemHeight );
  }

  // Slot method to load content of lower scroll list.
  $rect <440,220,640,260>
  slot OnLoadBottomM
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var AnimatedList::MinItemS itemView = (AnimatedList::MinItemS)BottomListM.View;
    var int32             itemNo   = BottomListM.Item;
    var string            caption  = string( itemNo, 2 );

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( BottomListM.Bounds.w, BottomListM.ItemHeight );
  }

  // Slot method to synchronize the scrolling of the upper/lower list with the current \
  // scroll position of the center list.
  $rect <440,170,640,210>
  slot OnUpdateM
  {
    sender; /* the method is called from the sender object */

    /* synchronize upper and lower list  */
    TopListM.ScrollOffset = MainListM.ScrollOffset * TopListM.ItemHeight / MainListM.ItemHeight + TopListM.Bounds.h;
    BottomListM.ScrollOffset = MainListM.ScrollOffset * BottomListM.ItemHeight / MainListM.ItemHeight - BottomListM.ItemHeight;



  }

  // This is a slot method.
  $rect <640,80,840,120>
  slot onFinished
  {
    sender; /* the method is called from the sender object */

    if ( FadeListOut.Value == 0x00 )
    {
      postsignal OnDisappear;

      /* fade in the duration after sliding */
      FadeDuration.Enabled = false;
      FadeDuration.Value1 = Caption.Opacity;
      FadeDuration.Value2 = 0xFF;
      FadeDuration.Enabled = true;
    }
  }

  // This is an int32 change effect.
  $rect <840,80,1040,120>
  object Effects::Int32Effect FadeDuration
  {
    preset Timing = Effects::Timing.FastIn_FastOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
    preset Outlet = ^TimezoneText.Opacity;
  }

  // This is an int32 change effect.
  $rect <840,0,1040,40>
  object Effects::Int32Effect FadeListOut
  {
    preset OnFinished = onFinished;
    preset OnAnimate = onAnimate;
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = AnimatedList::FadeOutTime;
    preset InitialDelay = AnimatedList::HoldTime;
    preset Value2 = 0;
    preset Value1 = 255;
    preset Outlet = ^TopListH.Opacity;
  }

  $rect <240,270,440,310>
  slot OnReleaseH
  {
    /* if the user has just tapped the simple touch handler without sliding, directly select the item */
    if ( !SimpleTouchHandlerH.AutoDeflected && TopListH.Opacity == 0xFF )
    {
      var int32 delta = 0;

      /* calculate the offset in number of items */
      if ( SimpleTouchHandlerH.CurrentPos.y < MainListH.Bounds.y1 )
        delta = ( SimpleTouchHandlerH.CurrentPos.y - MainListH.Bounds.y1 ) / TopListH.ItemHeight - 1;
      else if ( SimpleTouchHandlerH.CurrentPos.y > MainListH.Bounds.y2 )
        delta = ( SimpleTouchHandlerH.CurrentPos.y - MainListH.Bounds.y2 ) / BottomListH.ItemHeight + 1;

      if ( delta != 0 )
      {
        var int32 item = -MainListH.ScrollOffset / MainListH.ItemHeight + delta;
        MainListH.EnsureVisible( item, true, Int32EffectH, null );
      }
    }
    /* don't forget to start the fade out */
    signal OnEnd;

  }

  $rect <440,270,640,310>
  object Effects::Int32Effect Int32EffectH
  {
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
  }

  $rect <640,270,840,310>
  slot OnReleaseM
  {
    /* if the user has just tapped the simple touch handler without sliding, directly select the item */
    if ( !SimpleTouchHandlerM.AutoDeflected && TopListM.Opacity == 0xFF )
    {
      var int32 delta = 0;

      /* calculate the offset in number of items */
      if ( SimpleTouchHandlerM.CurrentPos.y < MainListM.Bounds.y1 )
        delta = ( SimpleTouchHandlerM.CurrentPos.y - MainListM.Bounds.y1 ) / TopListM.ItemHeight - 1;
      else if ( SimpleTouchHandlerM.CurrentPos.y > MainListM.Bounds.y2 )
        delta = ( SimpleTouchHandlerM.CurrentPos.y - MainListM.Bounds.y2 ) / BottomListM.ItemHeight + 1;

      if ( delta != 0 )
      {
        var int32 item = -MainListM.ScrollOffset / MainListM.ItemHeight + delta;
        MainListM.EnsureVisible( item, true, Int32EffectM, null );
      }
    }
    /* don't forget to start the fade out */
    signal OnEnd;

  }

  $rect <840,270,1040,310>
  object Effects::Int32Effect Int32EffectM
  {
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
  }

  // The class 'TimeList' implements a special type of list to display an hour value \
  // and a minute value, both with a magnification effect of the middle item. For \
  // this purpose, three different vertical lists are used for each side (hour and \
  // minute): A top list with small items, a center list with large items and a bottom \
  // list with small items. The three lists are synchronized, so that it appears \
  // for the user as one list. In order to make the list widget more attractive, \
  // the top and bottom lists are connected with a fade-in/fade-out effect: As soon \
  // as the user touches the widget, the text item dissappears, and the top/bottom \
  // lists start to fade-in. After a certain idle time, the top/bottom lists will \
  // fade-out.
  note legend Note
  {
    attr Bounds = <0,370,1040,490>;
  }

  // Slot method to trigger the next phase of the auto demo.
  $rect <240,320,440,360>
  slot AutoDemo
  {
    postsignal OnStart;

    MainListH.EnsureVisible( math_rand( 0, 12 ), true, AutoDemoEffectH, null );
    MainListM.EnsureVisible( math_rand( 0, 59 ), true, AutoDemoEffectM, OnEnd );

  }

  // This is an int32 change effect.
  $rect <440,320,640,360>
  object Effects::Int32Effect AutoDemoEffectH
  {
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset CycleDuration = 300;
  }

  // This is an int32 change effect.
  $rect <640,320,840,360>
  object Effects::Int32Effect AutoDemoEffectM
  {
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset CycleDuration = 600;
  }
}

// This is a GUI component.
$rect <40,150,240,190>
$output false
class HourItemL : Core::Group
{
  $rect <140,90,340,130>
  inherited property Bounds = <0,0,110,160>;

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,100,155>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "00";
    preset Font = AnimatedList::ListFontL;
    preset Color = AnimatedList::ButtonTextColor;
  }

  // The property 'Caption' contains the text of the list item.
  $rect <140,0,340,40>
  property string Caption = "";

  $rect <140,40,340,80>
  onset Caption
  {
    pure Caption = value;
    Text.String = value;
  }
}

// This is a GUI component.
$rect <240,150,440,190>
$output false
class MinItemL : Core::Group
{
  $rect <140,90,340,130>
  inherited property Bounds = <0,0,110,160>;

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <10,0,110,155>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "00";
    preset Font = AnimatedList::ListFontL;
    preset Color = AnimatedList::ButtonTextColor;
  }

  // The property 'Caption' contains the text of the list item.
  $rect <140,0,340,40>
  property string Caption = "";

  $rect <140,40,340,80>
  onset Caption
  {
    pure Caption = value;
    Text.String = value;
  }
}

// This is a GUI component.
$rect <240,190,440,230>
$output false
class MinItemS : Core::Group
{
  $rect <140,90,340,130>
  inherited property Bounds = <0,0,110,40>;

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,110,40>;
    preset Color = AnimatedList::ListBgColor;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Left
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeVert];
    preset Bounds = <0,0,1,40>;
    preset Color = AnimatedList::ButtonLineColor;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Right
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeVert];
    preset Bounds = <109,0,110,40>;
    preset Color = AnimatedList::ButtonLineColor;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,110,40>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Text";
    preset Font = AnimatedList::ListFontS;
    preset Color = AnimatedList::ListTextColor;
  }

  // The property 'Caption' contains the text of the list item.
  $rect <140,0,340,40>
  property string Caption = "";

  $rect <140,40,340,80>
  onset Caption
  {
    pure Caption = value;
    Text.String = value;
  }
}

// Controller class, containing all data set values and all current values of the \
// device.
$rect <40,690,240,730>
$output false
class DeviceClass
{
  // Hour of time.
  $rect <220,10,420,50>
  property int32 Hour = 0;

  $rect <220,50,420,90>
  onset Hour
  {
    // Implement here your ON SET business logic, the access to the hardware,
    // or any desired code to execute, when the property is written at the
    // runtime.

    /* check limits of given value */
    if ( value < 0 )
      value = 0;
    if ( value > 23 )
      value = 23;

    /* check for new value */
    if ( value == pure Hour )
      return;

    pure Hour = value;

    notifyobservers ^Hour;
  }

  // Minute of time.
  $rect <430,10,630,50>
  property int32 Minute = 0;

  $rect <430,50,630,90>
  onset Minute
  {
    // Implement here your ON SET business logic, the access to the hardware,
    // or any desired code to execute, when the property is written at the
    // runtime.

    /* check limits of given value */
    if ( value < 0 )
      value = 0;
    if ( value > 59 )
      value = 59;

    /* check for new value */
    if ( value == pure Minute )
      return;

    pure Minute = value;

    notifyobservers ^Minute;
  }

  // Index of week day.
  $rect <10,10,210,50>
  property int32 WeekDay = 0;

  $rect <10,50,210,90>
  onset WeekDay
  {
    // Implement here your ON SET business logic, the access to the hardware,
    // or any desired code to execute, when the property is written at the
    // runtime.

    /* check limits of given value */
    if ( value < 0 )
      value = 0;
    if ( value >= WeekDays.size )
      value = WeekDays.size - 1;


    /* check for new value */
    if ( value == pure WeekDay )
      return;

    pure WeekDay = value;

    notifyobservers ^WeekDay;


  }

  // Array of week days.
  $rect <10,100,210,140>
  array string WeekDays[ 7 ] =
  (
    Default[0] = "Mon";
    Default[1] = "Tue";
    Default[2] = "Wed";
    Default[3] = "Thu";
    Default[4] = "Fri";
    Default[5] = "Sat";
    Default[6] = "Sun";
  );
}

$rect <240,690,440,730>
$output false
autoobject AnimatedList::DeviceClass Device;

// This is a GUI component.
$rect <440,230,640,270>
$output false
class DayList : Core::Group
{
  $rect <0,270,200,310>
  inherited property Bounds = <0,0,100,240>;

  // This is a slide gesture handler.
  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,100,240>;
    preset OnEnd = OnEnd;
    preset OnStart = OnStart;
    preset SnapNext = <0,160>;
    preset Friction = 0.1;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,240>;
    preset Point3 = <100,240>;
    preset Point2 = <100,0>;
    preset Point1 = <0,0>;
    preset OnRelease = OnRelease;
    preset OnPress = OnStart;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeUp];
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,40,100,200>;
    preset Color = AnimatedList::ButtonBgColor;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList BottomList
  {
    preset Bounds = <0,200,100,240>;
    preset Opacity = 0;
    preset OnLoadItem = OnLoadBottom;
    preset ItemHeight = 40;
    preset NoOfItems = AnimatedList::Device.WeekDays.size;
    preset ItemClass = AnimatedList::DayItemS;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList MainList
  {
    preset Bounds = <0,40,100,200>;
    preset OnUpdate = OnUpdate;
    preset OnLoadItem = OnLoadMain;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 160;
    preset NoOfItems = AnimatedList::Device.WeekDays.size;
    preset ItemClass = AnimatedList::DayItemL;
  }

  // This is a vertical list component.
  $rect <20,20,160,60>
  object Core::VerticalList TopList
  {
    preset Bounds = <0,0,100,40>;
    preset Opacity = 0;
    preset OnLoadItem = OnLoadTop;
    preset ItemHeight = 40;
    preset NoOfItems = AnimatedList::Device.WeekDays.size;
    preset ItemClass = AnimatedList::DayItemS;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Caption
  {
    preset Bounds = <10,40,100,80>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Day";
    preset Font = AnimatedList::DescrFont;
    preset Color = AnimatedList::CaptionColor;
  }

  // Slot method to load content of main scroll list.
  $rect <210,90,410,130>
  slot OnLoadMain
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var AnimatedList::DayItemL itemView = (AnimatedList::DayItemL)MainList.View;
    var int32             itemNo   = MainList.Item;
    var string            caption  = "";

    /* get caption from corresponding array within device class */
    if (( itemNo >= 0 ) && ( itemNo < AnimatedList::Device.WeekDays.size ))
      caption = AnimatedList::Device.WeekDays[ itemNo ];

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( MainList.Bounds.w, MainList.ItemHeight );
  }

  // Slot method to load content of upper scroll list.
  $rect <210,0,410,40>
  slot OnLoadTop
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var AnimatedList::DayItemS itemView = (AnimatedList::DayItemS)TopList.View;
    var int32             itemNo   = TopList.Item;
    var string            caption  = "";

    /* get caption from corresponding array within device class */
    if (( itemNo >= 0 ) && ( itemNo < AnimatedList::Device.WeekDays.size ))
      caption = AnimatedList::Device.WeekDays[ itemNo ];

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( TopList.Bounds.w, TopList.ItemHeight );
  }

  // Slot method to synchronize the scrolling of the upper/lower list with the current \
  // scroll position of the center list.
  $rect <210,130,410,170>
  slot OnUpdate
  {
    sender; /* the method is called from the sender object */

    /* synchronize upper and lower list  */
    TopList.ScrollOffset = MainList.ScrollOffset * TopList.ItemHeight / MainList.ItemHeight + TopList.Bounds.h;
    BottomList.ScrollOffset = MainList.ScrollOffset * BottomList.ItemHeight / MainList.ItemHeight - BottomList.ItemHeight;



  }

  // Slot method to load content of lower scroll list.
  $rect <210,180,410,220>
  slot OnLoadBottom
  {
    sender; /* the method is called from the sender object */

    /* access the item to load the content */
    var AnimatedList::DayItemS itemView = (AnimatedList::DayItemS)BottomList.View;
    var int32             itemNo   = BottomList.Item;
    var string            caption  = "";

    /* get caption from corresponding array within device class */
    if (( itemNo >= 0 ) && ( itemNo < AnimatedList::Device.WeekDays.size ))
      caption = AnimatedList::Device.WeekDays[ itemNo ];

    /* load the item with the content */
    itemView.Caption     = caption;
    itemView.Bounds.size = point( BottomList.Bounds.w, BottomList.ItemHeight );
  }

  // Slot method to change the selection, when the item has reached its parking position.
  $rect <410,130,610,170>
  slot OnEnd
  {
    sender; /* the method is called from the sender object */

    /* change the current program according user selection */
    AnimatedList::Device.WeekDay = -MainList.ScrollOffset / MainList.ItemHeight;

    /* fade out upper/lower list */
    FadeListOut.Value1 = TopList.Opacity;
    FadeListOut.Enabled = true;

    /* fade in the caption after sliding */
    FadeCaption.Enabled = false;
    FadeCaption.Value1 = Caption.Opacity;
    FadeCaption.Value2 = 0xFF;
    FadeCaption.Enabled = true;

  }

  // Slot method to make the upper/lower list visible.
  $rect <410,90,610,130>
  slot OnStart
  {
    sender; /* the method is called from the sender object */

    /* fade in the upper/lower list if not fully opaque */
    if (( TopList.Opacity != 0xFF ) && !FadeListIn.Enabled )
    {
      FadeListIn.Value1 = TopList.Opacity;
      FadeListIn.Enabled = true;
    }
    FadeListOut.Enabled = false;

    /* fade out the caption during sliding */
    FadeCaption.Enabled = false;
    FadeCaption.Value1 = Caption.Opacity;
    FadeCaption.Value2 = 0x00;
    FadeCaption.Enabled = true;


  }

  // This is an int32 change effect.
  $rect <410,0,610,40>
  object Effects::Int32Effect FadeListIn
  {
    preset OnAnimate = onAnimate;
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = AnimatedList::FadeInTime;
    preset Outlet = ^TopList.Opacity;
  }

  // This is a slot method.
  $rect <410,40,610,80>
  slot onAnimate
  {
    sender; /* the method is called from the sender object */

    BottomList.Opacity = TopList.Opacity;

  }

  // This is an int32 change effect.
  $rect <610,40,810,80>
  object Effects::Int32Effect FadeCaption
  {
    preset Timing = Effects::Timing.FastIn_FastOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
    preset Outlet = ^Caption.Opacity;
  }

  // This is an int32 change effect.
  $rect <610,0,810,40>
  object Effects::Int32Effect FadeListOut
  {
    preset OnAnimate = onAnimate;
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = AnimatedList::FadeOutTime;
    preset InitialDelay = AnimatedList::HoldTime;
    preset Value2 = 0;
    preset Value1 = 255;
    preset Outlet = ^TopList.Opacity;
  }

  $rect <210,230,410,270>
  slot OnRelease
  {
    /* if the user has just tapped the simple touch handler without sliding, directly select the item */
    if ( !SimpleTouchHandler.AutoDeflected && TopList.Opacity == 0xFF )
    {
      var int32 delta = 0;

      /* calculate the offset in number of items */
      if ( SimpleTouchHandler.CurrentPos.y < MainList.Bounds.y1 )
        delta = ( SimpleTouchHandler.CurrentPos.y - MainList.Bounds.y1 ) / TopList.ItemHeight - 1;
      else if ( SimpleTouchHandler.CurrentPos.y > MainList.Bounds.y2 )
        delta = ( SimpleTouchHandler.CurrentPos.y - MainList.Bounds.y2 ) / BottomList.ItemHeight + 1;

      if ( delta != 0 )
      {
        var int32 item = -MainList.ScrollOffset / MainList.ItemHeight + delta;
        MainList.EnsureVisible( item, true, Int32Effect, null );
      }
    }
    /* don't forget to start the fade out */
    signal OnEnd;

  }

  $rect <410,230,610,270>
  object Effects::Int32Effect Int32Effect
  {
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 200;
  }

  // The class 'DayList' implements a special type of list to display the day of \
  // the week, with a magnification effect of the middle item. For this purpose, \
  // three different vertical lists are used: A top list with small items, a center \
  // list with large items and a bottom list with small items. The three lists are \
  // synchronized, so that it appears for the user as one list. In order to make \
  // the list widget more attractive, the top and bottom list are connected with \
  // a fade-in/fade-out effect: As soon as the user touches the widget, the text \
  // item dissappears, and the top/bottom lists start to fade-in. After a certain \
  // idle time, the top/bottom lists will fade-out.
  note legend Note
  {
    attr Bounds = <0,320,810,450>;
  }

  // Slot method to trigger the next phase of the auto demo.
  $rect <210,270,410,310>
  slot AutoDemo
  {
    postsignal OnStart;

    var int32 val = AnimatedList::Device.WeekDay + 1;

    if ( val >= AnimatedList::Device.WeekDays.size )
      val = 0;

    MainList.EnsureVisible( val, true, AutoDemoEffect, OnEnd );

  }

  // This is an int32 change effect.
  $rect <410,270,610,310>
  object Effects::Int32Effect AutoDemoEffect
  {
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset CycleDuration = 300;
  }
}

// This is a GUI component.
$rect <440,150,640,190>
$output false
class DayItemL : Core::Group
{
  $rect <140,90,340,130>
  inherited property Bounds = <0,0,100,160>;

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <20,0,90,160>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text";
    preset Font = AnimatedList::ListFontM;
    preset Color = AnimatedList::ButtonTextColor;
  }

  // The property 'Caption' contains the text of the list item.
  $rect <140,0,340,40>
  property string Caption = "";

  $rect <140,40,340,80>
  onset Caption
  {
    pure Caption = value;
    Text.String = value;
  }
}

// This is a GUI component.
$rect <440,190,640,230>
$output false
class DayItemS : Core::Group
{
  $rect <140,90,340,130>
  inherited property Bounds = <0,0,100,40>;

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,100,40>;
    preset Color = AnimatedList::ListBgColor;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Left
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeVert];
    preset Bounds = <0,0,1,40>;
    preset Color = AnimatedList::ButtonLineColor;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <20,0,100,40>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text";
    preset Font = AnimatedList::ListFontS;
    preset Color = AnimatedList::ListTextColor;
  }

  // The property 'Caption' contains the text of the list item.
  $rect <140,0,340,40>
  property string Caption = "";

  $rect <140,40,340,80>
  onset Caption
  {
    pure Caption = value;
    Text.String = value;
  }
}

// Color constant according UI design.
$rect <440,420,640,460>
$output false
const color ButtonLineColor = #0000007E;

// List item classes and list classes
note group Note
{
  attr Bounds = <20,110,660,290>;
}

// Time and color constants
note group Note1
{
  attr Bounds = <20,300,660,480>;
}

// Resources
note group Note2
{
  attr Bounds = <20,490,660,640>;
}

// Device class
note group Note3
{
  attr Bounds = <20,650,660,750>;
}

// This is the root component of the entire GUI application.
$rect <40,40,240,80>
$output false
class AnimatedList : Core::Group
{
  $rect <350,0,550,40>
  inherited property Bounds = <0,0,320,240>;

  // This is the Application class of the 'AnimatedList' example.
  // 
  // It just arranges the scrollable list widgets for time and day settings.
  // 
  // To run the application within the Prototyper, press 'F5'.
  note legend Note1
  {
    attr Bounds = <350,50,550,250>;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,320,240>;
    preset Color = #343B56FF;
  }

  $rect <20,20,160,60>
  object AnimatedList::TimeList TimeList
  {
    preset Bounds = <0,0,220,240>;
  }

  $rect <20,20,160,60>
  object AnimatedList::DayList DayList
  {
    preset Bounds = <220,0,320,240>;
  }

  // This variable refers to the autoobject 'Application::Device'. It is used to \
  // keep the device object within the memory during the whole liefetime of the application.
  $rect <10,270,210,310>
  var AnimatedList::DeviceClass Device = AnimatedList::Device;

  // Slot method to trigger the next phase of the auto demo.
  $rect <350,270,550,310>
  slot AutoDemoSlot
  {
    sender; /* the method is called from the sender object */

    switch ( AutoState )
    {
      case  1: postsignal DayList.AutoDemo;
      case  2: postsignal TimeList.AutoDemo;
      case  3: postsignal TimeList.AutoDemo;
      case  4: postsignal TimeList.AutoDemo;
      default:
       ;
    }

    AutoState = AutoState + 1;
    if ( AutoState > 5 )
      AutoState = 0;
  }

  // Variable to store the current phase of the auto demo.
  $rect <350,350,550,390>
  var int32 AutoState = 0;

  // Timer object to drive the auto demo mode.
  $rect <350,310,550,350>
  object Core::Timer AutoDemoTimer
  {
    preset OnTrigger = AutoDemoSlot;
    preset Period = 1500;
    preset Begin = 0;
  }
}

// Animated list main screen
note group Note4
{
  attr Bounds = <20,0,660,100>;
}
