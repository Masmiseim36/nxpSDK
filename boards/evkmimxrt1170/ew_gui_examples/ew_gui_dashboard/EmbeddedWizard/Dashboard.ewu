$version 10.00

// Screens
note group Note2
{
  attr Bounds = <0,10,449,140>;
}

// Widgets
note group Note1
{
  attr Bounds = <0,149,449,399>;
}

// Resources
note group Note3
{
  attr Bounds = <460,10,1280,400>;
}

// Color class which stores the used colors into properties.
$rect <10,630,210,670>
$output false
class ColorsClass
{
  $rect <10,40,210,80>
  property color Background = #000000FF;

  $rect <10,80,210,120>
  property color Text = #FFFFFFFF;

  $rect <10,120,210,160>
  property color TextLedsOff = #5454547E;

  $rect <240,80,440,120>
  property color GaugeGlowV1 = #01b8f6FF;

  $rect <240,40,440,80>
  property color BatteryGaugeSelectionV1 = #00dce3FF;

  $rect <10,200,210,240>
  property color LedsOnOrange = #FFB53EFF;

  $rect <470,80,670,120>
  property color GaugeGlowV2 = #00ffa9FF;

  $rect <470,40,670,80>
  property color BatteryGaugeSelectionV2 = #4eb599FF;

  $rect <470,120,670,160>
  property color WingV2 = #33AA71FF;

  $rect <10,160,210,200>
  property color BatteryFrame = #505050FF;

  $rect <10,240,210,280>
  property color LedsOnGreen = #10995EFF;

  // Common
  note group Note
  {
    attr Bounds = <0,0,220,410>;
  }

  // Variant 1
  note group Note1
  {
    attr Bounds = <230,0,450,410>;
  }

  // Variant 2
  note group Note2
  {
    attr Bounds = <460,0,680,410>;
  }

  $rect <240,120,440,160>
  property color GaugeLabelLinesV1 = #FFFFFFC8;

  $rect <240,160,440,200>
  property color GaugeCircle0 = #01b8f6FF;

  $rect <240,200,440,240>
  property color GaugeCircle1 = #002636FF;

  $rect <240,240,440,280>
  property color GaugeCircle2 = #0b78adFF;

  $rect <240,280,440,320>
  property color GaugeCircle3 = #00f6ffFF;

  $rect <240,320,440,360>
  property color GaugeCircle4 = #12143dFF;

  $rect <240,360,440,400>
  property color GaugeCircle5 = #031d29FF;
}

$rect <210,630,410,670>
$output false
autoobject Dashboard::ColorsClass Colors;

$rect <210,50,410,90>
$output false
class DashboardV1 : Core::Group
{
  $rect <0,740,200,780>
  inherited property Bounds = <0,0,1280,720>;

  $rect <400,961,600,1001>
  inherited method UpdateViewState()
  {
    super( aState );

    // Increase opacity of gauge labels
    PowerGauge.OpacityLabels = (uint8)Dashboard::Animation.linearValueProgress( 0, 255, 0.4, 0.7, CurrentProgress );
    SpeedGauge.OpacityLabels = (uint8)Dashboard::Animation.linearValueProgress( 0, 255, 0.4, 0.7, CurrentProgress );

    // Increase opacity of gauges and top glow
    PowerGauge.OpacityGauge = (uint8)Dashboard::Animation.linearValueProgress( 0, 255, 0.5, 0.9, CurrentProgress );
    SpeedGauge.OpacityGauge = (uint8)Dashboard::Animation.linearValueProgress( 0, 255, 0.5, 0.9, CurrentProgress );
    TopGlow.Opacity = (uint8)Dashboard::Animation.linearValueProgress( 0, 255, 0.9, 1.0, CurrentProgress );

    // Animate left path
    var int32 noOfEdges = leftPath.GetNoOfEdges( 0 );
    var int32 progress = noOfEdges - Dashboard::Animation.linearValueProgress( 0, noOfEdges, 0.15, 0.95, CurrentProgress );
    leftGrowingPath.InitSubPath( 0, noOfEdges );
    leftGrowingPath.AddCopy( 0, leftPath, 0, progress, noOfEdges - progress );
    LeftStrokePath.Path = leftGrowingPath;

    // Animate right path
    noOfEdges = rightPath.GetNoOfEdges( 0 );
    progress = Dashboard::Animation.linearValueProgress( 0, noOfEdges, 0.15, 0.95, CurrentProgress );
    rightGrowingPath.InitSubPath( 0, noOfEdges );
    rightGrowingPath.AddCopy( 0, rightPath, 0, 0, progress );
    RightStrokePath.Path = rightGrowingPath;

    // Increase opacity of left and right glows
    LeftBottomGlow.Opacity = (uint8)Dashboard::Animation.linearValueProgress( 0, 255, 0.9, 1.0, CurrentProgress );
    RightBottomGlow.Opacity = (uint8)Dashboard::Animation.linearValueProgress( 0, 255, 0.9, 1.0, CurrentProgress );
  }

  $rect <0,780,200,820>
  inherited method Init()
  {
    $if $composer
    CurrentProgress = 1.0;
    $endif


    signal createPath;
  }

  $rect <201,920,401,960>
  onset Outlet
  {
    // Check if the new outlet differs from the currently used outlet
    if ( pure Outlet == value )
      return;

    // Detach from the previous outlet
    if ( pure Outlet != null )
      detachobserver onOutlet, pure Outlet;

    // Store the new outlet ...
    pure Outlet = value;

    // ... and attach to the new one
    if ( value != null )
      attachobserver onOutlet, value;

    // Finally, retrieve the current state of the property associated via 'Outlet'.
    if ( value != null )
      postsignal onOutlet;
  }

  // The property 'Outlet' can refer to any other 'int32' property the widget should \
  // remain synchronized with. When the referred property is modified, the widget \
  // is automatically notified to remain in sync with the property.
  // This approach follows the Controller-View programming paradigm. Here the widget \
  // represents the 'View' and the property referred via 'Outlet' can be seen as \
  // a part of the 'Controller'.
  $rect <1,920,201,960>
  property ^float Outlet = null;

  // This slot method will receive a signal, if the value of the property assigned \
  // to @Outlet has been changed by another widget or by the application logic. In \
  // response to this notification, the widget will update itself.
  $rect <401,920,601,960>
  slot onOutlet
  {
    // Read the current value of the associated property and update accordingly
    // the state of the widget.
    if ( Outlet != null )
      CurrentProgress = Outlet^;
  }

  $rect <0,961,200,1001>
  property float CurrentProgress = 0.0;

  $rect <200,961,400,1001>
  onset CurrentProgress
  {
    // The value doesn't change - nothing to do.
    if ( pure CurrentProgress == value )
      return;

    // Remember the property's new value.
    pure CurrentProgress = value;

    InvalidateViewState();
  }

  $rect <420,820,620,860>
  object Graphics::Path leftGrowingPath;

  $rect <220,860,420,900>
  object Graphics::Path rightPath;

  $rect <421,860,621,900>
  object Graphics::Path rightGrowingPath;

  $rect <221,820,421,860>
  object Graphics::Path leftPath;

  $rect <221,780,421,820>
  slot createPath
  {
    // Setup left line path
    var string svg = "M 91,663.11 101.44125,642.40875 111.8825,621.7075 122.32375,601.00625 132.765,580.305 143.20625,559.60375 153.6475,538.9025 164.08875,518.20125 174.53,497.5 l 0.79,-2 c -6.34375,-2.07438 -12.57742,-4.39199 -18.69,-6.94183 -6.11257,-2.54984 -12.10404,-5.3319 -17.9634,-8.33516 -5.85935,-3.00326 -11.58659,-6.22773 -17.17069,-9.66237 -5.58409,-3.43464 -11.02505,-7.07947 -16.31185,-10.92345 -5.286794,-3.84399 -10.419431,-7.88713 -15.386887,-12.11842 -4.967456,-4.23128 -9.769732,-8.6507 -14.395806,-13.24725 -4.626074,-4.59654 -9.075947,-9.3702 -13.338598,-14.30996 C 57.800117,415.0218 53.724687,409.91594 49.8475,404.655 c -3.877187,-5.26094 -7.556133,-10.67695 -11.025815,-16.23703 -3.469683,-5.56007 -6.730103,-11.2642 -9.77024,-17.10137 -3.040136,-5.83717 -5.85999,-11.80737 -8.44854,-17.89959 -2.58855,-6.09222 -4.945796,-12.30646 -7.060718,-18.6317 C 11.427266,328.46008 9.554668,322.02385 7.935415,315.48764 6.3161621,308.95144 4.9502539,302.31525 3.8487109,295.59012 2.747168,288.86498 1.9099902,282.05089 1.3481982,275.15886 0.78640625,268.26684 0.5,261.29687 0.5,254.26 c 0,-8.75938 0.44378906,-17.41508 1.3101099,-25.94585 0.8663208,-8.53078 2.1551733,-16.93662 3.8453003,-25.19628 1.6901269,-8.25966 3.7815283,-16.37313 6.2529468,-24.31916 2.471418,-7.94602 5.322854,-15.72461 8.533049,-23.31449 3.210196,-7.58988 6.779151,-14.99107 10.685608,-22.18229 3.906458,-7.19122 8.150418,-14.17249 12.710623,-20.92254 4.560205,-6.75004 9.436655,-13.268877 14.608093,-19.535237 5.171438,-6.26636 10.637864,-12.280247 16.37802,-18.020403 5.740156,-5.740156 11.754043,-11.206582 18.020403,-16.37802 6.26636,-5.171438 12.785197,-10.047888 19.535237,-14.608093 6.75005,-4.560205 13.73132,-8.804165 20.92254,-12.710623 7.19122,-3.906457 14.59241,-7.475412 22.18229,-10.685608 7.58988,-3.210195 15.36847,-6.061631 23.31449,-8.533049 7.94603,-2.4714185 16.0595,-4.5628199 24.31916,-6.2529468 8.25966,-1.690127 16.6655,-2.9789795 25.19628,-3.8453003 C 236.84492,0.94378906 245.50063,0.5 254.26,0.5 c 13.13875,0 26.04438,"
    + "0.9985937 38.6451,2.924043 12.60072,1.9254492 24.89654,4.7777539 36.81568,8.485176 11.91914,3.707422 23.4616,8.269961 34.55561,13.615879 11.094,5.345918 21.73955,11.475215 31.86486,18.316152 10.12531,6.840937 19.73039,14.393516 28.74346,22.585996 9.01306,8.192481 17.43412,17.024863 25.19138,26.42541 7.75727,9.400544 14.85075,19.369254 21.20866,29.834394 6.35791,10.46514 11.98025,21.4267 16.79525,32.81295 h 27.6475 27.6475 27.6475 27.6475";
    leftPath.CreateFromSVGString( svg, 1.0, 1.0, 41.5, 38.0, 0.0 );

    // Setup right line path
    svg = "M 0,155.49 H 27.75 55.5 83.25 111 c 4.815,-11.385 10.43719,-22.34547 16.79482,-32.80965 6.35764,-10.46418 13.45073,-20.43207 21.20752,-29.831913 7.7568,-9.399843 16.17731,-18.23164 25.18979,-26.423632 9.01248,-8.191992 18.61693,-15.74418 28.74162,-22.584805 10.12469,-6.840625 20.76961,-12.969687 31.86303,-18.31543 11.09342,-5.345742 22.63533,-9.908164 34.554,-13.615507 11.91867,-3.7073442 24.2141,-6.5596099 36.81455,-8.4850396 C 318.76578,1.4985937 331.67125,0.5 344.81,0.5 c 8.76188,0 17.41977,0.44378906 25.95244,1.3101099 8.53268,0.8663208 16.94015,2.1551733 25.20117,3.8453003 8.26103,1.6901269 16.37561,3.7815283 24.32253,6.2529468 7.94692,2.471418 15.72616,5.322854 23.31652,8.533049 7.59035,3.210196 14.9918,6.779151 22.18313,10.685608 7.19133,3.906458 14.17254,8.150418 20.92239,12.710623 6.74986,4.560205 13.26836,9.436655 19.53428,14.608093 6.26592,5.171438 12.27926,10.637864 18.01879,16.37802 5.73953,5.740156 11.20525,11.754043 16.37594,18.020403 5.17069,6.26636 10.04634,12.785197 14.60572,19.535237 4.55938,6.75005 8.80251,13.73132 12.70813,20.92254 3.90563,7.19122 7.47376,14.59241 10.68318,22.18229 3.20941,7.58988 6.06011,15.36847 8.53085,23.31449 2.47075,7.94603 4.56154,16.0595 6.25116,24.31916 1.68962,8.25966 2.97806,16.6655 3.8441,25.19628 0.86604,8.53077 1.30967,17.18647 1.30967,25.94585 0,7.03688 -0.28641,14.00684 -0.8482,20.89886 -0.56179,6.89203 -1.39896,13.70612 -2.50049,20.43126 -1.10153,6.72513 -2.46743,13.36132 -4.08666,19.89752 -1.61923,6.53621 -3.4918,12.97244 -5.60668,19.29767 -2.11488,6.32524 -4.47208,12.53948 -7.06057,18.6317 -2.58849,6.09222 -5.40827,12.06242 -8.44832,17.89959 -3.04005,5.83717 -6.30036,11.5413 -9.76993,17.10137 -3.46956,5.56008 -7.14837,10.97609 -11.0254,16.23703 -3.87703,5.26094 -7.95229,10.3668 -12.21474,15.30656 -4.26245,4.93976 -8.71211,9.71342 -13.33794,14.30996 -4.62583,4.59655 -9.42783,9.01597 -14.39499,13.24725 -4.96716,4.23129 -10.09948,8.27443 -15.38592,12.11842 -5.28645,3.84398 -10.72703,7.48881 -16.31071,10.92345 -5.58368,3.43464 -11.31048,6.65911"
    + " -17.16935,9.66237 -5.85888,3.00326 -11.84984,5.78532 -17.96187,8.33516 -6.11202,2.54984 -12.3451,4.86745 -18.68823,6.94183 l 0.24,2 10.4425,20.70125 10.4425,20.70125 10.4425,20.70125 10.4425,20.70125 10.4425,20.70125 10.4425,20.70125 10.4425,20.70125 L 507.54,663.11";
    rightPath.CreateFromSVGString( svg, 1.0, 1.0, 0.0, 38.0, 0.0 );
  }

  $rect <20,20,160,60>
  object Views::StrokePath LeftStrokePath
  {
    preset Bounds = <0,0,640,720>;
    preset Color = Dashboard::Colors.BatteryGaugeSelectionV1;
    preset MiterLimit = 10.0;
    preset JoinPoints = Graphics::PathJoin.Miter;
    preset StartCap = Graphics::PathCap.Round;
    preset Path = leftPath;
  }

  $rect <20,20,160,60>
  object Views::StrokePath RightStrokePath
  {
    preset Bounds = <640,0,1280,720>;
    preset Color = Dashboard::Colors.BatteryGaugeSelectionV1;
    preset MiterLimit = 10.0;
    preset JoinPoints = Graphics::PathJoin.Miter;
    preset StartCap = Graphics::PathCap.Round;
    preset Path = rightPath;
  }

  $rect <20,20,160,60>
  object Views::Image TopGlow
  {
    preset Bounds = <461,-5,818,193>;
    preset Color = Dashboard::Colors.GaugeGlowV1;
    preset Bitmap = Dashboard::TopGloomV1;
  }

  $rect <20,20,160,60>
  object Views::Image RightBottomGlow
  {
    preset Bounds = <1064,501,1244,836>;
    preset Color = Dashboard::Colors.GaugeGlowV1;
    preset Bitmap = Dashboard::RightBottomGloomV1;
  }

  $rect <20,20,160,60>
  object Views::Image LeftBottomGlow
  {
    preset Bounds = <36,501,216,836>;
    preset Color = Dashboard::Colors.GaugeGlowV1;
    preset Bitmap = Dashboard::LeftBottomGloomV1;
  }

  $rect <20,20,160,60>
  object Dashboard::Gauge SpeedGauge
  {
    preset Bounds = <62,57,532,527>;
    preset Outlet = ^Dashboard::Device.Speed;
    preset Clockwise = true;
  }

  $rect <20,20,160,60>
  object Dashboard::Gauge PowerGauge
  {
    preset Bounds = <748,57,1218,527>;
    preset Outlet = ^Dashboard::Device.Energy;
    preset Clockwise = false;
  }

  // Line path
  note group Note
  {
    attr Bounds = <210,740,770,910>;
  }

  // This is the first variant of the dashboard.
  note legend Note1
  {
    attr Bounds = <780,740,1290,840>;
  }
}

$rect <470,51,670,91>
$output false
resource Resources::Bitmap StartEngine
{
  attr bitmapfile FileName = .\Res\StartEngine.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <10,50,210,90>
$output false
class StartScreen : Core::Group
{
  $rect <0,740,200,780>
  inherited property Bounds = <0,0,1280,720>;

  $rect <0,780,200,820>
  inherited method Init()
  {
    attachobserver onAutoDemoModeChanged, ^Dashboard::Device.AutoDemoMode;
    postsignal onAutoDemoModeChanged;

    $if $composer
    StartEngineGloom.Opacity = 255;
    $endif
  }

  $rect <218,800,418,840>
  slot onStart
  {
    // Initialize the device properties
    Dashboard::Device.Speed = 0;
    Dashboard::Device.Energy = 0;
    Dashboard::Device.Battery = 67;
    Dashboard::Device.ODO = 267;
    Dashboard::Device.Led0 = false;
    Dashboard::Device.Led1 = false;
    Dashboard::Device.Led2 = false;
    Dashboard::Device.Led3 = false;
    Dashboard::Device.Led4 = false;
    Dashboard::Device.Led5 = false;

    signal glowEffect.StartEffect;
  }

  $rect <218,840,418,880>
  object Effects::Int32Effect glowEffect
  {
    preset OnFinished = onGlowEffectFinished;
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 750;
    preset Outlet = ^StartEngineGloom.Opacity;
  }

  $rect <218,880,418,920>
  slot onGlowEffectFinished
  {
    // Leave this dialog and show another one
    if ( IsDialog( false ))
      Owner.SwitchToDialog( new Dashboard::Dashboard, Dashboard::FadeInOutBottom, null, null, null, null, null, null, null, null, false );
  }

  // Show glow / Screen change
  note group Note
  {
    attr Bounds = <209,740,429,931>;
  }

  // This is the start screen.
  //
  // You can activate the 'Start Engine' button to start a transition to the dashboard \
  // screen.
  note legend Note1
  {
    attr Bounds = <669,740,1058,849>;
  }

  $rect <20,20,160,60>
  object Views::Image StartEngineGloom
  {
    preset Bounds = <134,86,1158,667>;
    preset Bitmap = Dashboard::StartEngineGloom;
    preset Opacity = 0;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton StartEngineButton
  {
    preset Bounds = <489,211,792,514>;
    preset OnActivate = onStart;
    preset IconFrameActive = 1;
    preset IconFrameFocused = 0;
    preset IconFrameDisabled = 0;
    preset IconFrameDefault = 0;
    preset Icon = Dashboard::StartEngineStates;
    preset Label = "Caption";
    preset Appearance = Dashboard::StartEngineButtonConfig;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <49,589,329,690>;
    preset Bitmap = Dashboard::Logo;
  }

  $rect <449,800,649,840>
  slot onAutoDemoModeChanged
  {
    // Start the auto demo mode timer on enabled auto demo mode
    if ( Dashboard::Device.AutoDemoMode )
      signal onStart;
  }

  // Auto demo mode
  note group Note2
  {
    attr Bounds = <440,740,660,930>;
  }
}

$rect <30,269,230,309>
$output false
class GaugeDisplay : Core::Group
{
  $rect <0,169,200,209>
  inherited property Bounds = <0,0,150,150>;

  $rect <0,220,200,260>
  property ^int32 Outlet = null;

  $rect <200,220,400,260>
  onset Outlet
  {
    // Check if the new outlet differs from the currently used outlet
    if ( pure Outlet == value )
      return;

    // Detach from the previous outlet
    if ( pure Outlet != null )
      detachobserver onOutlet, pure Outlet;

    // Store the new outlet ...
    pure Outlet = value;

    // ... and attach to the new one
    if ( value != null )
      attachobserver onOutlet, value;

    // Finally, retrieve the current state of the property associated via 'Outlet'.
    if ( value != null )
      postsignal onOutlet;
  }

  $rect <400,220,600,260>
  slot onOutlet
  {
    if ( Outlet != null )
      ValueText.String = Outlet^;
  }

  $rect <0,260,200,300>
  property string Unit = "Watt";

  $rect <200,260,400,300>
  onset Unit
  {
    // The value doesn't change - nothing to do.
    if ( pure Unit == value )
      return;

    // Remember the property's new value.
    pure Unit = value;

    UnitText.String = value;
  }

  $rect <0,350,200,390>
  property string Desc = "BATT";

  $rect <200,350,400,390>
  onset Desc
  {
    // The value doesn't change - nothing to do.
    if ( pure Desc == value )
      return;

    // Remember the property's new value.
    pure Desc = value;

    postsignal onOutletDesc;
  }

  $rect <0,310,200,350>
  property ^int32 OutletDesc = null;

  $rect <200,310,400,350>
  onset OutletDesc
  {
    // Check if the new outlet differs from the currently used outlet
    if ( pure OutletDesc == value )
      return;

    // Detach from the previous outlet
    if ( pure OutletDesc != null )
      detachobserver onOutletDesc, pure OutletDesc;

    // Store the new outlet ...
    pure OutletDesc = value;

    // ... and attach to the new one
    if ( value != null )
      attachobserver onOutletDesc, value;

    // Finally, retrieve the current state of the property associated via 'Outlet'.
    if ( value != null )
      postsignal onOutletDesc;
  }

  $rect <409,350,609,390>
  slot onOutletDesc
  {
    // Set the new value at the description text
    if ( OutletDesc != null )
      DescText.String = Desc + string(OutletDesc^) + DescUnit;
  }

  $rect <0,390,200,430>
  property string DescUnit = "%%";

  $rect <200,390,400,430>
  onset DescUnit
  {
    // The value doesn't change - nothing to do.
    if ( pure DescUnit == value )
      return;

    // Remember the property's new value.
    pure DescUnit = value;

    postsignal onOutletDesc;
  }

  $rect <20,20,160,60>
  object Views::Text DescText
  {
    preset Bounds = <0,122,150,147>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = Desc + "  58" + DescUnit;
    preset Font = Dashboard::FontLightM;
    preset Color = Dashboard::Colors.Text;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <143,116>;
    preset Point1 = <6,116>;
    preset Width = 4;
    preset Color = Dashboard::Colors.Text;
  }

  $rect <20,20,160,60>
  object Views::Text UnitText
  {
    preset Bounds = <8,60,140,110>;
    preset String = "kW";
    preset Font = Dashboard::FontXL;
    preset Color = Dashboard::Colors.Text;
  }

  $rect <20,20,160,60>
  object Views::Text ValueText
  {
    preset Bounds = <11,-11,138,67>;
    preset String = "40";
    preset Font = Dashboard::FontXXL;
    preset Color = Dashboard::Colors.Text;
  }
}

$rect <470,130,670,170>
$output false
resource Resources::Bitmap StartEngineGloom
{
  attr bitmapfile FileName = .\Res\StartEngineGloom.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <670,50,870,90>
$output false
resource Resources::Bitmap LeftBottomGloomV1
{
  attr bitmapfile FileName = .\Res\LeftBottomGloomV1.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <670,90,870,130>
$output false
resource Resources::Bitmap RightBottomGloomV1
{
  attr bitmapfile FileName = .\Res\RightBottomGloomV1.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <670,130,870,170>
$output false
resource Resources::Bitmap TopGloomV1
{
  attr bitmapfile FileName = .\Res\TopGloomV1.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

// Device class
note group Note4
{
  attr Bounds = <460,409,880,510>;
}

$rect <469,449,669,489>
$output false
class DeviceClass
{
  $rect <210,40,410,80>
  property int32 Speed = 0;

  $rect <410,40,610,80>
  onset Speed
  {
    // The value doesn't change - nothing to do.
    if ( pure Speed == value )
      return;

    // Remember the property's new value.
    pure Speed = value;

    notifyobservers ^Speed;
  }

  $rect <210,130,410,170>
  property int32 Energy = 0;

  $rect <410,130,610,170>
  onset Energy
  {
    // The value doesn't change - nothing to do.
    if ( pure Energy == value )
      return;

    // Remember the property's new value.
    pure Energy = value;

    notifyobservers ^Energy;
  }

  $rect <210,80,410,120>
  property int32 ODO = 267;

  $rect <410,80,610,120>
  onset ODO
  {
    // The value doesn't change - nothing to do.
    if ( pure ODO == value )
      return;

    // Remember the property's new value.
    pure ODO = value;

    notifyobservers ^ODO;
  }

  $rect <210,170,410,210>
  property int32 Battery = 67;

  $rect <410,170,610,210>
  onset Battery
  {
    // The value doesn't change - nothing to do.
    if ( pure Battery == value )
      return;

    // Remember the property's new value.
    pure Battery = value;

    notifyobservers ^Battery;
  }

  $rect <210,220,410,260>
  property bool Led0 = false;

  $rect <410,220,610,260>
  onset Led0
  {
    // The value doesn't change - nothing to do.
    if ( pure Led0 == value )
      return;

    // Remember the property's new value.
    pure Led0 = value;

    notifyobservers ^Led0;
  }

  $rect <210,260,410,300>
  property bool Led1 = false;

  $rect <410,260,610,300>
  onset Led1
  {
    // The value doesn't change - nothing to do.
    if ( pure Led1 == value )
      return;

    // Remember the property's new value.
    pure Led1 = value;

    notifyobservers ^Led1;
  }

  $rect <210,300,410,340>
  property bool Led2 = false;

  $rect <410,300,610,340>
  onset Led2
  {
    // The value doesn't change - nothing to do.
    if ( pure Led2 == value )
      return;

    // Remember the property's new value.
    pure Led2 = value;

    notifyobservers ^Led2;
  }

  $rect <210,340,410,380>
  property bool Led3 = false;

  $rect <410,340,610,380>
  onset Led3
  {
    // The value doesn't change - nothing to do.
    if ( pure Led3 == value )
      return;

    // Remember the property's new value.
    pure Led3 = value;

    notifyobservers ^Led3;
  }

  $rect <210,380,410,420>
  property bool Led4 = false;

  $rect <410,380,610,420>
  onset Led4
  {
    // The value doesn't change - nothing to do.
    if ( pure Led4 == value )
      return;

    // Remember the property's new value.
    pure Led4 = value;

    notifyobservers ^Led4;
  }

  $rect <210,420,410,460>
  property bool Led5 = false;

  $rect <410,420,610,460>
  onset Led5
  {
    // The value doesn't change - nothing to do.
    if ( pure Led5 == value )
      return;

    // Remember the property's new value.
    pure Led5 = value;

    notifyobservers ^Led5;
  }

  $rect <210,470,410,510>
  property bool DemoMode = false;

  $rect <410,470,610,510>
  onset DemoMode
  {
    // The value doesn't change - nothing to do.
    if ( pure DemoMode == value )
      return;

    // Remember the property's new value.
    pure DemoMode = value;

    notifyobservers ^DemoMode;
  }

  // Device interface properties
  note group Note
  {
    attr Bounds = <0,0,620,560>;
  }

  $rect <210,510,410,550>
  property bool AutoDemoMode = false;

  $rect <410,510,610,550>
  onset AutoDemoMode
  {
    // The value doesn't change - nothing to do.
    if ( pure AutoDemoMode == value )
      return;

    // Remember the property's new value.
    pure AutoDemoMode = value;

    notifyobservers ^AutoDemoMode;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <10,40,210,80>
  $output true
  method void UpdateSpeed( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Speed )
    {
      // Remember the new value in the internal memory of the property.
      pure Speed = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Speed;
    }
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <10,80,210,120>
  $output true
  method void UpdateODO( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure ODO )
    {
      // Remember the new value in the internal memory of the property.
      pure ODO = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^ODO;
    }
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <10,130,210,170>
  $output true
  method void UpdateEnergy( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Energy )
    {
      // Remember the new value in the internal memory of the property.
      pure Energy = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Energy;
    }
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <10,170,210,210>
  $output true
  method void UpdateBattery( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Battery )
    {
      // Remember the new value in the internal memory of the property.
      pure Battery = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Battery;
    }
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <10,220,210,260>
  $output true
  method void UpdateLed0( arg bool aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Led0 )
    {
      // Remember the new value in the internal memory of the property.
      pure Led0 = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Led0;
    }
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <10,260,210,300>
  $output true
  method void UpdateLed1( arg bool aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Led1 )
    {
      // Remember the new value in the internal memory of the property.
      pure Led1 = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Led1;
    }
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <10,300,210,340>
  $output true
  method void UpdateLed2( arg bool aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Led2 )
    {
      // Remember the new value in the internal memory of the property.
      pure Led2 = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Led2;
    }
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <10,340,210,380>
  $output true
  method void UpdateLed3( arg bool aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Led3 )
    {
      // Remember the new value in the internal memory of the property.
      pure Led3 = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Led3;
    }
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <10,380,210,420>
  $output true
  method void UpdateLed4( arg bool aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Led4 )
    {
      // Remember the new value in the internal memory of the property.
      pure Led4 = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Led4;
    }
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <10,420,210,460>
  $output true
  method void UpdateLed5( arg bool aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Led5 )
    {
      // Remember the new value in the internal memory of the property.
      pure Led5 = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Led5;
    }
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <10,470,210,510>
  $output true
  method void UpdateDemoMode( arg bool aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure DemoMode )
    {
      // Remember the new value in the internal memory of the property.
      pure DemoMode = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^DemoMode;
    }
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <10,510,210,550>
  $output true
  method void UpdateAutoDemoMode( arg bool aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure AutoDemoMode )
    {
      // Remember the new value in the internal memory of the property.
      pure AutoDemoMode = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^AutoDemoMode;
    }
  }
}

$rect <669,449,869,489>
$output false
autoobject Dashboard::DeviceClass Device;

$rect <241,229,441,269>
$output false
class Clock : Core::Group
{
  $rect <0,50,200,90>
  inherited property Bounds = <0,0,90,40>;

  $rect <10,160,210,200>
  object Core::Timer clockTimer
  {
    preset OnTrigger = onClockUpdate;
    preset Period = 30000;
    preset Begin = 1;
    preset Enabled = true;
  }

  $rect <10,200,210,240>
  slot onClockUpdate
  {
    var Core::Time currentTime = (new Core::Time).CurrentTime;
    Text.String = currentTime.Format( "%H:%M" );
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,90,40>;
    preset String = "14:30";
    preset Font = Dashboard::FontLightL;
    preset Color = Dashboard::Colors.Text;
  }

  // Update clock each 30 sec
  note group Note
  {
    attr Bounds = <0,100,220,250>;
  }
}

$rect <470,260,670,300>
$output false
resource Resources::Bitmap Icons
{
  attr bitmapfile FileName = .\Res\Icons.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize = <42,42>;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <210,90,410,130>
$output false
class DashboardV2 : Core::Group
{
  $rect <0,740,200,780>
  inherited property Bounds = <0,0,1280,720>;

  $rect <399,960,599,1000>
  inherited method UpdateViewState()
  {
    super( aState );

    // Increase opacity of housings
    LeftHousing.Opacity = (uint8)Dashboard::Animation.linearValueProgress( 0, 255, 0.4, 0.6, CurrentProgress );
    RightHousing.Opacity = (uint8)Dashboard::Animation.linearValueProgress( 0, 255, 0.4, 0.6, CurrentProgress );

    // Move vertical bars
    SpeedBar.Bounds.origin = Dashboard::Animation.linearPointProgess( <-403,46>, <84,46>, 0.3, 0.7, CurrentProgress );
    EnergyBar.Bounds.origin = Dashboard::Animation.linearPointProgess( <1280,46>, <795,46>, 0.3, 0.7, CurrentProgress );

    // Move the left and right glows with the vertical bars
    LeftGlow.Bounds.origin = Dashboard::Animation.linearPointProgess( <-310,46>, <177,67>, 0.3, 0.7, CurrentProgress );
    RightGlow.Bounds.origin = Dashboard::Animation.linearPointProgess( <1360,46>, <875,67>, 0.3, 0.7, CurrentProgress );

    // Increase the opacity of the left and right glows
    LeftGlow.Opacity = (uint8)Dashboard::Animation.linearValueProgress( 0, 255, 0.6, 0.8, CurrentProgress );
    RightGlow.Opacity = (uint8)Dashboard::Animation.linearValueProgress( 0, 255, 0.6, 0.8, CurrentProgress );

    // Animate left path
    var int32 noOfEdges = leftPath.GetNoOfEdges( 0 );
    var int32 progress = noOfEdges - Dashboard::Animation.linearValueProgress( 0, noOfEdges, 0.85, 1.0, CurrentProgress );
    leftGrowingPath.InitSubPath( 0, noOfEdges );
    leftGrowingPath.AddCopy( 0, leftPath, 0, progress, noOfEdges - progress );
    LeftStrokePath.Path = leftGrowingPath;

    // Animate right path
    noOfEdges = rightPath.GetNoOfEdges( 0 );
    progress = Dashboard::Animation.linearValueProgress( 0, noOfEdges, 0.85, 1.0, CurrentProgress );
    rightGrowingPath.InitSubPath( 0, noOfEdges );
    rightGrowingPath.AddCopy( 0, rightPath, 0, 0, progress );
    RightStrokePath.Path = rightGrowingPath;
  }

  $rect <0,780,200,820>
  inherited method Init()
  {
    $if $composer
    CurrentProgress = 1.0;
    $endif

    signal createPath;
  }

  $rect <220,780,420,820>
  slot createPath
  {
    // Setup left line path
    var string svg = "m 0,1.73 h 32 32 c 7.5,0 16.5,2.1675 24.94375,5.66 C 97.3875,10.8825 105.275,15.7 110.55,21 L 134,44.45 c 5.3,5.3 13.1825,10.1175 21.61375,13.61 8.43125,3.4925 17.41125,5.66 24.90625,5.66 h 27.05625 27.05625 27.05625 27.05625 27.05625 27.05625 27.05625 27.05625";
    leftPath.CreateFromSVGString( svg, 1.0, 1.0, 243.5, 129.6, 0.0 );

    // Setup right line path
    svg = "m 396.97,63.72 h 27.05625 27.05625 27.05625 27.05625 27.05625 27.05625 27.05625 27.05625 c 7.5,0 16.48,-2.475 24.90875,-6.275 C 646.7575,53.645 654.635,48.52 659.93,43.22 L 671.66,31.495 683.39,19.77 C 688.695,14.47 696.5775,9.6525 705.0075,6.16 713.4375,2.6675 722.415,0.5 729.91,0.5 h 32 32";
    rightPath.CreateFromSVGString( svg, 1.0, 1.0, -396.5, 129.6, 0.0 );
  }

  $rect <201,920,401,960>
  onset Outlet
  {
    // Check if the new outlet differs from the currently used outlet
    if ( pure Outlet == value )
      return;

    // Detach from the previous outlet
    if ( pure Outlet != null )
      detachobserver onOutlet, pure Outlet;

    // Store the new outlet ...
    pure Outlet = value;

    // ... and attach to the new one
    if ( value != null )
      attachobserver onOutlet, value;

    // Finally, retrieve the current state of the property associated via 'Outlet'.
    if ( value != null )
      postsignal onOutlet;
  }

  // The property 'Outlet' can refer to any other 'int32' property the widget should \
  // remain synchronized with. When the referred property is modified, the widget \
  // is automatically notified to remain in sync with the property.
  // This approach follows the Controller-View programming paradigm. Here the widget \
  // represents the 'View' and the property referred via 'Outlet' can be seen as \
  // a part of the 'Controller'.
  $rect <1,920,201,960>
  property ^float Outlet = null;

  // This slot method will receive a signal, if the value of the property assigned \
  // to @Outlet has been changed by another widget or by the application logic. In \
  // response to this notification, the widget will update itself.
  $rect <401,920,601,960>
  slot onOutlet
  {
    // Read the current value of the associated property and update accordingly
    // the state of the widget.
    if ( Outlet != null )
      CurrentProgress = Outlet^;
  }

  $rect <0,961,200,1001>
  property float CurrentProgress = 0.0;

  $rect <200,961,400,1001>
  onset CurrentProgress
  {
    // The value doesn't change - nothing to do.
    if ( pure CurrentProgress == value )
      return;

    // Remember the property's new value.
    pure CurrentProgress = value;

    InvalidateViewState();
  }

  $rect <220,860,420,900>
  object Graphics::Path rightPath;

  $rect <220,820,420,860>
  object Graphics::Path leftPath;

  $rect <420,820,620,860>
  object Graphics::Path leftGrowingPath;

  $rect <421,860,621,900>
  object Graphics::Path rightGrowingPath;

  $rect <20,20,160,60>
  object Views::StrokePath RightStrokePath
  {
    preset Bounds = <640,0,1280,720>;
    preset Color = Dashboard::Colors.BatteryGaugeSelectionV2;
    preset MiterLimit = 10.0;
    preset JoinPoints = Graphics::PathJoin.Miter;
    preset StartCap = Graphics::PathCap.Round;
    preset Path = rightPath;
  }

  $rect <20,20,160,60>
  object Views::StrokePath LeftStrokePath
  {
    preset Bounds = <0,0,640,720>;
    preset Color = Dashboard::Colors.BatteryGaugeSelectionV2;
    preset MiterLimit = 10.0;
    preset JoinPoints = Graphics::PathJoin.Miter;
    preset StartCap = Graphics::PathCap.Round;
    preset Path = leftPath;
  }

  $rect <20,20,160,60>
  object Views::Image LeftHousing
  {
    preset Bounds = <9,16,279,705>;
    preset Bitmap = Dashboard::LeftWing2V2;
  }

  $rect <20,20,160,60>
  object Views::Image RightHousing
  {
    preset Bounds = <1003,16,1273,705>;
    preset Bitmap = Dashboard::RightWing2V2;
  }

  $rect <20,20,160,60>
  object Dashboard::VertValueBar EnergyBar
  {
    preset Bounds = <795,46,1198,675>;
    preset Outlet = ^Dashboard::Device.Energy;
  }

  $rect <20,20,160,60>
  object Views::Image RightGlow
  {
    preset Bounds = <875,67,1104,503>;
    preset Color = Dashboard::Colors.GaugeGlowV2;
    preset Bitmap = Dashboard::RightGlowV2;
  }

  $rect <20,20,160,60>
  object Views::Image LeftGlow
  {
    preset Bounds = <177,67,405,503>;
    preset Color = Dashboard::Colors.GaugeGlowV2;
    preset Bitmap = Dashboard::LeftGlowV2;
  }

  $rect <20,20,160,60>
  object Dashboard::VertValueBar SpeedBar
  {
    preset Bounds = <7,46,410,675>;
    preset Outlet = ^Dashboard::Device.Speed;
    preset RightWing = false;
  }

  // Line path
  note group Note
  {
    attr Bounds = <210,740,770,910>;
  }

  // This is the second variant of the dashboard.
  note legend Note1
  {
    attr Bounds = <780,740,1290,840>;
  }
}

$rect <870,50,1070,90>
$output false
resource Resources::Bitmap LeftWing2V2
{
  attr bitmapfile FileName = .\Res\LeftWing2V2.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <870,90,1070,130>
$output false
resource Resources::Bitmap LeftWingV2
{
  attr bitmapfile FileName = .\Res\LeftWingV2.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <870,169,1070,209>
$output false
resource Resources::Bitmap RightWing2V2
{
  attr bitmapfile FileName = .\Res\RightWing2V2.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <870,209,1070,249>
$output false
resource Resources::Bitmap RightWingV2
{
  attr bitmapfile FileName = .\Res\RightWingV2.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

// This class implements a simple 'value bar' instrument intended to display a vertical \
// bar. The height of the bar corresponds to the value specified in the property \
// @CurrentValue, which lies in range determined by the properties @MinValue and \
// @MaxValue.
// Alternatively the property @Outlet can refer to any other 'int32' property the \
// widget should remain synchronized with. When the referred property is modified \
// by another one, the widget is automatically notified to remain in sync with the \
// property.
// This approach follows the Controller-View programming paradigm. Here the 'value \
// bar' widget represents the 'View' and the property referred via 'Outlet' can be \
// seen as a part of the 'Controller'.
$rect <241,269,441,309>
$output false
class VertValueBar : Templates::VerticalValueBar
{
  $rect <420,0,620,40>
  inherited property Bounds = <0,0,403,629>;

  $rect <889,481,1089,521>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Get the min/max positions for the upper edge of the value bar.
    var int32 minPos = 59;
    var int32 maxPos = Bounds.h;
    var int32 oldPos = ValueStrokePath.Bounds.y1;
    var int32 newPos = minPos;

    // Convert the widget's current value to a pixel position within the
    // allowed range.
    if ( MaxValue != MinValue )
      newPos = ((( -CurrentValue + MaxValue ) * ( maxPos - minPos )) /
                 ( MaxValue - MinValue )) + minPos;

    // If the just calculated position does differ from the actual (old)
    // position, adjust the size and evtl. the position of your views.
    if ( newPos != oldPos )
    {
      ValueStrokePath.Bounds.y1 = newPos;
      ValueStrokePath.Offset.y = -newPos + minPos;

      // Take care that the needle is shown at the max value
      if ( newPos == minPos )
       newPos = minPos + 3;

      NeedleStrokePath.Bounds.y1 = newPos - 3;
      NeedleStrokePath.Bounds.y2 = newPos;
      NeedleStrokePath.Offset.y = -newPos + 3 + minPos;
    }
  }

  $rect <420,40,620,80>
  inherited method Init()
  {
    signal setupLabels;
    postsignal setup;

    $if $composer
    CurrentValue = 60;
    $endif
  }

  // State management
  note group Note2
  {
    attr Bounds = <879,441,1099,531>;
  }

  // Controller events
  note group Note1
  {
    attr Bounds = <879,341,1099,431>;
  }

  // This slot method will receive a signal, if the value of the property assigned \
  // to @Outlet has been changed by another widget or by the application logic. In \
  // response to this notification, the widget will update itself.
  $rect <889,381,1089,421>
  slot onOutlet
  {
    // Read the current value of the associated property and update accordingly
    // the state of the widget.
    if ( Outlet != null )
      CurrentValue = Outlet^;
  }

  $rect <620,250,820,290>
  onset Outlet
  {
    // Check if the new outlet differs from the currently used outlet
    if ( pure Outlet == value )
      return;

    // Detach from the previous outlet
    if ( pure Outlet != null )
      detachobserver onOutlet, pure Outlet;

    // Store the new outlet ...
    pure Outlet = value;

    // ... and attach to the new one
    if ( value != null )
      attachobserver onOutlet, value;

    // Finally, retrieve the current state of the property associated via 'Outlet'.
    if ( value != null )
      postsignal onOutlet;
  }

  $rect <620,170,820,210>
  onset MaxValue
  {
    // Check if the given value differs from the current value
    if ( pure MaxValue == value )
      return;

    // Store the new value ...
    pure MaxValue = value;

    // ... and finally, force an update
    InvalidateViewState();
  }

  $rect <620,131,820,171>
  onset MinValue
  {
    // Check if the given value differs from the current value
    if ( pure MinValue == value )
      return;

    // Store the new value ...
    pure MinValue = value;

    // ... and finally, force an update
    InvalidateViewState();
  }

  $rect <820,210,1020,250>
  onget CurrentValue
  {
    // Get the internally stored value of the property 'CurrentValue'.
    var int32 value = pure CurrentValue;

    // When reading the property 'CurrentValue' limit the result to the
    // range specified by the properties 'MinValue' and 'MaxValue'.
    // Note, the range can be 'inverted'.
    if ( MinValue > MaxValue )
    {
      if ( value < MaxValue ) value = MaxValue;
      if ( value > MinValue ) value = MinValue;
    }
    else
    {
      if ( value < MinValue ) value = MinValue;
      if ( value > MaxValue ) value = MaxValue;
    }

    return value;
  }

  $rect <620,210,820,250>
  onset CurrentValue
  {
    // Check if the given value differs from the current value.
    if ( pure CurrentValue == value )
      return;

    // Store the new value ...
    pure CurrentValue = value;

    // ... and finally, force an update.
    InvalidateViewState();
  }

  // The property 'Outlet' can refer to any other 'int32' property the widget should \
  // remain synchronized with. When the referred property is modified, the widget \
  // is automatically notified to remain in sync with the property.
  // This approach follows the Controller-View programming paradigm. Here the widget \
  // represents the 'View' and the property referred via 'Outlet' can be seen as \
  // a part of the 'Controller'.
  $rect <420,250,620,290>
  property ^int32 Outlet = null;

  // The property 'MaxValue' defines the widget's possible value at the upper end \
  // of the bar movement range.
  $rect <420,170,620,210>
  property int32 MaxValue = 100;

  // The property 'MinValue' defines the widget's possible value at the lower end \
  // of the bar movement range.
  $rect <420,130,620,170>
  property int32 MinValue = 0;

  // The property 'CurrentValue' stores the momentary value of the widget. The value \
  // is limited automatically to the range between @MinValue and @MaxValue.
  $rect <420,210,620,250>
  property int32 CurrentValue = 50;

  $rect <420,80,620,120>
  slot setup
  {
    var string valuePathString;
    var string needlePathString;

    // Setup the vertical bar as right wing
    if ( RightWing )
    {
      // Setup both vertical bar path
      valuePathString = "M200.74,152.5,141.06,0h-21l59.68,152.5c4.31,11,4.84,28.5,1.2,39.77L74.79,520.44c-3.72,11.49-15.38,24.1-26.55,28.7L0,569H8.62l11.82.23,48.8-20.09c11.17-4.6,22.83-17.21,26.55-28.7L201.94,192.27C205.58,181,205.05,163.53,200.74,152.5Z";
      needlePathString = "M208.74,152.5,149.06,0h-29l59.68,152.5c4.31,11,4.84,28.5,1.2,39.77L74.79,520.44c-3.72,11.49-15.38,24.1-26.55,28.7L0,569H6.62l11.82.23.45-.19,9.55.19,48.8-20.09c11.17-4.6,22.83-17.21,26.55-28.7L209.94,192.27C213.58,181,213.05,163.53,208.74,152.5Z";
      ValueStrokePath.Bounds.origin.x = 198;
      NeedleStrokePath.Bounds.origin.x = ValueStrokePath.Bounds.origin.x - 8;

      // Set the right wing bitmap
      Wing.Bitmap = Dashboard::RightWingV2;
    }
    // Otherwise as left wing
    else
    {
      // Setup both vertical bar path
      valuePathString = "M3.62,152.5,63.29,0h21L24.62,152.5c-4.32,11-4.84,28.5-1.2,39.77L129.57,520.44c3.72,11.49,15.38,24.1,26.55,28.7L204.36,569h-8.63l-11.82.23-48.79-20.09c-11.17-4.6-22.83-17.21-26.55-28.7L2.42,192.27C-1.22,181-.7,163.53,3.62,152.5Z";
      needlePathString = "M3.62,152.5,63.29,0h29L32.62,152.5c-4.32,11-4.84,28.5-1.2,39.77L137.57,520.44c3.72,11.49,15.38,24.1,26.55,28.7L212.36,569h-6.63l-11.82.23-.45-.19-9.55.19-48.79-20.09c-11.17-4.6-22.83-17.21-26.55-28.7L2.42,192.27C-1.22,181-.7,163.53,3.62,152.5Z";
      ValueStrokePath.Bounds.origin.x = 0;
      NeedleStrokePath.Bounds.origin.x = ValueStrokePath.Bounds.origin.x;

      // Set the left wing bitmap
      Wing.Bitmap = Dashboard::LeftWingV2;
    }

    // Create from the path data the complete vertical bar paths
    verticalValuePath.CreateFromSVGString( valuePathString, 1.0, 1.0, 0.0, 0.0, 0.0 );
    needlePath.CreateFromSVGString( needlePathString, 1.0, 1.0, 0.0, 0.0, 0.0 );

    // Setup the text labels
    postsignal adjustLabels;
  }

  // Vertical Bar
  note group Note
  {
    attr Bounds = <660,341,870,471>;
  }

  // The property 'RightWing' determines the appearance of this widget as left or \
  // right oriented vertical bar.
  $rect <420,290,620,330>
  property bool RightWing = true;

  $rect <620,290,820,330>
  onset RightWing
  {
    // The value doesn't change - nothing to do.
    if ( pure RightWing == value )
      return;

    // Remember the property's new value.
    pure RightWing = value;

    postsignal setup;
  }

  $rect <670,381,860,421>
  object Graphics::Path verticalValuePath;

  $rect <670,421,860,461>
  object Graphics::Path needlePath;

  $rect <20,20,160,60>
  object Views::Image Wing
  {
    preset Bounds = <0,0,403,629>;
    preset Color = Dashboard::Colors.WingV2;
    preset Bitmap = Dashboard::RightWingV2;
  }

  $rect <20,20,160,60>
  object Views::FillPath ValueStrokePath
  {
    preset Bounds = <0,344,240,628>;
    preset Color = Dashboard::Colors.GaugeGlowV2;
    preset Offset = <0,-20>;
    preset Path = verticalValuePath;
  }

  $rect <20,20,160,60>
  object Views::FillPath NeedleStrokePath
  {
    preset Bounds = <185,310,425,313>;
    preset Color = Dashboard::Colors.GaugeGlowV2;
    preset Offset = <0,-20>;
    preset Path = needlePath;
  }

  // The difference between the values of consecutive labels.
  $rect <430,381,630,421>
  var int32 increment = 10;

  $rect <430,461,630,501>
  slot setupLabels
  {
    // Create and setup the text labels
    var int32 i = 0;
    while ( i < label.size )
    {
      var Views::Text txt = new Views::Text;

      if ( i % 2 == 0 )
        txt.Font = Dashboard::FontLightM;
      else
        txt.Font = Dashboard::FontL;

      txt.Color = Dashboard::Colors.Text;
      txt.AutoSize = true;
      label[i] = txt;

      i = i + 1;
    }
  }

  // The array containing the dynamically created text view for the label text elements.
  $rect <430,421,630,461>
  array Views::Text label[ 10 ];

  $rect <430,501,630,541>
  slot adjustLabels
  {
    var int32 xoffset = 115;
    var int32 yoffset = 56;
    var int32 direction = -1;

    if ( RightWing )
    {
      xoffset = 290;
      direction = 1;
    }

    // Adjust labels
    var int32 i = 0;
    while ( i < label.size )
    {
      label[i].String = string((label.size - i) * increment);

      // Position text views
      if ( i < 4 )
        label[i].Bounds.origin = point( xoffset + (i * 18 * direction), yoffset + (i * 57));
      else
        label[i].Bounds.origin = point( xoffset + (108 * direction) + (i * 17 * -direction), yoffset + (i * 57));

      // Add text views if needed
      if ( label[i].Owner == null )
        Add( label[i], 0 );

      i = i + 1;
    }
  }

  // Text label
  note group Note3
  {
    attr Bounds = <420,341,640,551>;
  }

  // This is the vertical value bar which is used at the second dashboard variant.
  //
  // By changing the 'RightWing' property you can determine the appearance of this \
  // component as right or left oriented vertical bar.
  note legend Note4
  {
    attr Bounds = <420,560,910,680>;
  }
}

$rect <870,130,1070,170>
$output false
resource Resources::Bitmap LeftGlowV2
{
  attr bitmapfile FileName = .\Res\LeftGlowV2.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <870,248,1070,288>
$output false
resource Resources::Bitmap RightGlowV2
{
  attr bitmapfile FileName = .\Res\RightGlowV2.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

// This class implements a simple 'value bar' instrument intended to display a horizontal \
// bar. The width of the bar corresponds to the value specified in the property @CurrentValue, \
// which lies in range determined by the properties @MinValue and @MaxValue.
// Alternatively the property @Outlet can refer to any other 'int32' property the \
// widget should remain synchronized with. When the referred property is modified \
// by another one, the widget is automatically notified to remain in sync with the \
// property.
// This approach follows the Controller-View programming paradigm. Here the 'value \
// bar' widget represents the 'View' and the property referred via 'Outlet' can be \
// seen as a part of the 'Controller'.
$rect <240,188,440,228>
$output false
$multilingual true
class Battery : Templates::HorizontalValueBar
{
  $rect <0,50,200,90>
  inherited property Bounds = <0,0,100,35>;

  $rect <450,40,650,80>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Get the min/max positions for the right edge of the value bar.
    var int32 minPos = Image.Bounds.x1 + 4;
    var int32 maxPos = Image.Bounds.x2 - 10;
    var int32 oldPos = Track.Bounds.x2;
    var int32 newPos = minPos;

    // Convert the widget's current value to a pixel position within the
    // allowed range.
    if ( MaxValue != MinValue )
      newPos = ((( CurrentValue - MinValue ) * ( maxPos - minPos )) /
                 ( MaxValue - MinValue )) + minPos;

    // If the just calculated position does differ from the actual (old)
    // position, adjust the size and evtl. the position of your views.
    if ( newPos != oldPos )
    {
      Track.Bounds.x2 = newPos;
    }
  }

  // State management
  note group Note2
  {
    attr Bounds = <440,0,660,90>;
  }

  // Controller events
  note group Note1
  {
    attr Bounds = <210,0,430,90>;
  }

  // This slot method will receive a signal, if the value of the property assigned \
  // to @Outlet has been changed by another widget or by the application logic. In \
  // response to this notification, the widget will update itself.
  $rect <220,40,420,80>
  slot onOutlet
  {
    // Read the current value of the associated property and update accordingly
    // the state of the widget.
    if ( Outlet != null )
      CurrentValue = Outlet^;
  }

  $rect <200,230,400,270>
  onset Outlet
  {
    // Check if the new outlet differs from the currently used outlet
    if ( pure Outlet == value )
      return;

    // Detach from the previous outlet
    if ( pure Outlet != null )
      detachobserver onOutlet, pure Outlet;

    // Store the new outlet ...
    pure Outlet = value;

    // ... and attach to the new one
    if ( value != null )
      attachobserver onOutlet, value;

    // Finally, retrieve the current state of the property associated via 'Outlet'.
    if ( value != null )
      postsignal onOutlet;
  }

  $rect <200,180,400,220>
  onset MaxValue
  {
    // Check if the given value differs from the current value
    if ( pure MaxValue == value )
      return;

    // Store the new value ...
    pure MaxValue = value;

    // ... and finally, force an update
    InvalidateViewState();
  }

  $rect <200,140,400,180>
  onset MinValue
  {
    // Check if the given value differs from the current value
    if ( pure MinValue == value )
      return;

    // Store the new value ...
    pure MinValue = value;

    // ... and finally, force an update
    InvalidateViewState();
  }

  $rect <400,100,600,140>
  onget CurrentValue
  {
    // Get the internally stored value of the property 'CurrentValue'.
    var int32 value = pure CurrentValue;

    // When reading the property 'CurrentValue' limit the result to the
    // range specified by the properties 'MinValue' and 'MaxValue'.
    // Note, the range can be 'inverted'.
    if ( MinValue > MaxValue )
    {
      if ( value < MaxValue ) value = MaxValue;
      if ( value > MinValue ) value = MinValue;
    }
    else
    {
      if ( value < MinValue ) value = MinValue;
      if ( value > MaxValue ) value = MaxValue;
    }

    return value;
  }

  $rect <200,100,400,140>
  onset CurrentValue
  {
    // Check if the given value differs from the current value.
    if ( pure CurrentValue == value )
      return;

    // Store the new value ...
    pure CurrentValue = value;

    // ... and finally, force an update.
    InvalidateViewState();
  }

  // The property 'Outlet' can refer to any other 'int32' property the widget should \
  // remain synchronized with. When the referred property is modified, the widget \
  // is automatically notified to remain in sync with the property.
  // This approach follows the Controller-View programming paradigm. Here the widget \
  // represents the 'View' and the property referred via 'Outlet' can be seen as \
  // a part of the 'Controller'.
  $rect <0,230,200,270>
  property ^int32 Outlet = null;

  // The property 'MaxValue' defines the widget's possible value at the right end \
  // of the bar movement range.
  $rect <0,180,200,220>
  property int32 MaxValue = 100;

  // The property 'MinValue' defines the widget's possible value at the left end \
  // of the bar movement range.
  $rect <0,140,200,180>
  property int32 MinValue = 0;

  // The property 'CurrentValue' stores the momentary value of the widget. The value \
  // is limited automatically to the range between @MinValue and @MaxValue.
  $rect <0,100,200,140>
  property int32 CurrentValue = 100;

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,100,35>;
    preset Color = Dashboard::Colors.BatteryFrame;
    preset Alignment = Views::ImageAlignment[AlignHorzCenter, AlignVertCenter, StretchToFill];
    preset Bitmap = Dashboard::BatteryFrame;
  }

  $rect <20,20,160,60>
  object Views::Frame Track
  {
    preset Bounds = <4,4,51,31>;
    preset Color = Dashboard::Colors.BatteryGaugeSelectionV1;
    preset Bitmap = Dashboard::BatteryEnergy;
  }

  $rect <0,270,200,310>
  property color TrackColor = Dashboard::Colors.BatteryGaugeSelectionV1;

  $rect <200,270,400,310>
  onset TrackColor
  {
    // The value doesn't change - nothing to do.
    if ( pure TrackColor == value )
      return;

    // Remember the property's new value.
    pure TrackColor = value;

    Track.Color = value;
  }
}

$rect <470,299,670,339>
$output false
resource Resources::Bitmap BatteryFrame
{
  attr bitmapfile FileName = .\Res\Battery.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <470,339,670,379>
$output false
resource Resources::Bitmap BatteryEnergy
{
  attr bitmapfile FileName = .\Res\BatteryEnergy.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <1069,328,1269,368>
$output false
resource Resources::Bitmap GaugeNeedle
{
  attr bitmapfile FileName = .\Res\GaugeNeedle.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <241,349,441,389>
$output false
class Navigation : Core::Group
{
  $rect <0,509,200,549>
  inherited method Init()
  {
    attachobserver onDemoModeChanged, ^Dashboard::Device.DemoMode;
    postsignal onDemoModeChanged;

    // Draw the waypoints connected with red lines
    $if $composer
      var int32 i = 0;
      for( i = 0; i < waypoints.size - 1; i = i + 1 )
      {
        var Views::Line line = new Views::Line;
        line.Point1 = waypoints[ i ];
        line.Point2 = waypoints[ i + 1 ];
        line.Width = 4;
        line.Color  = #FF0000FF;
        Add( line, 0 );
      }
    $endif
  }

  $rect <0,469,200,509>
  inherited property Bounds = <0,0,828,451>;

  $rect <200,510,400,550>
  inherited onset Opacity
  {
    super( value );

    // Disable alpha blending on full opacity
    Map.AlphaBlended = (value != 255);
  }

  $rect <420,549,620,589>
  var int32 currentWaypoint = 4;

  $rect <649,529,849,569>
  slot startNavigationCycle
  {
    signal moveEffect.StopEffect;

    // Setup move effect with current and next waypoint
    var point nextWp = waypoints[ currentWaypoint + 1 ] - Position.Bounds.center;
    moveEffect.Value1 = waypoints[ currentWaypoint ] - Position.Bounds.center;
    moveEffect.Value2 = nextWp;

    // Calculate depending on the distance to the next waypoint and the speed the move effect duration
    var float distance = calculateDistance( waypoints[ currentWaypoint ], waypoints[ currentWaypoint + 1 ] );
    moveEffect.CycleDuration = (int32)(distance * speedFactor);

    // Check if a hint is registered
    if ( Hints != null )
    {
      // Calculate the distance between the next and the waypoint after the next
      distance = calculateDistance( waypoints[ currentWaypoint + 1 ], waypoints[ (currentWaypoint + 2) % waypoints.size ] );
      var point nextNextWp = waypoints[ (currentWaypoint + 2) % waypoints.size ] - Position.Bounds.center;

      // Calculate the direction angle in degree
      var float length = (float)(nextNextWp.x - nextWp.x);
      var int32 direction = (int32)math_asin(length / distance);

      // Update the direction angle at the hint
      Hints.Direction = direction;
    }

    signal moveEffect.StartEffect;
  }

  $rect <649,649,849,689>
  slot onMoveEffectFinished
  {
    // Update the hint distance and map position
    signal onMoveEffect;

    // After waypoint 10 to 11 was processed. The move effect loops and
    // it should be proceeded with waypoint 1 to 2
    currentWaypoint = (currentWaypoint + 1) % (waypoints.size - 1);

    postsignal startNavigationCycle;
  }

  $rect <649,569,849,609>
  object Effects::PointEffect moveEffect
  {
    preset OnFinished = onMoveEffectFinished;
    preset OnAnimate = onMoveEffect;
    preset TimingCustom2 = 0.5;
    preset TimingCustom1 = -0.5;
    preset Timing = Effects::Timing.Custom;
    preset NoOfCycles = 1;
  }

  $rect <649,689,849,729>
  method float calculateDistance( arg point aPoint1, arg point aPoint2 )
  {
    var int32 a = aPoint2.x - aPoint1.x;
    var int32 b = aPoint2.y - aPoint1.y;
    return math_sqrt( a*a + b*b );
  }

  $rect <420,509,620,549>
  array point waypoints[ 11 ] =
  (
    Default[0] = <450,450>;
    Default[1] = <449,413>;
    Default[2] = <486,404>;
    Default[3] = <475,358>;
    Default[4] = <416,240>;
    Default[5] = <362,155>;
    Default[6] = <371,137>;
    Default[7] = <390,132>;
    Default[8] = <437,29>;
    Default[9] = <450,38>;
    Default[10] = <450,0>;
  );

  $rect <1,590,201,630>
  property Dashboard::NavigationHints Hints = null;

  $rect <649,609,849,649>
  slot onMoveEffect
  {
    // Move the map by setting the scroll offset
    Map.ScrollOffset = -moveEffect.Value;

    // If a hint is registered update its distance value
    if ( Hints != null )
    {
      var uint32 currentTime = hintTimer.GetCurrentTime();

      // Initialize the lastTime if its the first update
      if( lastHintUpdate == 0 )
        lastHintUpdate = currentTime;

      // Only update the hint every 150 ms
      if( currentTime - lastHintUpdate > 150 )
      {
        // Calculate the distance from the current position to the next waypoint
        Hints.Distance = (int32)calculateDistance( moveEffect.Value + Position.Bounds.center, waypoints[ currentWaypoint + 1 ] );

        lastHintUpdate = currentTime;
      }
    }
  }

  $rect <420,699,620,739>
  var uint32 lastHintUpdate;

  $rect <420,658,620,698>
  object Core::Timer hintTimer;

  $rect <1,551,201,591>
  property color PositionColor = Dashboard::Colors.BatteryGaugeSelectionV1;

  $rect <200,550,400,590>
  onset PositionColor
  {
    // The value doesn't change - nothing to do.
    if ( pure PositionColor == value )
      return;

    // Remember the property's new value.
    pure PositionColor = value;

    Position.Color = value;
  }

  // Map movement / Hint update
  note group Note
  {
    attr Bounds = <640,469,860,778>;
  }

  $rect <649,729,849,769>
  var float speedFactor = 40.0;

  // Waypoints
  note group Note1
  {
    attr Bounds = <409,469,629,609>;
  }

  // Hint update
  note group Note2
  {
    attr Bounds = <409,618,629,749>;
  }

  // This is the animated navigation map.
  //
  // Its animation is realized by moving a vertical looped map on a given waypoint \
  // path.
  note legend Note3
  {
    attr Bounds = <10,760,530,870>;
  }

  $rect <20,20,160,60>
  object Views::Wallpaper Map
  {
    preset Bounds = Bounds;
    preset Bitmap = Dashboard::Map;
  }

  $rect <20,20,160,60>
  object Views::Image Fading
  {
    preset Bounds = <0,0,828,451>;
    preset Color = Dashboard::Colors.Background;
    preset Bitmap = Dashboard::MapFading;
  }

  $rect <20,20,160,60>
  object Views::Image Position
  {
    preset Bounds = <406,230,426,250>;
    preset Color = Dashboard::Colors.BatteryGaugeSelectionV1;
    preset Bitmap = Dashboard::Position;
  }

  $rect <200,470,400,510>
  slot onDemoModeChanged
  {
    if ( Dashboard::Device.DemoMode )
      signal startNavigationCycle;
    else
      signal moveEffect.StopEffect;
  }
}

$rect <9,188,209,228>
$output false
class Gauge : Core::Group
{
  $rect <490,0,690,40>
  inherited property Bounds = <0,0,470,470>;

  $rect <690,50,890,90>
  onset Outlet
  {
    // Check if the new outlet differs from the currently used outlet
    if ( pure Outlet == value )
      return;

    // Store the new outlet ...
    pure Outlet = value;

    // Set the outlet at the gauge indicator and label
    GaugeLabels.Outlet = value;
    GaugeIndicator.Outlet = value;
  }

  // The property 'Outlet' can refer to any other 'int32' property the widget should \
  // remain synchronized with. When the referred property is modified, the widget \
  // is automatically notified to remain in sync with the property.
  // This approach follows the Controller-View programming paradigm. Here the widget \
  // represents the 'View' and the property referred via 'Outlet' can be seen as \
  // a part of the 'Controller'.
  $rect <490,50,690,90>
  property ^int32 Outlet = null;

  $rect <490,90,690,130>
  property bool Clockwise = true;

  $rect <690,90,890,130>
  onset Clockwise
  {
    // The value doesn't change - nothing to do.
    if ( pure Clockwise == value )
      return;

    // Remember the property's new value.
    pure Clockwise = value;

    // Set the rotation direction at the gauge indicator and label
    GaugeLabels.Clockwise = Clockwise;

    if ( Clockwise )
    {
      GaugeIndicator.StartAngle = 180.0;
      GaugeIndicator.EndAngle = 405.0;
    }
    else
    {
      GaugeIndicator.StartAngle = 540.0;
      GaugeIndicator.EndAngle = 315.0;
    }
  }

  $rect <500,180,700,220>
  property uint8 OpacityLabels;

  $rect <700,180,900,220>
  onset OpacityLabels
  {
    // Remember the property's new value.
    pure OpacityLabels = value;

    // Set the opacity of the gauge labels
    GaugeLabels.Opacity = value;
  }

  $rect <500,220,700,260>
  property uint8 OpacityGauge;

  $rect <700,220,900,260>
  onset OpacityGauge
  {
    // Remember the property's new value.
    pure OpacityGauge = value;

    // Set the opacity of all elements despite the gauge labels
    GaugeIndicator.Opacity = value;
    Circle0.Opacity = value;
    Circle1.Opacity = value;
    Circle2.Opacity = value;
    Circle3.Opacity = value;
    Circle4.Opacity = value;
    Circle5.Opacity = value;
    Bg.Color = color( Dashboard::Colors.Background.red, Dashboard::Colors.Background.green, Dashboard::Colors.Background.blue, value);
  }

  // Opacity
  note group Note
  {
    attr Bounds = <490,140,910,280>;
  }

  $rect <690,0,890,40>
  object Graphics::ArcPath background
  {
    preset Radius = 235.0;
    preset Style = Graphics::ArcStyle.Arc;
  }

  $rect <20,20,160,60>
  object Views::FillPath Bg
  {
    preset Bounds = Bounds;
    preset Color = Dashboard::Colors.Background;
    preset Offset = <235,235>;
    preset Path = background;
  }

  $rect <20,20,160,60>
  object Views::Image Circle5
  {
    preset Bounds = <89,136,381,380>;
    preset Color = Dashboard::Colors.GaugeCircle5;
    preset Bitmap = Dashboard::Circle5;
  }

  $rect <20,20,160,60>
  object Views::Image Circle4
  {
    preset Bounds = <128,129,342,340>;
    preset Color = Dashboard::Colors.GaugeCircle4;
    preset Bitmap = Dashboard::Circle4;
  }

  $rect <20,20,160,60>
  object Views::Image Circle3
  {
    preset Bounds = <82,82,387,387>;
    preset Color = Dashboard::Colors.GaugeCircle3;
    preset Bitmap = Dashboard::Circle3;
  }

  $rect <20,20,160,60>
  object Views::Image Circle2
  {
    preset Bounds = <56,56,413,413>;
    preset Color = Dashboard::Colors.GaugeCircle2;
    preset Bitmap = Dashboard::Circle2;
  }

  $rect <20,20,160,60>
  object Views::Image Circle1
  {
    preset Bounds = <0,0,470,420>;
    preset Color = Dashboard::Colors.GaugeCircle1;
    preset Bitmap = Dashboard::Circle1;
  }

  $rect <20,20,160,60>
  object Views::Image Circle0
  {
    preset Bounds = <86,86,384,384>;
    preset Color = Dashboard::Colors.GaugeCircle0;
    preset Bitmap = Dashboard::Circle0;
  }

  $rect <20,20,160,60>
  object Dashboard::GaugeLabels GaugeLabels
  {
    preset Bounds = <0,0,470,470>;
  }

  $rect <20,20,160,60>
  object Dashboard::GaugeIndicator GaugeIndicator
  {
    preset Bounds = <90,90,380,380>;
  }

  // This is the gauge used at the first variant.
  //
  // It consists of a black background, six alpha8 circle bitmaps, the gauge labels \
  // and the gauge indicator.
  note legend Note1
  {
    attr Bounds = <490,290,910,430>;
  }

  $reorder OnGetEmbedded 1
  $reorder OnSetEmbedded 1
  $reorder OnGetAlphaBlended 1
  $reorder OnSetAlphaBlended 1
  $reorder OnGetVisible 1
  $reorder OnSetVisible 1
  $reorder FindActiveDialogByClass 1
  $reorder FindDialogByClass 1
  $reorder FindCurrentDialog 1
  $reorder IsCurrentDialog 1
  $reorder IsActiveDialog 1
  $reorder IsDialog 1
  $reorder GetIndexOfDialog 1
  $reorder GetDialogAtIndex 1
  $reorder CountDialogs 1
  $reorder SwitchToDialog 1
  $reorder DismissDialog 1
  $reorder PresentDialog 1
  $reorder ObtainFocus 1
  $reorder HasViewState 1
  $reorder LocalPosition 1
  $reorder GlobalPosition 1
  $reorder DispatchEvent 1
  $reorder BroadcastEventAtPosition 1
  $reorder BroadcastEvent 1
  $reorder UpdateLayout 1
  $reorder UpdateViewState 1
  $reorder InvalidateViewState 1
  $reorder InvalidateArea 1
  $reorder Init 1
  $reorder GetIndexOfView 1
  $reorder GetViewAtIndex 1
  $reorder CountViews 1
  $reorder FindViewInDirection 1
  $reorder FindViewWithinArea 1
  $reorder FindViewAtPosition 1
  $reorder FindPrevView 1
  $reorder FindNextView 1
  $reorder FindSiblingView 1
  $reorder GetContentArea 1
  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Embedded 3
  $reorder AlphaBlended 3
  $reorder Visible 3
  $reorder OnSetOutlet 3
  $reorder Outlet 3
  $reorder Clockwise 3
  $reorder OnSetClockwise 3
  $reorder Enabled 1
  $reorder Opacity 1
}

$rect <1070,50,1270,90>
$output false
resource Resources::Bitmap Circle0
{
  attr bitmapfile FileName = .\Res\Gauge\Circle0.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <1070,90,1270,130>
$output false
resource Resources::Bitmap Circle1
{
  attr bitmapfile FileName = .\Res\Gauge\Circle1.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <1070,130,1270,170>
$output false
resource Resources::Bitmap Circle2
{
  attr bitmapfile FileName = .\Res\Gauge\Circle2.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <1070,170,1270,210>
$output false
resource Resources::Bitmap Circle3
{
  attr bitmapfile FileName = .\Res\Gauge\Circle3.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <1070,210,1270,250>
$output false
resource Resources::Bitmap Circle4
{
  attr bitmapfile FileName = .\Res\Gauge\Circle4.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <1070,250,1270,290>
$output false
resource Resources::Bitmap Circle5
{
  attr bitmapfile FileName = .\Res\Gauge\Circle5.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <10,90,210,130>
$output false
class Dashboard : Core::Group
{
  $rect <-9,780,191,820>
  inherited method Init()
  {
    attachobserver onAutoDemoModeChanged, ^Dashboard::Device.AutoDemoMode;
    postsignal onAutoDemoModeChanged;

    // Show the second variant only after the user has started
    // a transition
    DashboardV1.Visible = true;
    DashboardV2.Visible = false;

    $if !$composer
      // Disable the touchhandlers while the startup sequence
      TransitionButton.Enabled = false;
      ShutdownButton.Enabled = false;
      shutdown = false;

      TransitionButton.Visible = false;
      ShutdownButton.Visible = false;

      EnergyDisplay.Opacity = 0;
      SpeedDisplay.Opacity = 0;

      SpeedWarpGroup.Opacity = 0;
      EnergyWarpGroup.Opacity = 0;

      Clock.Opacity = 0;
      Munich.Opacity = 0;

      Battery.Opacity = 0;
      Battery.Visible = false;

      RangeDisplay.Opacity = 0;
      RangeDisplay.Visible = false;

      Reach.Opacity = 0;
      Reach.Visible = false;

      LedButton.Opacity = 0;
      LedButton1.Opacity = 0;
      LedButton2.Opacity = 0;
      LedButton3.Opacity = 0;
      LedButton4.Opacity = 0;
      LedButton5.Opacity = 0;
    $endif

    // Set the gauge display to buffered before scaling
    SpeedDisplay.Buffered = true;
    EnergyDisplay.Buffered = true;

    // Delay the effects starts till the dashboard was initial drawn
    idlesignal gaugeDisplayEffect.StartEffect;
    idlesignal v1Effect.StartEffect;
  }

  $rect <-10,740,190,780>
  inherited property Bounds = <0,0,1280,720>;

  $rect <409,1149,609,1189>
  inherited method UpdateViewState()
  {
    super( aState );

    // Do not move the leds at the shutdown sequence but instead fade them out.
    if ( shutdown )
    {
      // Ensure that the leds are faded out at V1 and V2
      var float offset = (1.0 - progress);
      if ( DashboardV1.Visible )
        offset = progress;

      // Reduce opacity of left leds
      LedButton2.Opacity = Dashboard::Animation.linearValueProgress( 0, 255, 0.7, 1.0, offset );
      LedButton1.Opacity = Dashboard::Animation.linearValueProgress( 0, 255, 0.7, 1.0, offset );
      LedButton.Opacity = Dashboard::Animation.linearValueProgress( 0, 255, 0.7, 1.0, offset );

      // Reduce opacity of left leds
      LedButton5.Opacity = Dashboard::Animation.linearValueProgress( 0, 255, 0.7, 1.0, offset );
      LedButton4.Opacity = Dashboard::Animation.linearValueProgress( 0, 255, 0.7, 1.0, offset );
      LedButton3.Opacity = Dashboard::Animation.linearValueProgress( 0, 255, 0.7, 1.0, offset );
    }
    else
    {
      // Move left leds
      LedButton2.Bounds.origin = Dashboard::Animation.linearPointProgess( <94,585>, <73,657>, 0.8, 1.0, progress );
      LedButton1.Bounds.origin = Dashboard::Animation.linearPointProgess( <65,520>, <102,592>, 0.8, 1.0, progress );
      LedButton.Bounds.origin = Dashboard::Animation.linearPointProgess( <44,460>, <130,532>, 0.8, 1.0, progress );

      // Move right leds
      LedButton5.Bounds.origin = Dashboard::Animation.linearPointProgess( <1158,584>, <1171,655>, 0.8, 1.0, progress );
      LedButton4.Bounds.origin = Dashboard::Animation.linearPointProgess( <1179,518>, <1136,592>, 0.8, 1.0, progress );
      LedButton3.Bounds.origin = Dashboard::Animation.linearPointProgess( <1198,454>, <1105,530>, 0.8, 1.0, progress );

      // Animate colors of eco, battery and navigation position between the variants
      Navigation.PositionColor = Dashboard::Animation.linearColorProgess( Dashboard::Colors.BatteryGaugeSelectionV2, Dashboard::Colors.BatteryGaugeSelectionV1, 0.8, 1.0, progress );

      // Do not show battery and range text on startup of V1
      if ( DashboardV2.Visible )
      {
        if ( ! Battery.Visible ) Battery.Visible = true;
        Battery.Opacity = Dashboard::Animation.linearValueProgress( 255, 0, 0.2, 0.5, progress );

        if ( ! RangeDisplay.Visible ) RangeDisplay.Visible = true;
        RangeDisplay.Opacity = Dashboard::Animation.linearValueProgress( 255, 0, 0.2, 0.5, progress );

        if ( ! Reach.Visible ) Reach.Visible = true;
        Reach.Opacity = Dashboard::Animation.linearValueProgress( 255, 0, 0.2, 0.5, progress );
      }
      else
      {
        Battery.Visible      = false;
        RangeDisplay.Visible = false;
        Reach.Visible        = false;
      }
    }
  }

  // Navigation
  note group Note1
  {
    attr Bounds = <1149,829,1369,1020>;
  }

  $rect <240,890,440,930>
  object Effects::FloatEffect v1Effect
  {
    preset OnFinished = onV1Effect;
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 3000;
    preset Outlet = ^progress;
  }

  $rect <240,930,440,970>
  slot onV1Effect
  {
    // Show second variant
    DashboardV2.Visible = true;

    // Show all icons and indicators despite the map and navigation hint
    TransitionButton.Visible = true;
    ShutdownButton.Visible = true;

    Clock.Opacity = 255;
    Munich.Opacity = 255;

    LedButton.Opacity = 255;
    LedButton1.Opacity = 255;
    LedButton2.Opacity = 255;
    LedButton3.Opacity = 255;
    LedButton4.Opacity = 255;
    LedButton5.Opacity = 255;

    signal ledOnEffect.StartEffect;
  }

  $rect <9,930,209,970>
  slot onGaugeDisplayEffect
  {
    // Increase opacity of gauge displays
    SpeedWarpGroup.Opacity = (uint8)gaugeDisplayEffect.Value;
    EnergyWarpGroup.Opacity = (uint8)gaugeDisplayEffect.Value;

    // Start scaling of the gauges once the opacity is >= 150.0
    var float startOpacity = 5.0;
    var float scale = (startOpacity / 255.0);
    if ( gaugeDisplayEffect.Value >= startOpacity )
      scale = (float)gaugeDisplayEffect.Value / 255.0;

    // Scale gauge displays
    SpeedWarpGroup.RotateAndScale( SpeedDisplay.Bounds.center, 0.0, scale, scale );
    EnergyWarpGroup.RotateAndScale( EnergyDisplay.Bounds.center, 0.0, scale, scale );
  }

  // Gauge display
  note group Note2
  {
    attr Bounds = <0,830,220,1020>;
  }

  $rect <11,970,211,1010>
  slot onGaugeDisplayFinished
  {
    // Show the gauge displays
    EnergyDisplay.Opacity = 255;
    SpeedDisplay.Opacity = 255;

    // because on buffered == false they are not displayed at the warp groups anymore
    SpeedDisplay.Buffered = false;
    EnergyDisplay.Buffered = false;

  }

  $rect <469,889,669,929>
  object Effects::Int32Effect ledOnEffect
  {
    preset OnFinished = onLedOnEffectFinished;
    preset OnAnimate = onLedOnEffect;
    preset Timing = Effects::Timing.Linear;
    preset NoOfCycles = 1;
    preset CycleDuration = 1500;
    preset Value2 = 3;
  }

  $rect <469,929,669,969>
  slot onLedOnEffect
  {
    // Enable the leds from bottom to top
    Dashboard::Device.Led2 = (ledOnEffect.Value > 0);
    Dashboard::Device.Led5 = (ledOnEffect.Value > 0);

    Dashboard::Device.Led1 = (ledOnEffect.Value > 1);
    Dashboard::Device.Led4 = (ledOnEffect.Value > 1);

    Dashboard::Device.Led0 = (ledOnEffect.Value > 2);
    Dashboard::Device.Led3 = (ledOnEffect.Value > 2);
  }

  // Functional safety led on check
  note group Note3
  {
    attr Bounds = <460,830,680,1020>;
  }

  $rect <471,969,671,1009>
  slot onLedOnEffectFinished
  {
    signal gaugeCheckEffect.StartEffect;
  }

  // V1 blending
  note group Note4
  {
    attr Bounds = <231,830,449,1020>;
  }

  $rect <9,1058,209,1098>
  slot onStartTransition
  {
    // Swap effect direction
    transitionEffect.Value1 = progress;
    transitionEffect.Value2 = 1.0 - transitionEffect.Value2;

    // Start the variant transition
    signal transitionEffect.StartEffect;
  }

  $rect <9,1098,209,1138>
  object Effects::FloatEffect transitionEffect
  {
    preset Timing = Effects::Timing.EaseIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 3000;
    preset Outlet = ^progress;
  }

  // Variant transition
  note group Note5
  {
    attr Bounds = <0,1029,629,1238>;
  }

  $rect <1160,969,1360,1009>
  slot onNavigationFinished
  {
    // Let the user do variant transitions
    TransitionButton.Enabled = true;
    ShutdownButton.Enabled = true;

    // Let the user toggle the leds
    LedButton.Enabled = true;
    LedButton1.Enabled = true;
    LedButton2.Enabled = true;
    LedButton3.Enabled = true;
    LedButton4.Enabled = true;
    LedButton5.Enabled = true;

    // Start demo mode
    Dashboard::Device.DemoMode = true;
  }

  $rect <11,1150,211,1190>
  property float progress = 0.0;

  $rect <211,1149,411,1189>
  onset progress
  {
    // The value doesn't change - nothing to do.
    if ( pure progress == value )
      return;

    // Remember the property's new value.
    pure progress = value;

    progressReverse = (1.0 - value);

    InvalidateViewState();

    notifyobservers ^progress;
  }

  $rect <11,1189,211,1229>
  property float progressReverse = 100.0;

  $rect <209,1189,409,1229>
  onset progressReverse
  {
    // The value doesn't change - nothing to do.
    if ( pure progressReverse == value )
      return;

    // Remember the property's new value.
    pure progressReverse = value;

    notifyobservers ^progressReverse;
  }

  $rect <1160,889,1360,929>
  object Effects::Int32Effect navigationEffect
  {
    preset OnFinished = onNavigationFinished;
    preset OnAnimate = onNavigationEffect;
    preset Timing = Effects::Timing.Exp_In;
    preset NoOfCycles = 1;
    preset CycleDuration = 2000;
  }

  $rect <1160,929,1360,969>
  slot onNavigationEffect
  {
    // Show map and navigation hint by increasing its opacity
    Navigation.Opacity = navigationEffect.Value;
    NavigationHints.Opacity = navigationEffect.Value;
  }

  $rect <9,1287,209,1327>
  slot onShutdown
  {
    // Disable transition touchhandler
    TransitionButton.Enabled = false;

    // Store that shutdown was initiated
    shutdown = true;

    // Stop the demo mode
    Dashboard::Device.DemoMode = false;

    // Fade out the navigation components
    signal shutdownNavigationEffect.StartEffect;
  }

  $rect <409,1287,609,1327>
  object Effects::FloatEffect shutdownVariantEffect
  {
    preset Timing = Effects::Timing.EaseIn_FastOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 3000;
    preset Outlet = ^progress;
  }

  $rect <9,1327,209,1367>
  var bool shutdown = false;

  $rect <209,1367,409,1407>
  slot onShutdownNavigationFinished
  {
    // Swap shutdown effect direction
    shutdownVariantEffect.Value1 = progress;
    shutdownVariantEffect.Value2 = 1.0 - transitionEffect.Value2;

    // Hide the current not visible variant
    DashboardV1.Visible = ( progress == 1.0 );
    DashboardV2.Visible = !DashboardV1.Visible;

    // Hide all icons and indicators despite the map and navigation hint
    TransitionButton.Visible = false;
    ShutdownButton.Visible = false;

    Clock.Opacity = 0;
    Munich.Opacity = 0;

    Battery.Opacity = 0;
    Battery.Visible = false;

    RangeDisplay.Opacity = 0;
    RangeDisplay.Visible = false;

    Reach.Opacity = 0;
    Reach.Visible = false;

    // Set the gauge displayes to buffered before scaling
    SpeedDisplay.Buffered = true;
    EnergyDisplay.Buffered = true;

    // Hide the gauge displayes
    EnergyDisplay.Opacity = 0;
    SpeedDisplay.Opacity = 0;

    // Start the shutdown variant transition
    signal shutdownVariantEffect.StartEffect;
    signal shutdownGaugeDisplayEffect.StartEffect;
  }

  $rect <209,1287,409,1327>
  object Effects::Int32Effect shutdownNavigationEffect
  {
    preset OnFinished = onShutdownNavigationFinished;
    preset OnAnimate = onShutdownNavigationEffect;
    preset Timing = Effects::Timing.Exp_In;
    preset NoOfCycles = 1;
    preset CycleDuration = 1500;
    preset Value2 = 0;
    preset Value1 = 255;
  }

  $rect <209,1327,409,1367>
  slot onShutdownNavigationEffect
  {
    // Hide map and navigation hint by decreasing its opacity
    Navigation.Opacity = shutdownNavigationEffect.Value;
    NavigationHints.Opacity = shutdownNavigationEffect.Value;
  }

  // Shutdown transition
  note group Note7
  {
    attr Bounds = <0,1249,820,1420>;
  }

  $rect <9,889,209,929>
  object Effects::FloatEffect gaugeDisplayEffect
  {
    preset OnFinished = onGaugeDisplayFinished;
    preset OnAnimate = onGaugeDisplayEffect;
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 750;
    preset Value2 = 255.0;
    preset Value1 = 0.0;
  }

  $rect <609,1328,809,1368>
  slot onShutdownGaugeDisplayEffect
  {
    // Decrease opacity of gauge displays
    SpeedWarpGroup.Opacity = (uint8)shutdownGaugeDisplayEffect.Value;
    EnergyWarpGroup.Opacity = (uint8)shutdownGaugeDisplayEffect.Value;

    // Start shrinking of the gauges and end when opacity is < 150.0
    var float endOpacity = 5.0;
    var float scale = (endOpacity / 255.0);
    if ( shutdownGaugeDisplayEffect.Value >= endOpacity )
      scale = (float)shutdownGaugeDisplayEffect.Value / 255.0;

    // Shrink gauge displays
    SpeedWarpGroup.RotateAndScale( SpeedDisplay.Bounds.center, 0.0, scale, scale );
    EnergyWarpGroup.RotateAndScale( EnergyDisplay.Bounds.center, 0.0, scale, scale );
  }

  $rect <611,1368,811,1408>
  slot onShutdownGaugeDisplayFinished
  {
    // Leave this dialog and show another one
    if ( IsDialog( false ))
      Owner.SwitchToDialog( new Dashboard::StartScreen, Dashboard::FadeInOutCentered, Effects::FadeInOutCentered, null, null, Effects::FadeInOutCentered, null, null, null, null, false );
  }

  $rect <609,1287,809,1327>
  object Effects::FloatEffect shutdownGaugeDisplayEffect
  {
    preset OnFinished = onShutdownGaugeDisplayFinished;
    preset OnAnimate = onShutdownGaugeDisplayEffect;
    preset Timing = Effects::Timing.EaseIn_FastOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 750;
    preset InitialDelay = 2250;
    preset Value2 = 0.0;
    preset Value1 = 255.0;
  }

  $rect <700,889,900,929>
  object Effects::Int32Effect gaugeCheckEffect
  {
    preset OnFinished = onGaugeCheckEffectFinished;
    preset OnAnimate = onGaugeCheckEffect;
    preset Symmetric = true;
    preset Timing = Effects::Timing.EaseIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 1500;
    preset Value2 = 100;
  }

  $rect <700,929,900,969>
  slot onGaugeCheckEffect
  {
    // Drive speed and energy value from zero to 100
    Dashboard::Device.Speed = gaugeCheckEffect.Value;
    Dashboard::Device.Energy = gaugeCheckEffect.Value;
  }

  // Functional safety gauge check
  note group Note6
  {
    attr Bounds = <689,829,909,1020>;
  }

  $rect <702,969,902,1009>
  slot onGaugeCheckEffectFinished
  {
    // Show navigation components
    signal navigationEffect.StartEffect;
    signal ledOffEffect.StartEffect;
  }

  $rect <929,888,1129,928>
  object Effects::Int32Effect ledOffEffect
  {
    preset OnAnimate = onLedOffEffect;
    preset Timing = Effects::Timing.Linear;
    preset NoOfCycles = 1;
    preset CycleDuration = 1500;
    preset Value2 = 0;
    preset Value1 = 3;
  }

  $rect <929,928,1129,968>
  slot onLedOffEffect
  {
    // Disable the leds from top to bottom
    Dashboard::Device.Led2 = (ledOffEffect.Value > 0);
    Dashboard::Device.Led5 = (ledOffEffect.Value > 0);

    Dashboard::Device.Led1 = (ledOffEffect.Value > 1);
    Dashboard::Device.Led4 = (ledOffEffect.Value > 1);

    Dashboard::Device.Led0 = (ledOffEffect.Value > 2);
    Dashboard::Device.Led3 = (ledOffEffect.Value > 2);
  }

  // Functional safety led off check
  note group Note8
  {
    attr Bounds = <920,829,1140,1019>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,1280,720>;
    preset Color = Dashboard::Colors.Background;
  }

  $rect <20,20,160,60>
  object Dashboard::Navigation Navigation
  {
    preset Bounds = <226,269,1054,720>;
    preset Opacity = 0;
    preset Hints = NavigationHints;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ShutdownButton
  {
    preset Bounds = <1168,2,1278,83>;
    preset OnActivate = onShutdown;
    preset Icon = Dashboard::OffIcon;
    preset Label = "";
    preset Appearance = Dashboard::DashboardButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton TransitionButton
  {
    preset Bounds = <17,1,127,82>;
    preset OnActivate = onStartTransition;
    preset Icon = Dashboard::SwitchIcon;
    preset Label = "";
    preset Appearance = Dashboard::DashboardButtonConfig;
  }

  $rect <20,20,160,60>
  object Dashboard::DashboardV2 DashboardV2
  {
    preset Bounds = <0,0,1280,720>;
    preset Outlet = ^progressReverse;
  }

  $rect <20,20,160,60>
  object Dashboard::DashboardV1 DashboardV1
  {
    preset Bounds = <0,0,1280,720>;
    preset Outlet = ^progress;
  }

  $rect <20,20,160,60>
  object Dashboard::NavigationHints NavigationHints
  {
    preset Bounds = <559,107,724,267>;
    preset Opacity = 0;
  }

  $rect <20,20,160,60>
  object Dashboard::Clock Clock
  {
    preset Bounds = <596,59,686,99>;
  }

  $rect <20,20,160,60>
  object Views::Text Munich
  {
    preset Bounds = <537,19,747,64>;
    preset String = "Munich 22°C";
    preset Font = Dashboard::FontLightXL;
    preset Color = Dashboard::Colors.Text;
  }

  $rect <20,20,160,60>
  object Views::Text Reach
  {
    preset Bounds = <558,603,723,631>;
    preset String = "Reach";
    preset Font = Dashboard::FontLightM;
    preset Color = Dashboard::Colors.Text;
  }

  $rect <20,20,160,60>
  object Dashboard::Battery Battery
  {
    preset Bounds = <590,636,689,671>;
    preset Outlet = ^Dashboard::Device.Battery;
    preset TrackColor = Dashboard::Colors.BatteryGaugeSelectionV2;
  }

  $rect <20,20,160,60>
  object Dashboard::GaugeDisplay EnergyDisplay
  {
    preset Bounds = <909,218,1059,368>;
    preset Outlet = ^Dashboard::Device.Energy;
    preset Unit = "kW";
    preset Desc = "BATT  ";
    preset OutletDesc = ^Dashboard::Device.Battery;
    preset DescUnit = "%%";
  }

  $rect <20,20,160,60>
  object Views::WarpGroup EnergyWarpGroup
  {
    preset Point4 = <909,368>;
    preset Point3 = <1059,368>;
    preset Point2 = <1059,218>;
    preset Point1 = <909,218>;
    preset SourceAnchor = EnergyDisplay.Bounds.orect.center;
    preset Group = EnergyDisplay;
  }

  $rect <20,20,160,60>
  object Dashboard::GaugeDisplay SpeedDisplay
  {
    preset Bounds = <227,218,377,368>;
    preset Outlet = ^Dashboard::Device.Speed;
    preset Unit = "mph";
    preset Desc = "ODO  ";
    preset OutletDesc = ^Dashboard::Device.ODO;
    preset DescUnit = "km";
  }

  $rect <20,20,160,60>
  object Views::WarpGroup SpeedWarpGroup
  {
    preset Point4 = <227,368>;
    preset Point3 = <377,368>;
    preset Point2 = <377,218>;
    preset Point1 = <227,218>;
    preset SourceAnchor = SpeedDisplay.Bounds.orect.center;
    preset Group = SpeedDisplay;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton LedButton
  {
    preset Bounds = <60,400,102,442>;
    preset Enabled = false;
    preset Outlet = ^Dashboard::Device.Led0;
    preset IconOffFrame = 3;
    preset IconFrame = 3;
    preset Icon = Dashboard::Icons;
    preset Label = "";
    preset Appearance = Dashboard::LedButtonGreenConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton LedButton1
  {
    preset Bounds = <130,490,172,532>;
    preset Enabled = false;
    preset Outlet = ^Dashboard::Device.Led1;
    preset IconOffFrame = 4;
    preset IconFrame = 4;
    preset Icon = Dashboard::Icons;
    preset Label = "";
    preset Appearance = Dashboard::LedButtonGreenConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton LedButton2
  {
    preset Bounds = <170,560,212,602>;
    preset Enabled = false;
    preset Outlet = ^Dashboard::Device.Led2;
    preset IconOffFrame = 5;
    preset IconFrame = 5;
    preset Icon = Dashboard::Icons;
    preset Label = "";
    preset Appearance = Dashboard::LedButtonGreenConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton LedButton3
  {
    preset Bounds = <1090,450,1132,492>;
    preset Enabled = false;
    preset Outlet = ^Dashboard::Device.Led3;
    preset IconOffFrame = 0;
    preset IconFrame = 0;
    preset Icon = Dashboard::Icons;
    preset Label = "";
    preset Appearance = Dashboard::LedButtonOrangeConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton LedButton4
  {
    preset Bounds = <1010,520,1052,562>;
    preset Enabled = false;
    preset Outlet = ^Dashboard::Device.Led4;
    preset IconOffFrame = 1;
    preset IconFrame = 1;
    preset Icon = Dashboard::Icons;
    preset Label = "";
    preset Appearance = Dashboard::LedButtonOrangeConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton LedButton5
  {
    preset Bounds = <1050,590,1092,632>;
    preset Enabled = false;
    preset Outlet = ^Dashboard::Device.Led5;
    preset IconOffFrame = 2;
    preset IconFrame = 2;
    preset Icon = Dashboard::Icons;
    preset Label = "";
    preset Appearance = Dashboard::LedButtonOrangeConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay RangeDisplay
  {
    preset Bounds = <499,677,819,707>;
    preset Outlet = ^Dashboard::Device.Battery;
    preset Unit = "km on current setting";
    preset NoOfDigits = 1;
    preset CurrentFactor = 4.0;
    preset Appearance = Dashboard::RangeConfig;
  }

  // This is the dashboard screen.
  //
  // Once the user has switch to this screen multiple effects come into play to do \
  // the following actions:
  // 1. Show and zoom the speed and energy gauge displays
  // 2. Show the leds and the outer texts while the first dashboard variant is animated \
  // displayed
  // 3. Functional safety check of leds and gauges
  // 4. Show the navigation ui components
  //
  // You can start a variant transition by touching the left upper corner.
  // By touching the right upper corner the current visible variant disappears and \
  // it is returned to the start screen.
  note legend Note9
  {
    attr Bounds = <828,1028,1360,1348>;
  }

  $rect <1390,930,1590,970>
  object Core::Timer autoDemoModeTimer
  {
    preset OnTrigger = onStartTransition;
    preset Period = 20000;
  }

  $rect <1390,890,1590,930>
  slot onAutoDemoModeChanged
  {
    // Start the auto demo mode timer on enabled auto demo mode
    if ( Dashboard::Device.AutoDemoMode )
      signal autoDemoModeTimer.StartTimer;
    else
      signal autoDemoModeTimer.StopTimer;
  }

  // Auto demo mode
  note group Note
  {
    attr Bounds = <1380,830,1600,1020>;
  }
}

$rect <669,180,869,220>
$output false
resource Resources::Bitmap Map
{
  attr bitmapfile FileName = .\Res\Map.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <669,220,869,260>
$output false
resource Resources::Bitmap MapFading
{
  attr bitmapfile FileName = .\Res\MapFading.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <669,260,869,300>
$output false
resource Resources::Bitmap Position
{
  attr bitmapfile FileName = .\Res\Position.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <241,309,441,349>
$output false
class NavigationHints : Core::Group
{
  $rect <0,170,200,210>
  inherited property Bounds = <0,0,165,160>;

  $rect <0,210,200,250>
  property int32 Distance;

  $rect <200,210,400,250>
  onset Distance
  {
    // The value doesn't change - nothing to do.
    if ( pure Distance == value )
      return;

    // Remember the property's new value.
    pure Distance = value;

    DistanceDisplay.CurrentValue = value;
  }

  $rect <0,250,200,290>
  property int32 Direction;

  $rect <200,250,400,290>
  onset Direction
  {
    // The value doesn't change - nothing to do.
    if ( pure Direction == value )
      return;

    // Remember the property's new value.
    pure Direction = value;

    if ( Direction < 0 )
    {
     DirectionImage.FrameNumber = 0;
     DescText.String = "left turn";
    }
    else if ( Direction == 0 )
    {
     DirectionImage.FrameNumber = 1;
     DescText.String = "forward";
    }
    else
    {
     DirectionImage.FrameNumber = 2;
     DescText.String = "right turn";
    }
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay DistanceDisplay
  {
    preset Bounds = <19,96,184,132>;
    preset Unit = "m";
    preset NoOfDigits = 1;
    preset Appearance = Dashboard::NavigationHintConfig;
  }

  $rect <20,20,160,60>
  object Views::Text DescText
  {
    preset Bounds = <0,124,165,157>;
    preset String = "right turn";
    preset Font = Dashboard::FontLightM;
    preset Color = Dashboard::Colors.Text;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Image DirectionImage
  {
    preset Bounds = <0,0,165,80>;
    preset Color = Dashboard::Colors.Text;
    preset Bitmap = Dashboard::Arrows;
  }
}

$rect <220,448,420,488>
$output false
autoobject WidgetSet::ValueDisplayConfig NavigationHintConfig
{
  preset ValueMarginRight = 3;
  preset ValueColorNegative = Dashboard::Colors.Text;
  preset ValueColorPositive = Dashboard::Colors.Text;
  preset ValueAlignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
  preset ValueFont = Dashboard::FontLightL;
  preset UnitColorNegative = Dashboard::Colors.Text;
  preset UnitColorPositive = Dashboard::Colors.Text;
  preset UnitFont = Dashboard::FontLightL;
  preset FormatDecimalSign = "";
  preset Layout = WidgetSet::ValueDisplayLayout.AlignValueLeftToUnit;
}

$rect <669,300,869,340>
$output false
resource Resources::Bitmap Arrows
{
  attr bitmapfile FileName = .\Res\Arrows.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize = <62,58>;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

// Helper class which provides functions to simplifies time independent animations.
$rect <10,670,210,710>
$output false
class AnimationClass
{
  $rect <0,0,200,40>
  method int32 linearValueProgress( arg int32 aValue1, arg int32 aValue2, arg float aStart, arg float aEnd, arg float aProgress )
  {
    var int32 opacity;

    if ( (aProgress >= aStart) && (aProgress <= aEnd) )
    {
      opacity = (int32)(aValue1 + (int32)(((aProgress - aStart) * (float)(aValue2 - aValue1)) * (1.0 / (aEnd - aStart))));
    }
    else if ( aProgress < aStart )
    {
      opacity = aValue1;
    }
    else // aProgress > aEnd
    {
      opacity = aValue2;
    }

    return opacity;
  }

  $rect <0,40,200,80>
  method point linearPointProgess( arg point aValue1, arg point aValue2, arg float aStart, arg float aEnd, arg float aProgress )
  {
    var int32 x = linearValueProgress( aValue1.x, aValue2.x, aStart, aEnd, aProgress );
    var int32 y = linearValueProgress( aValue1.y, aValue2.y, aStart, aEnd, aProgress );

    return point( x, y );
  }

  $rect <0,80,200,120>
  method color linearColorProgess( arg color aValue1, arg color aValue2, arg float aStart, arg float aEnd, arg float aProgress )
  {
    var uint8 r = (uint8)linearValueProgress( aValue1.red, aValue2.red, aStart, aEnd, aProgress );
    var uint8 g = (uint8)linearValueProgress( aValue1.green, aValue2.green, aStart, aEnd, aProgress );
    var uint8 b = (uint8)linearValueProgress( aValue1.blue, aValue2.blue, aStart, aEnd, aProgress );

    // Set alpha channel to full opacity
    return color( r, g, b, 0xFF );
  }
}

$rect <210,670,410,710>
$output false
autoobject Dashboard::AnimationClass Animation;

$rect <10,448,210,488>
$output false
autoobject WidgetSet::ToggleButtonConfig LedButtonOrangeConfig
{
  preset IconOnTintActive = Dashboard::Colors.LedsOnOrange;
  preset IconOnTintFocused = Dashboard::Colors.LedsOnOrange;
  preset IconOnTintDisabled = Dashboard::Colors.LedsOnOrange;
  preset IconOnTintDefault = Dashboard::Colors.LedsOnOrange;
  preset IconOffTintActive = Dashboard::Colors.TextLedsOff;
  preset IconOffTintFocused = Dashboard::Colors.TextLedsOff;
  preset IconOffTintDisabled = Dashboard::Colors.TextLedsOff;
  preset IconOffTintDefault = Dashboard::Colors.TextLedsOff;
}

// Config
note group Note6
{
  attr Bounds = <0,408,450,580>;
}

$rect <220,487,420,527>
$output false
autoobject WidgetSet::ValueDisplayConfig RangeConfig
{
  preset ValueMarginRight = 3;
  preset ValueColorNegative = Dashboard::Colors.Text;
  preset ValueColorPositive = Dashboard::Colors.Text;
  preset ValueAlignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
  preset ValueFont = Dashboard::FontLightM;
  preset UnitColorNegative = Dashboard::Colors.Text;
  preset UnitColorPositive = Dashboard::Colors.Text;
  preset UnitFont = Dashboard::FontLightM;
  preset FormatDecimalSign = "";
  preset Layout = WidgetSet::ValueDisplayLayout.AlignValueLeftToUnit;
}

$rect <29,228,229,268>
$output false
class GaugeLabels : Core::Group
{
  $rect <490,40,690,80>
  inherited property Bounds = <0,0,470,470>;

  $rect <490,0,690,40>
  inherited method Init()
  {
    signal setup;
    postsignal refresh;
  }

  $rect <700,340,900,380>
  slot refresh
  {
    // Calculate the angle between each text label
    var float deltaAngle = ( endAngle - startAngle ) / float( labels.size - 1 );

    // Adjust and position each text label
    var int32 i = 0;
    while ( i < labels.size )
    {
      if ( Clockwise )
        adjustLabel( i, startAngle + float(i) * deltaAngle, radius, i * increment );
      else
        adjustLabel( i, startAngle + float(i) * deltaAngle, radius, (labels.size - i - 1) * increment );

      i = i + 1;
    }
  }

  $rect <700,380,900,420>
  method void adjustLabel( arg int32 aIndex, arg float aAngle, arg int32 aDistance, arg int32 aNumber )
  {
    var int32 dist = aDistance;
    var int32 offset = 0;

    // Calculate the label center
    var point labelCenter = point( labels[ aIndex ].Bounds.w / 2, labels[ aIndex ].Bounds.h / 2 );

    // Set the number as label text
    labels[ aIndex ].String = string( aNumber );

    if ( aAngle > 360.0 )
      aAngle = aAngle - 360.0;

    // Draw values which can be divided by 20 with 10px less distance to the center
    if ( aNumber % 20 == 0 )
      aDistance = aDistance - 10;

    // Add more distance for number with three or more digits
    if ( aNumber / 100 >= 1 )
      offset = 5;

    // Calculate the position of the label
    labels[ aIndex ].Bounds.origin = Bounds.orect.center - labelCenter
      + point( int32( float( aDistance + offset ) * math_cos( aAngle - 90.0 ) ), int32( float( aDistance + offset ) * math_sin( aAngle - 90.0 ) ) );

    // Calculate the coordinates of the points of the label line
    var int32 p1Offset = 20;
    var int32 p2Offset = 38;
    var point p1 = Bounds.orect.center + point( int32( float( aDistance - p1Offset ) * math_cos( aAngle - 90.0 ) ), int32( float( aDistance - p1Offset ) * math_sin( aAngle - 90.0 ) ) );
    var point p2 = Bounds.orect.center + point( int32( float( dist - p2Offset ) * math_cos( aAngle - 90.0 ) ), int32( float( dist - p2Offset ) * math_sin( aAngle - 90.0 ) ) );

    // Draw the label line
    linePath.InitSubPath( aIndex, 2 );
    linePath.Begin( aIndex, p1.x, p1.y );
    linePath.AddLine( aIndex, p2.x, p2.y );
  }

  // The difference between the values of consecutive labels.
  $rect <500,380,700,420>
  var int32 increment = 10;

  $rect <500,420,700,460>
  var int32 radius = 217;

  // The array containing the dynamically created text view for the label text elements.
  $rect <500,460,700,500>
  array Views::Text labels[ 11 ];

  $rect <490,120,690,160>
  property int32 CurrentValue = 10;

  $rect <690,120,890,160>
  onset CurrentValue
  {
    // The value doesn't change - nothing to do.
    if ( pure CurrentValue == value )
      return;

    // Remember the property's new value.
    pure CurrentValue = value;

    // Calculate the nearest label to the CurrentValue
    var int32 index = (int32)math_round((float)CurrentValue / (float)increment);

    // Check on valid index and if not already selected
    if ( (index < labels.size) && (index != selected) )
    {
      // Unselect all labels
      var int32 i;
      for ( i = 0; i < labels.size; i = i + 1 )
        labels[i].Color = Dashboard::Colors.Text;

      // Color the selected label dependend of the rotation direction
      if ( index >= 0 )
      {
        if ( Clockwise )
          labels[ index ].Color = Dashboard::Colors.BatteryGaugeSelectionV1;
        else
          labels[ labels.size - index - 1 ].Color = Dashboard::Colors.BatteryGaugeSelectionV1;
      }

      // Store the current selection index
      selected = index;
    }
  }

  $rect <500,250,700,290>
  object Graphics::Path linePath;

  $rect <690,80,890,120>
  onset Outlet
  {
    // Check if the new outlet differs from the currently used outlet
    if ( pure Outlet == value )
      return;

    // Detach from the previous outlet
    if ( pure Outlet != null )
      detachobserver onOutlet, pure Outlet;

    // Store the new outlet ...
    pure Outlet = value;

    // ... and attach to the new one
    if ( value != null )
      attachobserver onOutlet, value;

    // Finally, retrieve the current state of the property associated via 'Outlet'.
    if ( value != null )
      postsignal onOutlet;
  }

  // The property 'Outlet' can refer to any other 'int32' property the widget should \
  // remain synchronized with. When the referred property is modified, the widget \
  // is automatically notified to remain in sync with the property.
  // This approach follows the Controller-View programming paradigm. Here the widget \
  // represents the 'View' and the property referred via 'Outlet' can be seen as \
  // a part of the 'Controller'.
  $rect <490,80,690,120>
  property ^int32 Outlet = null;

  // This slot method will receive a signal, if the value of the property assigned \
  // to @Outlet has been changed by another widget or by the application logic. In \
  // response to this notification, the widget will update itself.
  $rect <890,80,1090,120>
  slot onOutlet
  {
    // Read the current value of the associated property and update accordingly
    // the state of the widget.
    if ( Outlet != null )
      CurrentValue = Outlet^;
  }

  $rect <500,500,700,540>
  var int32 selected;

  $rect <490,161,690,201>
  property bool Clockwise = true;

  $rect <690,161,890,201>
  onset Clockwise
  {
    // The value doesn't change - nothing to do.
    if ( pure Clockwise == value )
      return;

    // Remember the property's new value.
    pure Clockwise = value;

    var int32 i = 0;
    while ( i < labels.size )
    {
      if ( Clockwise )
      {
        if ( i % 2 == 0 )
          labels[i].Font = Dashboard::FontL;
        else
          labels[i].Font = Dashboard::FontLightM;
      }
      else
      {
        if ( i % 2 == 1 )
          labels[i].Font = Dashboard::FontLightM;
        else
           labels[i].Font = Dashboard::FontL;
      }

      i = i + 1;
    }

    if ( Clockwise )
    {
      startAngle = 180.0;
      endAngle = 405.0;
    }
    else
    {
      startAngle = 315.0;
      endAngle = 540.0;
    }

    postsignal refresh;
  }

  $rect <500,300,700,340>
  property float startAngle = 180.0;

  $rect <500,340,700,380>
  property float endAngle = 405.0;

  // Label and line adjustment
  note group Note
  {
    attr Bounds = <490,210,920,550>;
  }

  $rect <700,300,900,340>
  slot setup
  {
    var int32 i = 0;
    while ( i < labels.size )
    {
      var Views::Text txt = new Views::Text;

      // Assign each second label a different font
      if ( i % 2 == 0 )
        txt.Font = Dashboard::FontL;
      else
        txt.Font = Dashboard::FontLightM;

      // Autosize the text view to allow center positioning through the view bounds
      txt.AutoSize = true;
      labels[i] = txt;

      // If the view was not already added add it
      if ( labels[i].Owner == null )
        Add( labels[i], 0 );

      i = i + 1;
    }

    // Setup the path which is used for the indicator lines of each text label
    linePath.SetMaxNoOfSubPaths( labels.size );
  }

  // This is the gauge labels component which is used at Dashboard::Gauge.
  //
  // The text views and the lines are dynamically adjusted.
  note legend Note1
  {
    attr Bounds = <0,480,410,600>;
  }

  $rect <20,20,160,60>
  object Views::StrokePath StrokePath
  {
    preset Bounds = <0,0,469,469>;
    preset Color = Dashboard::Colors.GaugeLabelLinesV1;
    preset Width = 1.0;
    preset Path = linePath;
  }
}

// The class 'PieChart' implements a GUI component for displaying a complete pie \
// chart diagram. The data for the single pie segments is defined within a @RecordList.
$rect <30,309,230,349>
$output false
class GaugeIndicator : Core::Group
{
  $rect <0,400,200,440>
  inherited method Draw()
  {
    var float startAngle;
    var float deltaAngle;

    // Determine starting angle and delta (clockwise)
    if ( StartAngle < EndAngle )
    {
      startAngle = pure StartAngle;
      deltaAngle = newRotationAngle - startAngle;
    }
    // counterclockwise
    else
    {
      startAngle = newRotationAngle;
      deltaAngle = pure StartAngle - newRotationAngle;
    }

    // Determine center coordinates
    var int32 dx = ( pure Bounds.x2 + pure Bounds.x1 ) / 2 + aOffset.x;
    var int32 dy = ( pure Bounds.y2 + pure Bounds.y1 ) / 2 + aOffset.y;

    drawPie( aCanvas, aClip, dx, dy, startAngle, deltaAngle, pure Scaling, pure Displacement, Dashboard::Colors.GaugeGlowV1, aOpacity, aBlend );

    // Draw embedded components, like background rectangle
    super( aCanvas, aClip, aOffset, aOpacity, aBlend );

  }

  $rect <0,310,200,350>
  inherited property Bounds = <0,0,290,290>;

  $rect <0,350,200,390>
  inherited method Init()
  {
    // Update the needle position
    drawNeedle();

    $if $composer
    CurrentValue = 100;
    $endif
  }

  // The property 'StartAngle' contains the starting angle of the gauge indicator.
  $rect <300,0,500,40>
  property float StartAngle = 180.0;

  $rect <500,0,700,40>
  onset StartAngle
  {
    // Check for any changes...
    if ( value == pure StartAngle )
      return;

    // Store the new angle value...
    pure StartAngle = value;

    // ...and force an update of the component
    InvalidateArea( Bounds.orect );

  }

  // The property 'SegmentImage' contains the bitmap resource, that is used to create \
  // the segment. The image has to contain the top left quarter of a circular object.
  $rect <300,180,500,220>
  property Resources::Bitmap SegmentImage = Dashboard::GaugeGlowSegment;

  $rect <500,180,700,220>
  onset SegmentImage
  {
    // Check for any changes...
    if ( value == pure SegmentImage )
      return;

    // Store the image...
    pure SegmentImage = value;

    // ...and force an update of the component
    InvalidateArea( Bounds.orect );

  }

  $rect <500,220,700,260>
  var Graphics::Canvas tempImage = null;

  // The property 'Scaling' contains the scaling factor between 0.01 and 1.1.
  $rect <300,90,500,130>
  property float Scaling = 1.0;

  $rect <500,90,700,130>
  onset Scaling
  {
    // Check limits
    if ( value < 0.01 )
      value = 0.01;
    if ( value > 1.1 )
      value = 1.1;

    // Check for any changes...
    if ( value == pure Scaling )
      return;

    // Store the new value...
    pure Scaling = value;

    // ...and force an update of the component
    InvalidateArea( Bounds.orect );

  }

  $rect <0,440,200,480>
  method void drawPie( arg Graphics::Canvas aCanvas, arg rect aClip, arg int32 aX, arg int32 aY, arg float aStartAngle, arg float aDeltaAngle, arg float aScaling, arg float aDisplacement, arg color aColor, arg int32 aOpacity, arg bool aBlend )
  {
    var float sinA;
    var float cosA;
    var float p1x;
    var float p1y;
    var float p2x;
    var float p2y;
    var float p3x;
    var float p3y;
    var float p4x;
    var float p4y;
    var rect clip;

    var color c = aColor;

    /* calculate resulting opacity value from given opacity and the components opacity value */
    var int32 opacity = ((( aOpacity + 1 ) * pure Opacity ) >> 8 ) + 1;

    /* alpha blending of the chart depends on the blending mode of its owners */
    aBlend = aBlend && viewState.contains( Core::ViewState[ AlphaBlended ]);

    /* modulate the color values by the calculated opacity */
    if ( opacity < 256 )
      c.alpha = uint8(( c.alpha * opacity ) >> 8 );

    /* valid segment image is necessary to draw the segment */
    if ( SegmentImage == null )
      return;

    var int32 w = SegmentImage.FrameSize.x;
    var int32 h = SegmentImage.FrameSize.y;

    var float quadAngle = 0.0;

    /* detect full 360° segment */
    if ( aDeltaAngle >= 360.0 )
    {
      aStartAngle = 0.0;
      aDeltaAngle = 360.0;
    }

    /* if pie segment should be displaced from the center, calculate the direction and resulting offset */
    if ( aDisplacement > 0.0 )
    {
      var float displaceAngle = aStartAngle + aDeltaAngle / 2.0;

      /* pre-calculate the sin/cos values for the displacement angle */
      sinA = math_sin( displaceAngle );
      cosA = math_cos( displaceAngle );

      /* shift the center point with given displacement  */
      aX = aX + (int32)( aDisplacement * sinA );
      aY = aY - (int32)( aDisplacement * cosA );
    }

    /* limit starting angle to 0°...90° and determine quadrant angle */
    while ( aStartAngle >= 90.0 )
    {
      aStartAngle = aStartAngle - 90.0;
      quadAngle = quadAngle + 90.0;
    }

    /* create temporary canvas if necessary */
    if (( tempImage == null ) || ( tempImage.FrameSize != SegmentImage.FrameSize ))
    {
      tempImage = new Graphics::Canvas;
      tempImage.FrameSize = SegmentImage.FrameSize;

    }

    /*
       ---
       For drawing a pie segment, two different scenarios are possible:
       1. the complete pie segment is within one quadrant - in this case
          an intermediate (temporary) canvas has to be used.
       2. the pie segment crosses one or more quadrant borders - in this
          case, the following parts have to be drawn:
          - starting segment (from start angle to quadrant border)
          - 0...4 complete quadrants
          - final segment (from quadrant border to stop angle)
       ---
       For rotating the four points of a segment, the rotation formula is:
         x' = x cosA - y sinA;
         y' = y cosA + x sinA;
       ---
    */

    /* scenario 1: start and stop angle are within the same quadrant */
    if (( aStartAngle > 0.0 ) && ( aStartAngle + aDeltaAngle < 90.0 ))
    {
      /* pre-calculate the sin/cos values for the delta angle */
      sinA = math_sin( aDeltaAngle );
      cosA = math_cos( aDeltaAngle );

      /* perform the rotation of the four points p1...p4 */
      p1x = (float)-w * cosA + (float)h * sinA;
      p1y = (float)-h * cosA - (float)w * sinA;
      p2x = (float)h * sinA;
      p2y = (float)-h * cosA;
      p3x = 0.0;
      p3y = 0.0;
      p4x = (float)-w * cosA;
      p4y = (float)-w * sinA;

      /* clear tempImage */
      tempImage.FillRectangle( rect( 0, 0, w, h ), rect( 0, 0, tempImage.FrameSize.x, tempImage.FrameSize.y ),
        #00000000, #00000000, #00000000, #00000000, false );

      /* rotate pie segment image into tempImage */
      tempImage.WarpBitmap( rect( 0, 0, w, h ), SegmentImage, 0,
        p1x, p1y + (float)h, 1.0,
        p2x, p2y + (float)h, 1.0,
        p3x, p3y + (float)h, 1.0,
        p4x, p4y + (float)h, 1.0,
        rect( 0, 0, w, h ), c, c, c, c, true, true );

      /* pre-calculate the sin/cos values for the delta angle */
      sinA = math_sin( aStartAngle + quadAngle ) * aScaling;
      cosA = math_cos( aStartAngle + quadAngle ) * aScaling;

      /* perform the rotation of the four points p1...p4 */
      p1x = (float)h * sinA;
      p1y = (float)-h * cosA;
      p2x = (float)w * cosA + (float)h * sinA;
      p2y = (float)-h * cosA + (float)w * sinA;
      p3x = (float)w * cosA;
      p3y = (float)w * sinA;
      p4x = 0.0;
      p4y = 0.0;

      /* rotate content from tempImage into destination canvas */
      aCanvas.WarpBitmap( aClip, tempImage, 0,
        p1x + (float)aX, p1y + (float)aY, 1.0,
        p2x + (float)aX, p2y + (float)aY, 1.0,
        p3x + (float)aX, p3y + (float)aY, 1.0,
        p4x + (float)aX, p4y + (float)aY, 1.0,
        rect( 0, 0, w, h ), #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, #FFFFFFFF, aBlend, true );
    }


    /* scenario 2: start and stop angle are within different quadrants */
    else
    {
      /* step 1: drawing pie segment from start angle to quadrant border */
      if ( aStartAngle > 0.0 )
      {
        /* pre-calculate the sin/cos values for the delta angle */
        sinA = math_sin( 90.0 + quadAngle + aStartAngle ) * aScaling;
        cosA = math_cos( 90.0 + quadAngle + aStartAngle ) * aScaling;

        /* perform the rotation of the four points p1...p4 */
        p1x = (float)-w * cosA + (float)h * sinA;
        p1y = (float)-h * cosA - (float)w * sinA;
        p2x = (float)h * sinA;
        p2y = (float)-h * cosA;
        p3x = 0.0;
        p3y = 0.0;
        p4x = (float)-w * cosA;
        p4y = (float)-w * sinA;

        /* ensure proper clipping at counter clockwise rotation */
        if ( quadAngle >= 360.0 )
          quadAngle = quadAngle - 360.0;

        /* ensure proper clipping into current quadrant */
        if ( quadAngle == 0.0 )
          clip = rect( aX, -10000, 10000, aY );
        else if ( quadAngle == 90.0 )
          clip = rect( aX, aY, 10000, 10000 );
        else if ( quadAngle == 180.0 )
          clip = rect( -10000, aY, aX, 10000 );
        else
          clip = rect( -10000, -10000, aX, aY );

        /* rotate pie segment image into destination canvas */
        aCanvas.WarpBitmap( aClip & clip, SegmentImage, 0,
          p1x + (float)aX, p1y + (float)aY, 1.0,
          p2x + (float)aX, p2y + (float)aY, 1.0,
          p3x + (float)aX, p3y + (float)aY, 1.0,
          p4x + (float)aX, p4y + (float)aY, 1.0,
          rect( 0, 0, w, h ), c, c, c, c, aBlend, true );

        /* calculate angles for next quadrant */
        quadAngle = quadAngle + 90.0;
        if ( quadAngle >= 360.0 )
          quadAngle = quadAngle - 360.0;
        aDeltaAngle = aDeltaAngle - ( 90.0 - aStartAngle );
      }

      /* step 2: drawing full quadrants */
      while( aDeltaAngle >= 90.0 )
      {
        /* pre-calculate the sin/cos values for the quadrant angle */
        sinA = math_sin( 90.0 + quadAngle ) * aScaling;
        cosA = math_cos( 90.0 + quadAngle ) * aScaling;

        /* perform the rotation of the four points p1...p4 */
        p1x = (float)-w * cosA + (float)h * sinA;
        p1y = (float)-h * cosA - (float)w * sinA;
        p2x = (float)h * sinA;
        p2y = (float)-h * cosA;
        p3x = 0.0;
        p3y = 0.0;
        p4x = (float)-w * cosA;
        p4y = (float)-w * sinA;

        /* ensure proper clipping at counter clockwise rotation */
        if ( quadAngle >= 360.0 )
          quadAngle = quadAngle - 360.0;

        /* ensure proper clipping into current quadrant */
        if ( quadAngle == 0.0 )
          clip = rect( aX, -10000, 10000, aY );
        else if ( quadAngle == 90.0 )
          clip = rect( aX, aY, 10000, 10000 );
        else if ( quadAngle == 180.0 )
          clip = rect( -10000, aY, aX, 10000 );
        else
          clip = rect( -10000, -10000, aX, aY );

        /* rotate pie segment image into destination canvas */
        aCanvas.WarpBitmap( aClip & clip, SegmentImage, 0,
          p1x + (float)aX, p1y + (float)aY, 1.0,
          p2x + (float)aX, p2y + (float)aY, 1.0,
          p3x + (float)aX, p3y + (float)aY, 1.0,
          p4x + (float)aX, p4y + (float)aY, 1.0,
          rect( 0, 0, w, h ), c, c, c, c, aBlend, true );

        /* calculate angles for next quadrant */
        quadAngle = quadAngle + 90.0;
        if ( quadAngle >= 360.0 )
          quadAngle = quadAngle - 360.0;
        aDeltaAngle = aDeltaAngle - 90.0;
      }

      /* step 3: drawing pie segment from quadrant border to stop angle */

      /* pre-calculate the sin/cos values for the delta angle */
      sinA = math_sin( aDeltaAngle + quadAngle ) * aScaling;
      cosA = math_cos( aDeltaAngle + quadAngle ) * aScaling;

      /* perform the rotation of the four points p1...p4 */
      p1x = (float)-w * cosA + (float)h * sinA;
      p1y = (float)-h * cosA - (float)w * sinA;
      p2x = (float)h * sinA;
      p2y = (float)-h * cosA;
      p3x = 0.0;
      p3y = 0.0;
      p4x = (float)-w * cosA;
      p4y = (float)-w * sinA;

      /* ensure proper clipping into current quadrant */
      if ( quadAngle == 0.0 )
        clip = rect( aX, -10000, 10000, aY );
      else if ( quadAngle == 90.0 )
        clip = rect( aX, aY, 10000, 10000 );
      else if ( quadAngle == 180.0 )
        clip = rect( -10000, aY, aX, 10000 );
      else
        clip = rect( -10000, -10000, aX, aY );

       /* rotate pie segment image into destination canvas */
      aCanvas.WarpBitmap( aClip & clip, SegmentImage, 0,
        p1x + (float)aX, p1y + (float)aY, 1.0,
        p2x + (float)aX, p2y + (float)aY, 1.0,
        p3x + (float)aX, p3y + (float)aY, 1.0,
        p4x + (float)aX, p4y + (float)aY, 1.0,
        rect( 0, 0, w, h ), c, c, c, c, aBlend, true );
    }


  }

  // The property 'Displacement' contains the displacement of each segments from \
  // the center point of the pie chart. The direction of the displacement is given \
  // by the vector from center point of the pie chart to the centroid of the segment.
  $rect <300,130,500,170>
  property float Displacement = 0.0;

  $rect <500,130,700,170>
  onset Displacement
  {
    // Check limits
    if ( value < 0.0 )
      value = 0.0;

    // Check for any changes...
    if ( value == pure Displacement )
      return;

    // Store the new value...
    pure Displacement = value;

    // ...and force an update of the component
    InvalidateArea( Bounds.orect );

  }

  $rect <500,310,700,350>
  onset Outlet
  {
    // Check if the new outlet differs from the currently used outlet
    if ( pure Outlet == value )
      return;

    // Detach from the previous outlet
    if ( pure Outlet != null )
      detachobserver onOutlet, pure Outlet;

    // Store the new outlet ...
    pure Outlet = value;

    // ... and attach to the new one
    if ( value != null )
      attachobserver onOutlet, value;

    // Finally, retrieve the current state of the property associated via 'Outlet'.
    if ( value != null )
      postsignal onOutlet;
  }

  // The property 'Outlet' can refer to any other 'int32' property the widget should \
  // remain synchronized with. When the referred property is modified, the widget \
  // is automatically notified to remain in sync with the property.
  // This approach follows the Controller-View programming paradigm. Here the widget \
  // represents the 'View' and the property referred via 'Outlet' can be seen as \
  // a part of the 'Controller'.
  $rect <300,310,500,350>
  property ^int32 Outlet = null;

  // This slot method will receive a signal, if the value of the property assigned \
  // to @Outlet has been changed by another widget or by the application logic. In \
  // response to this notification, the widget will update itself.
  $rect <700,310,900,350>
  slot onOutlet
  {
    // Read the current value of the associated property and update accordingly
    // the state of the widget.
    if ( Outlet != null )
      CurrentValue = Outlet^;
  }

  $rect <500,430,700,470>
  onset MaxValue
  {
    // Check if the given value differs from the current value
    if ( pure MaxValue == value )
      return;

    // Store the new value ...
    pure MaxValue = value;

    // ...and force an update of the component
    InvalidateArea( Bounds.orect );
  }

  $rect <500,390,700,430>
  onset MinValue
  {
    // Check if the given value differs from the current value
    if ( pure MinValue == value )
      return;

    // Store the new value ...
    pure MinValue = value;

    // ...and force an update of the component
    InvalidateArea( Bounds.orect );
  }

  $rect <500,350,700,390>
  onset CurrentValue
  {
    // Check if the given value differs from the current value.
    if ( pure CurrentValue == value )
      return;

    // Store the new value ...
    pure CurrentValue = value;

    // Update the needle position
    drawNeedle();

    // ...and force an update of the component
    InvalidateArea( Bounds.orect );
  }

  // The property 'MaxValue' defines the possible @CurrentValue at the upper end \
  // of the gauge indicator scale.
  $rect <300,430,500,470>
  property int32 MaxValue = 100;

  // The property 'MinValue' defines the possible @CurrentValue at the lower end \
  // of the gauge indicator scale.
  $rect <300,390,500,430>
  property int32 MinValue = 0;

  // The property 'CurrentValue' stores the momentary value of the gauge indicator. \
  // The value is limited automatically to the range between @MinValue and @MaxValue.
  $rect <300,350,500,390>
  property int32 CurrentValue = 1;

  // The property 'EndAngle' contains the end angle of the gauge indicator.
  $rect <300,40,500,80>
  property float EndAngle = 405.0;

  $rect <500,40,700,80>
  onset EndAngle
  {
    // Check for any changes...
    if ( value == pure EndAngle )
      return;

    // Store the new angle value...
    pure EndAngle = value;

    // ...and force an update of the component
    InvalidateArea( Bounds.orect );

  }

  $rect <500,260,700,300>
  var float newRotationAngle;

  $rect <0,480,200,520>
  method void drawNeedle()
  {
    var point dstPos = point( Bounds.w / 2, Bounds.h / 2 );

    // Convert the gauge's current value to a rotation angle within the scale
    // range specified by StartAngle .. EndAngle.
    if ( MaxValue != MinValue )
      newRotationAngle = ( float( CurrentValue - MinValue ) * ( EndAngle - StartAngle )) /
                           float( MaxValue - MinValue ) + StartAngle;

    // Let the needle appear at the calculated position with the calculated
    // rotation angle.
    Needle.RotateAndScale( dstPos, 360.0 - newRotationAngle, 1.0, 1.0 );
  }

  $rect <20,20,160,60>
  object Views::WarpImage Needle
  {
    preset Point4 = <144,289>;
    preset Point3 = <157,289>;
    preset Point2 = <157,231>;
    preset Point1 = <144,231>;
    preset SourceAnchor = <6,146>;
    preset Color = #FF0000FF;
    preset Bitmap = Dashboard::GaugeNeedle;
  }

  // This is the gauge indicator component which is used at Dashboard::Gauge.
  //
  // This component is based on the Charts::PieChart.
  note legend Note1
  {
    attr Bounds = <0,530,410,650>;
  }
}

$rect <1069,289,1269,329>
$output false
resource Resources::Bitmap GaugeGlowSegment
{
  attr bitmapfile FileName = .\Res\GaugeGlowSegment.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <10,489,210,529>
$output false
autoobject WidgetSet::ToggleButtonConfig LedButtonGreenConfig
{
  preset IconOnTintActive = Dashboard::Colors.LedsOnGreen;
  preset IconOnTintFocused = Dashboard::Colors.LedsOnGreen;
  preset IconOnTintDisabled = Dashboard::Colors.LedsOnGreen;
  preset IconOnTintDefault = Dashboard::Colors.LedsOnGreen;
  preset IconOffTintActive = Dashboard::Colors.TextLedsOff;
  preset IconOffTintFocused = Dashboard::Colors.TextLedsOff;
  preset IconOffTintDisabled = Dashboard::Colors.TextLedsOff;
  preset IconOffTintDefault = Dashboard::Colors.TextLedsOff;
}

// Helper
note group Note
{
  attr Bounds = <0,590,450,760>;
}

$rect <10,530,210,570>
$output false
autoobject WidgetSet::PushButtonConfig StartEngineButtonConfig
{
  preset FaceActive = Dashboard::StartEngine;
  preset FaceFocused = Dashboard::StartEngine;
  preset FaceDisabled = Dashboard::StartEngine;
  preset FaceDefault = Dashboard::StartEngine;
}

$rect <470,90,670,130>
$output false
resource Resources::Bitmap StartEngineStates
{
  attr bitmapfile FileName = .\Res\StartEngineStates.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize = <167,167>;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <470,220,670,260>
$output false
resource Resources::Bitmap SwitchIcon
{
  attr bitmapfile FileName = .\Res\SwitchIcon.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <470,180,670,220>
$output false
resource Resources::Bitmap OffIcon
{
  attr bitmapfile FileName = .\Res\OffIcon.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <220,528,420,568>
$output false
autoobject WidgetSet::PushButtonConfig DashboardButtonConfig
{
  preset IconTintActive = Dashboard::Colors.TextLedsOff;
  preset IconTintDisabled = Dashboard::Colors.TextLedsOff;
  preset IconTintDefault = Dashboard::Colors.Text;
}

$rect <870,300,1070,340>
$output false
resource Resources::Bitmap Logo
{
  attr bitmapfile FileName = .\Res\Logo.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <470,560,670,600>
$output false
class DemoMode
{
  // Demo Mode
  note group Note
  {
    attr Bounds = <0,50,620,340>;
  }

  $rect <10,130,210,170>
  object Effects::Int32Effect DemoModeTimer
  {
    preset OnFinished = onDemoModeCycleFinished;
    preset NoOfCycles = 1;
  }

  $rect <210,130,410,170>
  slot onDemoModeCycleFinished
  {
    if ( DemoStep == 0 )
    {
      DemoModeTimer.CycleDuration = 2200;

      StartEffect( SpeedEffect, 0, 100, Effects::Timing.Exp_Out, 2000 );
      StartEffect( PowerEffect, 0, 78, Effects::Timing.Exp_Out, 1500 );
      StartEffect( BatteryEffect, 67, 65, Effects::Timing.Exp_Out, 2200 );
      StartEffect( ODOEffect, 567, 569, Effects::Timing.Exp_Out, 2200 );
    }
    else if ( DemoStep == 1 )
    {
      DemoModeTimer.CycleDuration = 2200;

      StartEffect( SpeedEffect, 100, 77, Effects::Timing.Exp_Out, 2200 );
      StartEffect( PowerEffect, 78, 18, Effects::Timing.Exp_Out, 1900 );
      StartEffect( BatteryEffect, 65, 65, Effects::Timing.Exp_Out, 2200 );
      StartEffect( ODOEffect, 569, 570, Effects::Timing.Exp_Out, 2200 );
    }
    else if ( DemoStep == 2 )
    {
      DemoModeTimer.CycleDuration = 1100;

      StartEffect( SpeedEffect, 77, 37, Effects::Timing.Exp_Out, 1100 );
      StartEffect( PowerEffect, 18, 10, Effects::Timing.Exp_Out, 800 );
      StartEffect( BatteryEffect, 65, 65, Effects::Timing.Exp_Out, 1100 );
      StartEffect( ODOEffect, 270, 270, Effects::Timing.Exp_Out, 1100 );
    }
    else if ( DemoStep == 3 )
    {
      DemoModeTimer.CycleDuration = 2000;

      StartEffect( SpeedEffect, 37, 55, Effects::Timing.Exp_Out, 1700 );
      StartEffect( PowerEffect, 10, 15, Effects::Timing.Exp_Out, 1500 );
      StartEffect( BatteryEffect, 65, 64, Effects::Timing.Exp_Out, 1700 );
      StartEffect( ODOEffect, 270, 271, Effects::Timing.Exp_Out, 1700 );
    }
    else if ( DemoStep == 4 )
    {
      DemoModeTimer.CycleDuration = 2600;

      StartEffect( SpeedEffect, 55, 100, Effects::Timing.Exp_Out, 2600 );
      StartEffect( PowerEffect, 15, 67, Effects::Timing.Exp_Out, 1800 );
      StartEffect( BatteryEffect, 64, 62, Effects::Timing.Exp_Out, 2600 );
      StartEffect( ODOEffect, 271, 271, Effects::Timing.Exp_Out, 2600 );
    }
    else if ( DemoStep == 5 )
    {
      DemoModeTimer.CycleDuration = 4500;

      StartEffect( SpeedEffect, 100, 0, Effects::Timing.Exp_Out, 3500 );
      StartEffect( PowerEffect, 67, 0, Effects::Timing.Exp_Out, 1300 );
      StartEffect( BatteryEffect, 62, 62, Effects::Timing.Exp_Out, 2600 );
      StartEffect( ODOEffect, 271, 272, Effects::Timing.Exp_Out, 2600 );
    }

    DemoStep = ( DemoStep + 1 ) % 6;
    Dashboard::Device.ODO = 0;

    postsignal DemoModeTimer.StartEffect;
  }

  $rect <10,90,210,130>
  var int32 DemoStep = 0;

  $rect <10,170,210,210>
  object Effects::Int32Effect SpeedEffect
  {
    preset NoOfCycles = 1;
    preset Outlet = ^Dashboard::Device.Speed;
  }

  $rect <10,210,210,250>
  object Effects::Int32Effect PowerEffect
  {
    preset NoOfCycles = 1;
    preset Outlet = ^Dashboard::Device.Energy;
  }

  $rect <10,250,210,290>
  object Effects::Int32Effect BatteryEffect
  {
    preset NoOfCycles = 1;
    preset Outlet = ^Dashboard::Device.Battery;
  }

  $rect <410,90,610,130>
  method void StartEffect( arg Effects::Int32Effect aEffect, arg int32 aValue1, arg int32 aValue2, arg Effects::Timing aTiming, arg int32 aCycleDuration )
  {
    aEffect.Value1 = aValue1;
    aEffect.Value2 = aValue2;
    aEffect.Timing = aTiming;
    aEffect.CycleDuration = aCycleDuration;
    signal aEffect.StartEffect;
  }

  $rect <10,290,210,330>
  object Effects::Int32Effect ODOEffect
  {
    preset NoOfCycles = 1;
    preset Outlet = ^Dashboard::Device.ODO;
  }

  // The method Init() is invoked automatically after the component has been created. \
  // This method can be overridden and filled with logic containing additional initialization \
  // statements.
  $rect <0,0,200,40>
  inherited method Init()
  {
    attachobserver onDemoModeChanged, ^Dashboard::Device.DemoMode;
    postsignal onDemoModeChanged;
  }

  $rect <210,90,410,130>
  slot onDemoModeChanged
  {
    if ( Dashboard::Device.DemoMode )
      signal DemoModeTimer.StartEffect;
    else
      signal DemoModeTimer.StopEffect;
  }
}

// DemoMode & AutoDemoMode
note group Note5
{
  attr Bounds = <460,520,880,610>;
}

$rect <470,660,730,700>
$output false
autoobject Effects::FadeInOutTransition FadeInOutBottom
{
  preset Alignment = Effects::DialogAlignment[AlignHorzCenter, AlignVertBottom];
}

// Transitions
note group Note7
{
  attr Bounds = <460,620,880,760>;
}

$rect <470,700,730,740>
$output false
autoobject Effects::FadeInOutTransition FadeInOutCentered
{
  preset Alignment = Effects::DialogAlignment[AlignHorzCenter, AlignVertCenter];
}

// Font resource used per default by 'Text' and 'Attributed Text' views to ensure \
// that new views don't remain empty on the screen.
$rect <900,480,1100,520>
$output false
resource Resources::Font FontL
{
  attr fontname FontName = Asap Condensed SemiBold;
  attr fontheight Height = 36;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0x7F;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontheightmode HeightMode = Compatible;
  attr fontrowdistance RowDistance;
}

// Font resource used per default by 'Text' and 'Attributed Text' views to ensure \
// that new views don't remain empty on the screen.
$rect <900,560,1100,600>
$output false
resource Resources::Font FontXXL
{
  attr fontname FontName = Asap Condensed SemiBold;
  attr fontheight Height = 100;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0x7F;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontheightmode HeightMode = Compatible;
  attr fontrowdistance RowDistance;
}

// Font resource used per default by 'Text' and 'Attributed Text' views to ensure \
// that new views don't remain empty on the screen.
$rect <900,520,1100,560>
$output false
resource Resources::Font FontXL
{
  attr fontname FontName = Asap Condensed SemiBold;
  attr fontheight Height = 48;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0x7F;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontheightmode HeightMode = Compatible;
  attr fontrowdistance RowDistance;
}

// Font resource used per default by 'Text' and 'Attributed Text' views to ensure \
// that new views don't remain empty on the screen.
$rect <900,640,1100,680>
$output false
resource Resources::Font FontLightL
{
  attr fontname FontName = Asap Condensed;
  attr fontheight Height = 38;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0x7F;
  attr fontaspectratio AspectRatio = 0.9;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontheightmode HeightMode = Compatible;
  attr fontrowdistance RowDistance;
}

// Font resource used per default by 'Text' and 'Attributed Text' views to ensure \
// that new views don't remain empty on the screen.
$rect <900,680,1100,720>
$output false
resource Resources::Font FontLightXL
{
  attr fontname FontName = Asap Condensed;
  attr fontheight Height = 38;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0x7F, 0xB0;
  attr fontaspectratio AspectRatio = 0.9;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontheightmode HeightMode = Compatible;
  attr fontrowdistance RowDistance;
}

// Font resource used per default by 'Text' and 'Attributed Text' views to ensure \
// that new views don't remain empty on the screen.
$rect <900,600,1100,640>
$output false
resource Resources::Font FontLightM
{
  attr fontname FontName = Asap Condensed;
  attr fontheight Height = 34;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0x7F;
  attr fontaspectratio AspectRatio = 0.9;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontheightmode HeightMode = Compatible;
  attr fontrowdistance RowDistance;
}

// Fonts
note group Note8
{
  attr Bounds = <890,410,1110,760>;
}
