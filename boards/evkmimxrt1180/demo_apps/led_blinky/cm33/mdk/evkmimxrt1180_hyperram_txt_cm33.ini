/*
 * Copyright 2023-2024 NXP
 * All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

FUNC void _FLEXSPI1_ModuleReset(void)
{
    unsigned int reg;
    
    reg = _RDWORD(0x425E0000);  // FlexSPI1->MCR0
    if( (reg & 0x02) == 0)  // Module Enabled
    {
        reg = _RDWORD(0x425E0000);
        _WDWORD(0x425E0000, (reg | 0x1));
        do
        {
            reg = _RDWORD(0x425E0000);
        } while ((reg & 0x1) != 0);
    }
}

FUNC void _FLEXSPI1_WaitBusIdle(void)
{
    unsigned int reg;
    reg = _RDWORD(0x425E0000);  // FlexSPI1->MCR0
    if( (reg & 0x02) == 0)  // Module Enabled
    {
        do
        {
            reg = _RDWORD(0x425E00E0);
        } while ((reg & 0x3) != 0x3);
    }
}

FUNC void _FLEXSPI1_ClockInit(void)
{
    _WDWORD(0x54484350, 0x0);  // ROSC400M_CTRL1
    
    // Set flexspi1 root clock, use ROSC400, div = 4 = 1+3
    _WDWORD(0x54450A80, 0x103);     // CLOCK_ROOT[21].CONTROL, FlexSPI1
}

FUNC void _FLEXSPI1_SetPinForQuadMode(void) {
    // Set 4 Pin Mode
    // IOMUXC_GPIO_B2_07_FLEXSPI1_BUS2BIT_A_DQS
    _WDWORD(0x42A1023C, 0x17);
    _WDWORD(0x42A10544, 0x1);
    // IOMUXC_GPIO_B2_08_FLEXSPI1_BUS2BIT_A_SCLK
    _WDWORD(0x42A10240, 0x17);
    // IOMUXC_GPIO_B2_09_FLEXSPI1_BUS2BIT_A_SS0_B
    _WDWORD(0x42A10244, 0x17);
    // IOMUXC_GPIO_B2_10_FLEXSPI1_BUS2BIT_A_DATA00
    _WDWORD(0x42A10248, 0x17);
    // IOMUXC_GPIO_B2_11_FLEXSPI1_BUS2BIT_A_DATA01
    _WDWORD(0x42A1024C, 0x17);
    // IOMUXC_GPIO_B2_12_FLEXSPI1_BUS2BIT_A_DATA02
    _WDWORD(0x42A10250, 0x17);
    // IOMUXC_GPIO_B2_13_FLEXSPI1_BUS2BIT_A_DATA03
    _WDWORD(0x42A10254, 0x17);
}

FUNC void _FLEXSPI1_ModuleInit(void) {

    unsigned int reg;
    reg = _RDWORD(0x425E0000);
    _WDWORD(0x425E0000, (reg & 0xFFFFFFFD));

    //FLEXSPI1->MCR0 = 0xFFFF8010;
    _WDWORD(0x425E0000, 0xFFFF8010);
    //FLEXSPI1->MCR2 = 0x200001F7;
    _WDWORD(0x425E0008, 0x200001F7);
    //FLEXSPI1->AHBCR = 0x78;
    _WDWORD(0x425E000C, 0x78);
    
    //FLEXSPI1->FLSHCR0[0] = 0x00004000;
    _WDWORD(0x425E0060, 0x00004000);

    //FLEXSPI1->FLSHCR4 = 0xC3;
    _WDWORD(0x425E0094, 0xC3);
    //FLEXSPI1->IPRXFCR = 0x1C;
    _WDWORD(0x425E00B8, 0x1C);

    //FLEXSPI1->LUTKEY = 0x5AF05AF0UL;
    _WDWORD(0x425E0018, 0x5AF05AF0);
    //FLEXSPI1->LUTCR  = 0x02;
    _WDWORD(0x425E001C, 0x02);

    //FLEXSPI1->LUT[0] = 0x0A1804EB;  // AHB Quad Read Change to use Fast Read Quad
    _WDWORD(0x425E0200, 0x0A1804EB);
    //FLEXSPI1->LUT[1] = 0x26043206;
    _WDWORD(0x425E0204, 0x26043206);
    //FLEXSPI1->LUT[2] = 0x00000000;
    _WDWORD(0x425E0208, 0x00000000);
    //FLEXSPI1->LUT[3] = 0x00000000;
    _WDWORD(0x425E020C, 0x00000000);

    //FLEXSPI1->LUT[4] = 0x00000406;  // Write Enable
    _WDWORD(0x425E0210, 0x00000406);
    //FLEXSPI1->LUT[5] = 0x00000000;
    _WDWORD(0x425E0214, 0x00000000);
    //FLEXSPI1->LUT[6] = 0x00000000;
    _WDWORD(0x425E0218, 0x00000000);
    //FLEXSPI1->LUT[7] = 0x00000000;
    _WDWORD(0x425E021C, 0x00000000);

    //FLEXSPI1->LUT[8] = 0x20040401;  // Wirte s1
    _WDWORD(0x425E0220, 0x20040401);
    //FLEXSPI1->LUT[9] = 0x00000000;
    _WDWORD(0x425E0224, 0x00000000);
    //FLEXSPI1->LUT[10] = 0x00000000;
    _WDWORD(0x425E0228, 0x00000000);
    //FLEXSPI1->LUT[11] = 0x00000000;
    _WDWORD(0x425E022C, 0x00000000);

    //FLEXSPI1->LUT[12] = 0x24040405;  // Read s1
    _WDWORD(0x425E0230, 0x24040405);
    //FLEXSPI1->LUT[13] = 0x00000000;
    _WDWORD(0x425E0234, 0x00000000);
    //FLEXSPI1->LUT[14] = 0x00000000;
    _WDWORD(0x425E0238, 0x00000000);
    //FLEXSPI1->LUT[15] = 0x00000000;
    _WDWORD(0x425E023C, 0x00000000);

    //FLEXSPI1->LUT[16] = 0x00000404;  // Write Disable
    _WDWORD(0x425E0240, 0x00000404);
    //FLEXSPI1->LUT[17] = 0x00000000;
    _WDWORD(0x425E0244, 0x00000000);
    //FLEXSPI1->LUT[18] = 0x00000000;
    _WDWORD(0x425E0248, 0x00000000);
    //FLEXSPI1->LUT[19] = 0x00000000;
    _WDWORD(0x425E024C, 0x00000000);

    //FLEXSPI1->LUT[20] = 0x20040431;  // Wirte s2
    _WDWORD(0x425E0250, 0x20040431);
    //FLEXSPI1->LUT[21] = 0x00000000;
    _WDWORD(0x425E0254, 0x00000000);
    //FLEXSPI1->LUT[22] = 0x00000000;
    _WDWORD(0x425E0258, 0x00000000);
    //FLEXSPI1->LUT[23] = 0x00000000;
    _WDWORD(0x425E025C, 0x00000000);

    //FLEXSPI1->LUT[24] = 0x24040435;  // Read s2
    _WDWORD(0x425E0260, 0x24040435);
    //FLEXSPI1->LUT[25] = 0x00000000;
    _WDWORD(0x425E0264, 0x00000000);
    //FLEXSPI1->LUT[26] = 0x00000000;
    _WDWORD(0x425E0268, 0x00000000);
    //FLEXSPI1->LUT[27] = 0x00000000;
    _WDWORD(0x425E026C, 0x00000000);

    //FLEXSPI1->LUT[28] = 0x00000450;  // Write Enable Volatile
    _WDWORD(0x425E0270, 0x00000450);
    //FLEXSPI1->LUT[29] = 0x00000000;
    _WDWORD(0x425E0274, 0x00000000);
    //FLEXSPI1->LUT[30] = 0x00000000;
    _WDWORD(0x425E0278, 0x00000000);
    //FLEXSPI1->LUT[31] = 0x00000000;
    _WDWORD(0x425E027C, 0x00000000);

    //FLEXSPI1->LUTKEY = 0x5AF05AF0UL;
    _WDWORD(0x425E0018, 0x5AF05AF0);
    //FLEXSPI1->LUTCR  = 0x01;
    _WDWORD(0x425E001C, 0x01);
}

FUNC void _FLEXSPI2_ModuleReset(void)
{
    unsigned int reg;

    reg = _RDWORD(0x445E0000);  // FlexSPI2->MCR0
    if( (reg & 0x02) == 0)  // Module Enabled
    {
        reg = _RDWORD(0x445E0000);
        _WDWORD(0x445E0000, (reg | 0x1));
        do
        {
            reg = _RDWORD(0x445E0000);
        } while ((reg & 0x1) != 0);
    }
}

FUNC void _FLEXSPI2_WaitBusIdle(void)
{
    unsigned int reg;

    reg = _RDWORD(0x445E0000);  // FlexSPI2->MCR0
    if( (reg & 0x02) == 0)  // Module Enabled
    {
        do
        {
            reg = _RDWORD(0x445E00E0);
        } while ((reg & 0x3) != 0x3);
    }
}

FUNC void _FlexSPI2_SetPinForOctalMode(void)
{
    // Config IOMUX for FlexSPI2
    _WDWORD(0x42A10088, 0x00000013); // FLEXSPI2_B_DATA03
    _WDWORD(0x42A1008C, 0x00000013); // FLEXSPI2_B_DATA02
    _WDWORD(0x42A10090, 0x00000013); // FLEXSPI2_B_DATA01
    _WDWORD(0x42A10094, 0x00000013); // FLEXSPI2_B_DATA00
    _WDWORD(0x42A1009C, 0x00000013); // FLEXSPI2_A_DATA00
    _WDWORD(0x42A100A0, 0x00000013); // FLEXSPI2_A_DATA01
    _WDWORD(0x42A100A4, 0x00000013); // FLEXSPI2_A_DATA02
    _WDWORD(0x42A100A8, 0x00000013); // FLEXSPI2_A_DATA03
    _WDWORD(0x42A100AC, 0x00000013); // FLEXSPI2_A_SS0_B
    _WDWORD(0x42A100B0, 0x00000013); // FLEXSPI2_A_DQS
    _WDWORD(0x42A100B4, 0x00000013); // FLEXSPI2_A_SCLK

    //The input daisy!!
    _WDWORD(0x42A10594, 0x00000001); // FLEXSPI2_B_DATA03
    _WDWORD(0x42A10590, 0x00000001); // FLEXSPI2_B_DATA02
    _WDWORD(0x42A1058C, 0x00000001); // FLEXSPI2_B_DATA01
    _WDWORD(0x42A10588, 0x00000001); // FLEXSPI2_B_DATA00
    _WDWORD(0x42A10578, 0x00000000); // FLEXSPI2_A_DATA00
    _WDWORD(0x42A1057C, 0x00000000); // FLEXSPI2_A_DATA01
    _WDWORD(0x42A10580, 0x00000000); // FLEXSPI2_A_DATA02
    _WDWORD(0x42A10584, 0x00000000); // FLEXSPI2_A_DATA03
    _WDWORD(0x42A10570, 0x00000000); // FLEXSPI2_A_DQS
    _WDWORD(0x42A10598, 0x00000000); // FLEXSPI2_A_SCLK

    // PAD ctrl
    _WDWORD(0x42A102D0, 0x00000008); // FLEXSPI2_B_DATA03
    _WDWORD(0x42A102D4, 0x00000008); // FLEXSPI2_B_DATA02
    _WDWORD(0x42A102D8, 0x00000008); // FLEXSPI2_B_DATA01
    _WDWORD(0x42A102DC, 0x00000008); // FLEXSPI2_B_DATA00
    _WDWORD(0x42A102E4, 0x00000008); // FLEXSPI2_A_DATA00
    _WDWORD(0x42A102E8, 0x00000008); // FLEXSPI2_A_DATA01
    _WDWORD(0x42A102EC, 0x00000008); // FLEXSPI2_A_DATA02
    _WDWORD(0x42A102F0, 0x00000008); // FLEXSPI2_A_DATA03
    _WDWORD(0x42A102F4, 0x00000008); // FLEXSPI2_A_SS0_B
    _WDWORD(0x42A102F8, 0x00000008); // FLEXSPI2_A_DQS
    _WDWORD(0x42A102FC, 0x00000008); // FLEXSPI2_A_SCLK
}

FUNC void _FLEXSPI2_ClockInit(void)
{
    _WDWORD(0x54484350, 0x0);  // ROSC400M_CTRL1

    // Set flexspi2 root clock, use ROSC400, div = 2 = 1+1
    _WDWORD(0x44450B00, 0x101);     // CLOCK_ROOT[22].CONTROL, FlexSPI2
}

FUNC void _FLEXSPI2_ModuleInit(void)
{
    // Config FlexSPI2 Registers

    unsigned int reg;
    reg = _RDWORD(0x445E0000);
    _WDWORD(0x445E0000, (reg & 0xFFFFFFFD));

    _FLEXSPI2_ModuleReset();

    _WDWORD(0x445E0000, 0xFFFF3032); // MCR0
    _WDWORD(0x445E0004, 0xFFFFFFFF); // MCR1
    _WDWORD(0x445E0008, 0x200001F7); // MCR2
    _WDWORD(0x445E000C, 0x00000078); // AHBCR prefetch enable
    _WDWORD(0x445E0020, 0x800F0000); // AHBRXBUF0CR0
    _WDWORD(0x445E0024, 0x800F0000); // AHBRXBUF1CR0
    _WDWORD(0x445E0028, 0x800F0000); // AHBRXBUF2CR0
    _WDWORD(0x445E002C, 0x800F0000); // AHBRXBUF3CR0
    _WDWORD(0x445E0030, 0x800F0000); // AHBRXBUF4CR0
    _WDWORD(0x445E0034, 0x800F0000); // AHBRXBUF5CR0
    _WDWORD(0x445E0038, 0x80000020); // AHBRXBUF6CR0
    _WDWORD(0x445E003C, 0x80000020); // AHBRXBUF7CR0
    _WDWORD(0x445E00B8, 0x00000000); // IPRXFCR
    _WDWORD(0x445E00BC, 0x00000000); // IPTXFCR

    _WDWORD(0x445E0060, 0x00000000); // FLASHA1CR0
    _WDWORD(0x445E0064, 0x00000000); // FLASHA2CR0
    _WDWORD(0x445E0068, 0x00000000); // FLASHB1CR0
    _WDWORD(0x445E006C, 0x00000000); // FLASHB2CR0

    _FLEXSPI2_WaitBusIdle();

    _WDWORD(0x445E0060, 0x00002000); // FLASHA1CR0
    _WDWORD(0x445E0070, 0x00021C63); // FLASHA1CR1 
    _WDWORD(0x445E0080, 0x00000100); // FLASHA1CR2

    _FLEXSPI2_WaitBusIdle();

    _WDWORD(0x445E00C0, 0x00000079); // DLLCRA   
    _WDWORD(0x445E0000, 0xFFFF3030); // MCR0

    do
    {
        reg = _RDWORD(0x445E00E8);
    } while (0x3 != (reg & 0x3));
    _Sleep_(1);
    // __delay(100);//100us

    _WDWORD(0x445E0000, 0xFFFF3032); // MCR0
    _WDWORD(0x445E0094, 0x000000C2); // FLASHCR4 
    _WDWORD(0x445E0094, 0x000000C6); // FLASHCR4
    _WDWORD(0x445E0000, 0xFFFF3030); // MCR0

    _FLEXSPI2_WaitBusIdle();

    _WDWORD(0x445E0018, 0x5AF05AF0); // LUTKEY
    _WDWORD(0x445E001C, 0x00000002); // LUTCR
    _WDWORD(0x445E0200, 0x8B1887A0); // LUT[0]
    _WDWORD(0x445E0204, 0xB7078F10); // LUT[1]
    _WDWORD(0x445E0208, 0x0000A704); // LUT[2]
    _WDWORD(0x445E020C, 0x00000000); // LUT[3] 
    _WDWORD(0x445E0210, 0x8B188720); // LUT[4]
    _WDWORD(0x445E0214, 0xB7078F10); // LUT[5]
    _WDWORD(0x445E0218, 0x0000A304); // LUT[6]
    _WDWORD(0x445E021C, 0x00000000); // LUT[7]
    _WDWORD(0x445E0220, 0x8B1887E0); // LUT[8]
    _WDWORD(0x445E0224, 0xB7078F10); // LUT[9]
    _WDWORD(0x445E0228, 0x0000A704); // LUT[10]
    _WDWORD(0x445E022C, 0x00000000); // LUT[11]
    _WDWORD(0x445E0230, 0x8B188760); // LUT[12]
    _WDWORD(0x445E0234, 0xA3048F10); // LUT[13]
    _WDWORD(0x445E0238, 0x00000000); // LUT[14]
    _WDWORD(0x445E023C, 0x00000000); // LUT[15]
    _WDWORD(0x445E0240, 0x00000000); // LUT[16]
    _WDWORD(0x445E0244, 0x00000000); // LUT[17]
    _WDWORD(0x445E0248, 0x00000000); // LUT[18]
    _WDWORD(0x445E024C, 0x00000000); // LUT[19]
    _WDWORD(0x445E0018, 0x5AF05AF0); // LUTKEY
    _WDWORD(0x445E001C, 0x00000001); // LUTCR

    _FLEXSPI2_ModuleReset();
}

FUNC void Flash_Init(void) 
{
    printf("***************************************************\r\n");
    printf("Init Flash\r\n");

    _FLEXSPI1_WaitBusIdle();
    _FLEXSPI1_ModuleReset();

    _FLEXSPI1_SetPinForQuadMode();
    _FLEXSPI1_ClockInit();
    _FLEXSPI1_ModuleInit();

    printf("***************************************************\r\n");
}

FUNC void HyperRAM_Init(void)
{
    printf("***************************************************\r\n");
    printf("Init HyperRAM\r\n");

    _FLEXSPI2_WaitBusIdle();
    _FLEXSPI2_ModuleReset();

    _FlexSPI2_SetPinForOctalMode();
    _FLEXSPI2_ClockInit();
    _FLEXSPI2_ModuleInit();

    printf("***************************************************\r\n");
}

FUNC void ClearNVIC(void) {
    printf("***************************************************\r\n");
    printf("Clear NVIC\r\n");
    printf("***************************************************\r\n");
    memset(0xE000E180, 0x40, 0xFF);
    memset(0xE000E280, 0x40, 0xFF);
}

FUNC void Setup_PC_SP(void)
{
    SP = _RDWORD(0x04000000);          // Setup Stack Pointer
    PC = _RDWORD(0x04000004);          // Setup Program Counter
    _WDWORD(0xE000ED08, 0x04000000);   // Setup Vector Table Offset Register
}

FUNC void Setup (void) {
    ClearNVIC();
    // Flash_Init();
    Setup_PC_SP();
}

FUNC void OnResetExec (void)
{
    // executes upon software RESET
    
    Setup_PC_SP();                   // Setup for Running
}


HyperRAM_Init();

LOAD %L INCREMENTAL                  // Download

Setup();
