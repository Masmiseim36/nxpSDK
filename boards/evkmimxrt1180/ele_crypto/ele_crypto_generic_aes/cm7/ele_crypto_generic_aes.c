/*
 * Copyright 2024 NXP
 * All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

/*******************************************************************************
 * Includes
 ******************************************************************************/
#include "fsl_device_registers.h"
#include "fsl_debug_console.h"
#include "pin_mux.h"
#include "clock_config.h"
#include "board.h"

#include "ele_crypto.h" /* ELE Crypto SW */
#include "fsl_s3mu.h"   /* Messaging unit driver */
#include "ele_fw.h"     /* ELE FW, to be placed in bootable container in real world app */

/*******************************************************************************
 * Definitions
 ******************************************************************************/
#define S3MU MU_APPS_S3MUA

/*******************************************************************************
 * Prototypes
 ******************************************************************************/

/*******************************************************************************
 * Variables
 ******************************************************************************/
/*! @brief 16 bytes key for CBC method: "ultrapassword123". */
SDK_ALIGN(static uint8_t s_CbcKey128[], 8u) = {0x75, 0x6c, 0x74, 0x72, 0x61, 0x70, 0x61, 0x73,
                                               0x73, 0x77, 0x6f, 0x72, 0x64, 0x31, 0x32, 0x33};

/*! @brief 24 bytes key for CTR method: "ultrapassword123ultrapas". */
SDK_ALIGN(static uint8_t s_CtrKey192[], 8u) = {0x75, 0x6c, 0x74, 0x72, 0x61, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72,
                                               0x64, 0x31, 0x32, 0x33, 0x75, 0x6c, 0x74, 0x72, 0x61, 0x70, 0x61, 0x73};

/*! @brief 32 bytes key for OFB method: "ultrapassword123ultrapassword123". */
SDK_ALIGN(static uint8_t s_OfbKey256[], 8u) = {0x75, 0x6c, 0x74, 0x72, 0x61, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f,
                                               0x72, 0x64, 0x31, 0x32, 0x33, 0x75, 0x6c, 0x74, 0x72, 0x61, 0x70,
                                               0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x31, 0x32, 0x33};

/*!
 * @brief Plaintext for examples using the generic AES API.
 * 16-byte multiple, last '\0' is not used.
 */
SDK_ALIGN(static uint8_t s_GenericAesPlain[], 8u) =
    "Be that word our sign of parting, bird or fiend! I shrieked upstarting"
    "Get thee back into the tempest and the Nights Plutonian shore!"
    "Leave no black plume as a token of that lie thy soul hath spoken!"
    "Leave my loneliness unbroken! quit the bust above my door!"
    "Take thy beak from out my heart, and take thy form from off my door!"
    "Quoth the raven, Nevermore.  ";

/*! @brief Decrypted plaintext from CBC method goes here. */
SDK_ALIGN(static uint8_t s_CbcPlainDecrypted[sizeof(s_GenericAesPlain) - 1U], 8u);

/*! @brief Encrypted ciphertext from CBC method goes here. */
SDK_ALIGN(static uint8_t s_CbcCipher[sizeof(s_GenericAesPlain) - 1U], 8u);

/*! @brief Decrypted plaintext from CTR method goes here. */
SDK_ALIGN(static uint8_t s_CtrPlainDecrypted[sizeof(s_GenericAesPlain) - 1U], 8u);

/*! @brief Encrypted ciphertext from CTR method goes here. */
SDK_ALIGN(static uint8_t s_CtrCipher[sizeof(s_GenericAesPlain) - 1U], 8u);

/*! @brief Decrypted plaintext from OFB method goes here. */
SDK_ALIGN(static uint8_t s_OfbPlainDecrypted[sizeof(s_GenericAesPlain) - 1U], 8u);

/*! @brief Encrypted ciphertext from OFB method goes here. */
SDK_ALIGN(static uint8_t s_OfbCipher[sizeof(s_GenericAesPlain) - 1U], 8u);

/*! @brief Expected ciphertext from CBC method using s_CbcKey128 key. */
static uint8_t s_Cbc128CipherExpected[] = {
    0xeb, 0x69, 0xb5, 0xae, 0x7a, 0xbb, 0xb8, 0xee, 0x4d, 0xe5, 0x28, 0x97, 0xca, 0xab, 0x60, 0x65, 0x63, 0xf9, 0xe8,
    0x4c, 0x7f, 0xda, 0x0a, 0x02, 0x3a, 0x93, 0x16, 0x0d, 0x64, 0x56, 0x5a, 0x86, 0xf2, 0xe8, 0x5b, 0x38, 0x1d, 0x31,
    0xd7, 0x65, 0x7e, 0x8f, 0x8d, 0x53, 0xc5, 0xa6, 0x0c, 0x5d, 0xc5, 0x43, 0x98, 0x3b, 0x49, 0x3a, 0xce, 0x7d, 0xf9,
    0xb5, 0xf7, 0x95, 0x47, 0x89, 0xaf, 0xd8, 0x2f, 0xbd, 0xa4, 0xd8, 0x7f, 0xb9, 0x13, 0x3a, 0xcd, 0x17, 0xc8, 0xc4,
    0xb0, 0x5d, 0xe8, 0xf5, 0x19, 0x39, 0x6a, 0x14, 0x1b, 0x1b, 0x78, 0x5e, 0xe0, 0xd6, 0x67, 0x9a, 0x36, 0x17, 0x9c,
    0x7a, 0x88, 0x26, 0xfd, 0x8f, 0x3d, 0x82, 0xc9, 0xb1, 0x2a, 0x9c, 0xc0, 0xdd, 0xdb, 0x78, 0x61, 0x3b, 0x22, 0x5d,
    0x48, 0x3c, 0xab, 0x10, 0xd3, 0x5d, 0x0d, 0xa1, 0x25, 0x3e, 0x4d, 0xd6, 0x8e, 0xc4, 0x1b, 0x68, 0xbb, 0xa4, 0x2d,
    0x97, 0x2b, 0xd6, 0x23, 0xa0, 0xf2, 0x90, 0x8e, 0x07, 0x75, 0x44, 0xb3, 0xe2, 0x5a, 0x35, 0x38, 0x4c, 0x5d, 0x35,
    0xa9, 0x7c, 0xa3, 0xb6, 0x38, 0xe7, 0xf5, 0x20, 0xdc, 0x0e, 0x6c, 0x7c, 0x4b, 0x4f, 0x93, 0xc1, 0x81, 0x69, 0x02,
    0xb7, 0x66, 0x37, 0x24, 0x0d, 0xb8, 0x9a, 0xa8, 0xd4, 0x42, 0x75, 0x28, 0xe8, 0x33, 0x89, 0x1e, 0x60, 0x82, 0xe9,
    0xf6, 0x45, 0x72, 0x64, 0x65, 0xd2, 0xcd, 0x19, 0xd9, 0x5e, 0xa2, 0x59, 0x31, 0x82, 0x53, 0x20, 0x35, 0x13, 0x76,
    0x7f, 0xeb, 0xc3, 0xbe, 0xfa, 0x4a, 0x10, 0x83, 0x81, 0x0f, 0x24, 0x6d, 0xca, 0x53, 0x07, 0xb9, 0xe0, 0xb9, 0x5d,
    0x91, 0x2d, 0x90, 0x86, 0x5b, 0x9d, 0xaa, 0xcd, 0x28, 0xea, 0x11, 0xfb, 0x83, 0x39, 0x9c, 0xf5, 0x3b, 0xd9, 0xef,
    0x38, 0xc7, 0xa4, 0xad, 0x47, 0xf2, 0x2d, 0xd6, 0x6b, 0x26, 0x28, 0x59, 0xaa, 0x33, 0x01, 0x73, 0xc9, 0x46, 0x97,
    0xa3, 0xe5, 0x11, 0x71, 0x66, 0xef, 0x1f, 0x0b, 0xbc, 0xe7, 0x4f, 0x8c, 0x79, 0xe2, 0x39, 0x14, 0x85, 0xcd, 0xa9,
    0x59, 0xed, 0x78, 0x9d, 0x37, 0xf5, 0x46, 0xfc, 0xa9, 0x8a, 0x16, 0x0a, 0x76, 0x58, 0x6d, 0x59, 0x9e, 0x65, 0xbe,
    0x1b, 0xc2, 0x09, 0xa1, 0xf9, 0x40, 0xab, 0xdb, 0x2e, 0x11, 0x30, 0x29, 0x49, 0x75, 0xf7, 0x74, 0xe1, 0xf3, 0x78,
    0x97, 0x69, 0x2c, 0x6a, 0x0e, 0x0d, 0xbd, 0x72, 0x3d, 0x75, 0xd6, 0x0a, 0x8c, 0xc2, 0x92, 0xd9, 0xb6, 0x46, 0x91,
    0xa7, 0xe4, 0x74, 0x71, 0xf5, 0xb4, 0x21, 0x86, 0x18, 0xa8};

/*! @brief Expected ciphertext from CTR method using s_CtrKey192 key. */
static uint8_t s_Ctr192CipherExpected[] = {
    0x81, 0xd2, 0xa6, 0x8a, 0x52, 0x2a, 0xe6, 0x8e, 0x23, 0x44, 0x7e, 0xe5, 0x83, 0xd8, 0x52, 0x52, 0xbc, 0x38, 0xe4,
    0x3e, 0xa3, 0x74, 0x3c, 0x57, 0xd5, 0x14, 0x91, 0x6a, 0x53, 0x10, 0xcc, 0xed, 0xad, 0x8d, 0x7a, 0x96, 0x0e, 0x3c,
    0x43, 0x24, 0xef, 0x4d, 0xec, 0x63, 0x1f, 0x84, 0xe2, 0x52, 0xfc, 0x94, 0x7f, 0xed, 0xdd, 0x46, 0x11, 0x64, 0x37,
    0xe1, 0x1b, 0xe7, 0xd2, 0x02, 0x93, 0x66, 0xa4, 0x50, 0xc1, 0xc6, 0x1e, 0xb8, 0xff, 0x35, 0x15, 0xf2, 0xd9, 0xf2,
    0xbc, 0x0e, 0xd8, 0x46, 0x55, 0x56, 0xa8, 0xec, 0x11, 0x14, 0xa6, 0x74, 0xb6, 0x66, 0x9b, 0xfa, 0xf8, 0xbd, 0xb4,
    0xff, 0x6b, 0xe8, 0x71, 0xb2, 0xa3, 0xac, 0xeb, 0x62, 0x10, 0xb7, 0xfa, 0x97, 0x02, 0xbb, 0xc8, 0x15, 0x40, 0x4c,
    0x5e, 0x75, 0x18, 0x87, 0x02, 0x92, 0x05, 0xd3, 0x7a, 0xcc, 0xa3, 0xc1, 0xb7, 0xca, 0x93, 0x67, 0x54, 0x9d, 0x86,
    0x9e, 0x61, 0x8c, 0x49, 0x62, 0x21, 0xc7, 0x64, 0xb2, 0x85, 0xcf, 0x73, 0xfb, 0xe7, 0x1b, 0x9b, 0xe0, 0xf5, 0xd0,
    0x03, 0x12, 0x82, 0x08, 0x98, 0x68, 0xa2, 0x1e, 0xd8, 0xea, 0xa0, 0x84, 0x31, 0x65, 0x88, 0x9a, 0xbb, 0xfb, 0xed,
    0xbb, 0x6d, 0xdb, 0x9d, 0x5e, 0x2f, 0xfc, 0xfd, 0xe8, 0x67, 0x82, 0xcf, 0x65, 0x59, 0x25, 0x1a, 0x27, 0xa5, 0xb3,
    0x29, 0x9d, 0x50, 0x70, 0xcb, 0xbe, 0xab, 0xe2, 0x40, 0xa4, 0x79, 0xfa, 0x89, 0x3a, 0xee, 0xed, 0x37, 0x8d, 0x4d,
    0x1a, 0x5e, 0x4e, 0xfe, 0x5e, 0xbd, 0xa4, 0xb4, 0x33, 0xdb, 0x1e, 0xa4, 0x5d, 0xaa, 0xfc, 0x0f, 0xf9, 0xd9, 0x8a,
    0xca, 0xd1, 0x34, 0x7a, 0x79, 0x09, 0x41, 0x2e, 0xc9, 0xa7, 0x94, 0x31, 0x37, 0x11, 0x6c, 0x97, 0x69, 0xf2, 0x5e,
    0x31, 0x17, 0x53, 0x4b, 0x70, 0x00, 0x77, 0xf1, 0x4c, 0xb3, 0x1c, 0xf0, 0x19, 0x3c, 0x41, 0x11, 0x1c, 0x8d, 0x0f,
    0x54, 0xc2, 0xa2, 0x4f, 0x53, 0xcc, 0xb9, 0x4a, 0x3c, 0x3e, 0xce, 0xba, 0x1e, 0x3c, 0x49, 0xa5, 0x7f, 0xaa, 0x7f,
    0xde, 0xd1, 0x7f, 0xea, 0x99, 0x51, 0x9e, 0x89, 0x7c, 0x4c, 0x53, 0x71, 0xe9, 0x11, 0x04, 0xd5, 0xb6, 0x19, 0x8e,
    0x8c, 0xea, 0xba, 0x00, 0xaf, 0xe9, 0x27, 0x74, 0x0d, 0x05, 0x47, 0x65, 0xfc, 0x96, 0x70, 0x63, 0x21, 0xb8, 0x77,
    0x4d, 0xe3, 0x82, 0x27, 0x84, 0x1e, 0x38, 0x91, 0x1b, 0x24, 0xd1, 0x78, 0x37, 0x22, 0x63, 0x86, 0x9b, 0xed, 0xa9,
    0x25, 0x2d, 0xe7, 0x60, 0xba, 0xf4, 0xff, 0x47, 0x4b, 0x72};

/*! @brief Expected ciphertext from OFB method using s_OfbKey256 key. */
static uint8_t s_Ofb256CipherExpected[] = {
    0x68, 0xc0, 0xb3, 0x2e, 0x52, 0xfb, 0x30, 0x7a, 0x47, 0x36, 0xde, 0xeb, 0xfe, 0x3c, 0xd2, 0x0a, 0x17, 0x77, 0x19,
    0xb3, 0x0a, 0xa1, 0x1f, 0xb9, 0xb0, 0x3e, 0xf4, 0xdd, 0x47, 0xe4, 0xf1, 0xaf, 0xa9, 0xaf, 0x40, 0xe3, 0xe7, 0x32,
    0xf4, 0xe9, 0x3f, 0xd8, 0xef, 0xf2, 0x5d, 0x70, 0x66, 0x25, 0x95, 0x08, 0x72, 0x38, 0x53, 0x69, 0x89, 0xf7, 0x89,
    0x54, 0xc8, 0xd5, 0xa0, 0x50, 0x0c, 0x5f, 0xe1, 0xea, 0x63, 0xb1, 0xb0, 0x7e, 0x42, 0xe8, 0xa5, 0xc2, 0xf3, 0x9b,
    0xf3, 0x2e, 0x6b, 0xf7, 0xc8, 0x28, 0x5e, 0x52, 0x60, 0x78, 0x5c, 0xd3, 0xdb, 0xf0, 0x90, 0x60, 0x6b, 0x70, 0x23,
    0x08, 0x06, 0x9b, 0xe7, 0x12, 0x30, 0xf4, 0x4d, 0x3f, 0xb4, 0x23, 0x29, 0x9b, 0x25, 0x7c, 0x30, 0x03, 0x10, 0xc8,
    0x18, 0x8b, 0xb0, 0xec, 0x9e, 0xf9, 0xf1, 0xf8, 0xa1, 0x34, 0x0d, 0x21, 0xfe, 0x6c, 0xff, 0xc5, 0x2f, 0x88, 0x7c,
    0x94, 0xec, 0x32, 0x4e, 0xda, 0x87, 0x29, 0x12, 0xe6, 0x34, 0x4d, 0xd6, 0x12, 0x19, 0xea, 0xbb, 0x26, 0x4c, 0xd8,
    0xdd, 0x9c, 0x93, 0xc1, 0xf8, 0x3d, 0x60, 0xa1, 0x20, 0xed, 0xe7, 0xb3, 0x23, 0x1b, 0xf2, 0xba, 0x65, 0x75, 0x33,
    0x19, 0x26, 0xb1, 0x9b, 0x3f, 0x70, 0x83, 0xfd, 0x3f, 0x8c, 0xb1, 0x10, 0xc7, 0xea, 0xf0, 0xc0, 0xfb, 0x96, 0x7f,
    0xde, 0xd9, 0x36, 0x6f, 0x9a, 0x5d, 0x1b, 0xf6, 0x91, 0x8a, 0x31, 0x7c, 0x59, 0x17, 0x0c, 0x67, 0x1d, 0x43, 0x61,
    0x89, 0x5c, 0xc0, 0xc4, 0x24, 0xf7, 0x02, 0xa2, 0xb4, 0x42, 0x26, 0x0c, 0xde, 0x80, 0x04, 0xa6, 0x28, 0x73, 0x46,
    0x15, 0x7b, 0xc3, 0x5b, 0x93, 0xae, 0x9d, 0x1c, 0x7f, 0xe4, 0x27, 0x36, 0xef, 0x3a, 0x14, 0xe2, 0xca, 0x72, 0x79,
    0xb1, 0x12, 0x69, 0xb3, 0xf6, 0x8e, 0xb1, 0xb5, 0x0d, 0xb2, 0xc1, 0xc6, 0xd4, 0xed, 0x83, 0x43, 0x7b, 0x00, 0x54,
    0xfc, 0xe0, 0xf7, 0x1d, 0x9d, 0x54, 0xad, 0x4a, 0xe8, 0xad, 0x20, 0xf2, 0x7a, 0x98, 0x76, 0xd6, 0x45, 0xe5, 0x10,
    0xb7, 0xef, 0x05, 0x3c, 0x13, 0x4e, 0xb6, 0x8b, 0xbb, 0x01, 0x05, 0x42, 0x8e, 0x99, 0xba, 0x08, 0x8b, 0xfc, 0xee,
    0x38, 0xbc, 0xda, 0xbf, 0x1a, 0x24, 0x32, 0xa2, 0xcd, 0xd8, 0xc1, 0x63, 0x31, 0x87, 0x5f, 0xa8, 0x73, 0x79, 0x5d,
    0x52, 0xb5, 0x1c, 0x90, 0x99, 0xa0, 0x08, 0xe0, 0x7b, 0x34, 0x9e, 0xcd, 0x60, 0x9b, 0x3b, 0x9f, 0xd4, 0xcb, 0x4d,
    0x63, 0xdc, 0xfd, 0x35, 0x5a, 0xe4, 0xe3, 0x9b, 0xf7, 0xef};

/*! @brief Initialization vector for CBC method: 16 bytes: "mysecretpassword". */
SDK_ALIGN(static uint8_t s_CbcIv[16u], 8u) = {0x6d, 0x79, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74,
                                              0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64};

/*! @brief Initialization vector for CTR method: 16 bytes: "mysecretpassword". */
SDK_ALIGN(static uint8_t s_CtrIv[16u], 8u) = {0x6d, 0x79, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74,
                                              0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64};

/*! @brief Initialization vector for OFB method: 16 bytes: "mysecretpassword". */
SDK_ALIGN(static uint8_t s_OfbIv[16u], 8u) = {0x6d, 0x79, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74,
                                              0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64};

/*! @brief 16 bytes key for GCM method. */
SDK_ALIGN(static uint8_t s_GcmKey[16], 8u) = {0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
                                              0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08};

/*! @brief Plaintext for GCM method. */
SDK_ALIGN(static uint8_t s_GcmPlain[], 8u) = {0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5,
                                              0xaf, 0xf5, 0x26, 0x9a, 0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda,
                                              0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 0x1c, 0x3c, 0x0c, 0x95,
                                              0x95, 0x68, 0x09, 0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25,
                                              0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39};

/*! @brief Expected ciphertext from GCM method. */
static uint8_t s_GcmCipherExpected[] = {0x42, 0x83, 0x1e, 0xc2, 0x21, 0x77, 0x74, 0x24, 0x4b, 0x72, 0x21, 0xb7,
                                        0x84, 0xd0, 0xd4, 0x9c, 0xe3, 0xaa, 0x21, 0x2f, 0x2c, 0x02, 0xa4, 0xe0,
                                        0x35, 0xc1, 0x7e, 0x23, 0x29, 0xac, 0xa1, 0x2e, 0x21, 0xd5, 0x14, 0xb2,
                                        0x54, 0x66, 0x93, 0x1c, 0x7d, 0x8f, 0x6a, 0x5a, 0xac, 0x84, 0xaa, 0x05,
                                        0x1b, 0xa3, 0x0b, 0x39, 0x6a, 0x0a, 0xac, 0x97, 0x3d, 0x58, 0xe0, 0x91};

/*! @brief Encrypted ciphertext from GCM method goes here. */
SDK_ALIGN(static uint8_t s_GcmCipher[sizeof(s_GcmCipherExpected)], 8u);

/*! @brief Initialization vector for GCM method. */
SDK_ALIGN(static uint8_t s_GcmIv[12], 8u) = {0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad, 0xde, 0xca, 0xf8, 0x88};

/*! @brief Additional authenticated data for GCM method. */
SDK_ALIGN(static uint8_t s_GcmAad[], 8u) = {0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 0xfe, 0xed,
                                            0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 0xab, 0xad, 0xda, 0xd2};

/*! @brief Expected tag from GCM method. */
static uint8_t s_GcmTagExpected[] = {0x5b, 0xc9, 0x4f, 0xbc, 0x32, 0x21, 0xa5, 0xdb,
                                     0x94, 0xfa, 0xe9, 0x5a, 0xe7, 0x12, 0x1a, 0x47};

/*! @brief Encrypted tag from GCM method goes here. */
SDK_ALIGN(static uint8_t s_GcmTag[sizeof(s_GcmTagExpected)], 8u);

/*******************************************************************************
 * Code
 ******************************************************************************/

/*!
 * @brief Main function
 */
int main(void)
{
    /*
     * This code example demonstrates EdgeLock usage in following steps:
     * 0.  load and authenticate EdgeLock Enclave FW (to be done in secure boot flow in real world app)
     * 1.  Encrypt message using AES-CBC with 128-bit key and check output data with expected value
     * 2.  Decrypt message using AES-CBC with 128-bit key and check output data with expected value
     * 3.  Encrypt message using AES-CTR with 192-bit key and check output data with expected value
     * 4.  Decrypt message using AES-CTR with 192-bit key and check output data with expected value
     * 5.  Encrypt message using AES-OFB with 256-bit key and check output data with expected value
     * 6.  Decrypt message using AES-OFB with 256-bit key and check output data with expected value
     * 7.  Encrypt and authenticate message usign AES-GCM and check output data with expected value
     */

    status_t result = kStatus_Fail;

    do
    {
        /* HW init */
    BOARD_ConfigMPU();
    BOARD_InitBootPins();
    BOARD_InitBootClocks();
    BOARD_InitDebugConsole();

        PRINTF("EdgeLock Enclave secure Sub-System Driver Example:\r\n\r\n");

        /****************** Load EdgeLock FW message ***********************/
        PRINTF("****************** Load EdgeLock FW ***********************\r\n");
        if (ELE_LoadFw(S3MU, ele_fw) != kStatus_Success)
        {
            result = kStatus_Fail;
            break;
        }
        else
        {
            PRINTF("EdgeLock FW loaded and authenticated successfully.\r\n\r\n");
        }

        /****************** Generic Crypto AES-CBC **************************/
        PRINTF("****************** Generic Crypto AES-CBC ******************\r\n");
        ele_generic_cipher_t GenericCipherCBC = {0u};

        GenericCipherCBC.data     = (uint32_t)s_GenericAesPlain;
        GenericCipherCBC.output   = (uint32_t)s_CbcCipher;
        GenericCipherCBC.size     = sizeof(s_GenericAesPlain) - 1u;
        GenericCipherCBC.key      = (uint32_t)s_CbcKey128;
        GenericCipherCBC.key_size = sizeof(s_CbcKey128);
        GenericCipherCBC.iv       = (uint32_t)s_CbcIv;
        GenericCipherCBC.iv_size  = sizeof(s_CbcIv);
        GenericCipherCBC.mode     = kEncrypt;
        GenericCipherCBC.algo     = kAES_CBC;

        if (ELE_GenericCipher(S3MU, &GenericCipherCBC) != kStatus_Success)
        {
            result = kStatus_Fail;
            break;
        }

        if (memcmp(s_CbcCipher, s_Cbc128CipherExpected, sizeof(s_CbcCipher)) == 0)
        {
            PRINTF("AES-CBC Generic crypto encryption success and output matches expected result.\r\n\r\n");
        }
        else
        {
            result = kStatus_Fail;
            break;
        }

        GenericCipherCBC.data     = (uint32_t)s_CbcCipher;
        GenericCipherCBC.output   = (uint32_t)s_CbcPlainDecrypted;
        GenericCipherCBC.size     = sizeof(s_CbcCipher);
        GenericCipherCBC.key      = (uint32_t)s_CbcKey128;
        GenericCipherCBC.key_size = sizeof(s_CbcKey128);
        GenericCipherCBC.iv       = (uint32_t)s_CbcIv;
        GenericCipherCBC.iv_size  = sizeof(s_CbcIv);
        GenericCipherCBC.mode     = kDecrypt;
        GenericCipherCBC.algo     = kAES_CBC;

        if (ELE_GenericCipher(S3MU, &GenericCipherCBC) != kStatus_Success)
        {
            result = kStatus_Fail;
            break;
        }

        if (memcmp(s_CbcPlainDecrypted, s_GenericAesPlain, sizeof(s_CbcCipher)) == 0)
        {
            PRINTF("AES-CBC Generic crypto decryption success and output matches original message.\r\n\r\n");
        }
        else
        {
            result = kStatus_Fail;
            break;
        }

        /****************** Generic Crypto AES-CTR **************************/
        PRINTF("****************** Generic Crypto AES-CTR ******************\r\n");
        ele_generic_cipher_t GenericCipherCTR = {0u};

        GenericCipherCTR.data     = (uint32_t)s_GenericAesPlain;
        GenericCipherCTR.output   = (uint32_t)s_CtrCipher;
        GenericCipherCTR.size     = sizeof(s_GenericAesPlain) - 1u;
        GenericCipherCTR.key      = (uint32_t)s_CtrKey192;
        GenericCipherCTR.key_size = sizeof(s_CtrKey192);
        GenericCipherCTR.iv       = (uint32_t)s_CtrIv;
        GenericCipherCTR.iv_size  = sizeof(s_CtrIv);
        GenericCipherCTR.mode     = kEncrypt;
        GenericCipherCTR.algo     = kAES_CTR;

        if (ELE_GenericCipher(S3MU, &GenericCipherCTR) != kStatus_Success)
        {
            result = kStatus_Fail;
            break;
        }

        if (memcmp(s_CtrCipher, s_Ctr192CipherExpected, sizeof(s_CtrCipher)) == 0)
        {
            PRINTF("AES-CTR Generic crypto encryption success and output matches expected result.\r\n\r\n");
        }
        else
        {
            result = kStatus_Fail;
            break;
        }

        GenericCipherCTR.data     = (uint32_t)s_CtrCipher;
        GenericCipherCTR.output   = (uint32_t)s_CtrPlainDecrypted;
        GenericCipherCTR.size     = sizeof(s_CtrCipher);
        GenericCipherCTR.key      = (uint32_t)s_CtrKey192;
        GenericCipherCTR.key_size = sizeof(s_CtrKey192);
        GenericCipherCTR.iv       = (uint32_t)s_CtrIv;
        GenericCipherCTR.iv_size  = sizeof(s_CtrIv);
        GenericCipherCTR.mode     = kDecrypt;
        GenericCipherCTR.algo     = kAES_CTR;

        if (ELE_GenericCipher(S3MU, &GenericCipherCTR) != kStatus_Success)
        {
            result = kStatus_Fail;
            break;
        }

        if (memcmp(s_CtrPlainDecrypted, s_GenericAesPlain, sizeof(s_CtrCipher)) == 0)
        {
            PRINTF("AES-CTR Generic crypto decryption success and output matches original message.\r\n\r\n");
        }
        else
        {
            result = kStatus_Fail;
            break;
        }

        /****************** Generic Crypto AES-OFB **************************/
        PRINTF("****************** Generic Crypto AES-OFB ******************\r\n");
        ele_generic_cipher_t GenericCipherOFB = {0u};

        GenericCipherOFB.data     = (uint32_t)s_GenericAesPlain;
        GenericCipherOFB.output   = (uint32_t)s_OfbCipher;
        GenericCipherOFB.size     = sizeof(s_GenericAesPlain) - 1u;
        GenericCipherOFB.key      = (uint32_t)s_OfbKey256;
        GenericCipherOFB.key_size = sizeof(s_OfbKey256);
        GenericCipherOFB.iv       = (uint32_t)s_OfbIv;
        GenericCipherOFB.iv_size  = sizeof(s_OfbIv);
        GenericCipherOFB.mode     = kEncrypt;
        GenericCipherOFB.algo     = kAES_OFB;

        if (ELE_GenericCipher(S3MU, &GenericCipherOFB) != kStatus_Success)
        {
            result = kStatus_Fail;
            break;
        }

        if (memcmp(s_OfbCipher, s_Ofb256CipherExpected, sizeof(s_OfbCipher)) == 0)
        {
            PRINTF("AES-OFB Generic crypto encryption success and output matches expected result.\r\n\r\n");
        }
        else
        {
            result = kStatus_Fail;
            break;
        }

        GenericCipherOFB.data     = (uint32_t)s_OfbCipher;
        GenericCipherOFB.output   = (uint32_t)s_OfbPlainDecrypted;
        GenericCipherOFB.size     = sizeof(s_OfbCipher);
        GenericCipherOFB.key      = (uint32_t)s_OfbKey256;
        GenericCipherOFB.key_size = sizeof(s_OfbKey256);
        GenericCipherOFB.iv       = (uint32_t)s_OfbIv;
        GenericCipherOFB.iv_size  = sizeof(s_OfbIv);
        GenericCipherOFB.mode     = kDecrypt;
        GenericCipherOFB.algo     = kAES_OFB;

        if (ELE_GenericCipher(S3MU, &GenericCipherOFB) != kStatus_Success)
        {
            result = kStatus_Fail;
            break;
        }

        if (memcmp(s_OfbPlainDecrypted, s_GenericAesPlain, sizeof(s_OfbCipher)) == 0)
        {
            PRINTF("AES-OFB Generic crypto decryption success and output matches original message.\r\n\r\n");
        }
        else
        {
            result = kStatus_Fail;
            break;
        }

        /****************** Generic Crypto AES-GCM **************************/
        PRINTF("****************** Generic Crypto AES-GCM ******************\r\n");
        ele_generic_aead_t GenericAeadGCM = {0u};

        GenericAeadGCM.data     = (uint32_t)s_GcmPlain;
        GenericAeadGCM.output   = (uint32_t)s_GcmCipher;
        GenericAeadGCM.size     = sizeof(s_GcmPlain);
        GenericAeadGCM.key      = (uint32_t)s_GcmKey;
        GenericAeadGCM.key_size = sizeof(s_GcmKey);
        GenericAeadGCM.iv       = (uint32_t)s_GcmIv;
        GenericAeadGCM.iv_size  = sizeof(s_GcmIv);
        GenericAeadGCM.aad      = (uint32_t)s_GcmAad;
        GenericAeadGCM.aad_size = sizeof(s_GcmAad);
        GenericAeadGCM.tag      = (uint32_t)s_GcmTag;
        GenericAeadGCM.tag_size = sizeof(s_GcmTag);
        GenericAeadGCM.mode     = kEncrypt;
        GenericAeadGCM.algo     = kAES_GCM;

        if (ELE_GenericAead(S3MU, &GenericAeadGCM) != kStatus_Success)
        {
            result = kStatus_Fail;
            break;
        }

        if (memcmp(s_GcmCipher, s_GcmCipherExpected, sizeof(s_GcmCipher)) == 0 &&
            memcmp(s_GcmTag, s_GcmTagExpected, sizeof(s_GcmTag)) == 0)
        {
            PRINTF("AES-GCM Generic crypto encryption success and output matches expected result.\r\n\r\n");
        }
        else
        {
            result = kStatus_Fail;
            break;
        }

        /****************** END of Example *************************************/
        result = kStatus_Success;

    } while (0);

    if (result == kStatus_Success)
    {
        PRINTF("End of Example with SUCCESS!!\r\n\r\n");
    }
    else
    {
        PRINTF("ERROR: execution of commands on Security Sub-System failed!\r\n\r\n");
    }
    while (1)
    {
    }
}
