<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MCUX CLNS: mcuxClMath_Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MCUX CLNS
   </div>
   <div id="projectbrief">MCUX Crypto Library Normal Secure</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('a01121.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">mcuxClMath_Functions<div class="ingroups"><a class="el" href="a01120.html">mcuxClMath</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Defines all functions of <a class="el" href="a01120.html">mcuxClMath</a>.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaadd4485b0f1db32b6da6e6b7a2e6cc11"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#gaadd4485b0f1db32b6da6e6b7a2e6cc11">MCUXCLMATH_SHIFTMODULUS</a>(iNShifted,  iN)</td></tr>
<tr class="memdesc:gaadd4485b0f1db32b6da6e6b7a2e6cc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="a01121.html#ga65003277bfc2c6eb64be0f23261cadd7" title="Prepares shifted modulus.">mcuxClMath_ShiftModulus</a>.  <br /></td></tr>
<tr class="separator:gaadd4485b0f1db32b6da6e6b7a2e6cc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35df7cdad4c81c5e276f373c70c571d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#ga35df7cdad4c81c5e276f373c70c571d0">MCUXCLMATH_FP_SHIFTMODULUS</a>(iNShifted,  iN)</td></tr>
<tr class="memdesc:ga35df7cdad4c81c5e276f373c70c571d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="a01121.html#ga65003277bfc2c6eb64be0f23261cadd7" title="Prepares shifted modulus.">mcuxClMath_ShiftModulus</a> with flow protection.  <br /></td></tr>
<tr class="separator:ga35df7cdad4c81c5e276f373c70c571d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab588855e23f750a4c9f7533b54a11325"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#gab588855e23f750a4c9f7533b54a11325">MCUXCLMATH_NDASH</a>(iN,  iT)</td></tr>
<tr class="memdesc:gab588855e23f750a4c9f7533b54a11325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="a01121.html#ga47ca58caa097e65c0925aa488f287a1e" title="Prepares modulus (calculates NDash) for PKC modular multiplication.">mcuxClMath_NDash</a>.  <br /></td></tr>
<tr class="separator:gab588855e23f750a4c9f7533b54a11325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa0d390f4eb5728edfd764936aeee313"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#gafa0d390f4eb5728edfd764936aeee313">MCUXCLMATH_FP_NDASH</a>(iN,  iT)</td></tr>
<tr class="memdesc:gafa0d390f4eb5728edfd764936aeee313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="a01121.html#ga47ca58caa097e65c0925aa488f287a1e" title="Prepares modulus (calculates NDash) for PKC modular multiplication.">mcuxClMath_NDash</a> with flow protection.  <br /></td></tr>
<tr class="separator:gafa0d390f4eb5728edfd764936aeee313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga666d3347d6f96a09b791355e596de46d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#ga666d3347d6f96a09b791355e596de46d">MCUXCLMATH_QDASH</a>(iQDash,  iNShifted,  iN,  iT,  len)</td></tr>
<tr class="memdesc:ga666d3347d6f96a09b791355e596de46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="a01121.html#ga61ef022af097c89154560df0f81b3caa" title="Calculates QDash = Q * Q&#39; mod n, where Q = 256^(operandSize) mod n, and Q&#39; = 256^length mod n.">mcuxClMath_QDash</a>.  <br /></td></tr>
<tr class="separator:ga666d3347d6f96a09b791355e596de46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7703703d552c5446acdf38d82cd81971"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#ga7703703d552c5446acdf38d82cd81971">MCUXCLMATH_FP_QDASH</a>(iQDash,  iNShifted,  iN,  iT,  len)</td></tr>
<tr class="memdesc:ga7703703d552c5446acdf38d82cd81971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="a01121.html#ga61ef022af097c89154560df0f81b3caa" title="Calculates QDash = Q * Q&#39; mod n, where Q = 256^(operandSize) mod n, and Q&#39; = 256^length mod n.">mcuxClMath_QDash</a> with flow protection.  <br /></td></tr>
<tr class="separator:ga7703703d552c5446acdf38d82cd81971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ee6d9b078ecc35a081a3a8cdbec0968"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#ga4ee6d9b078ecc35a081a3a8cdbec0968">MCUXCLMATH_QSQUARED</a>(iQSqr,  iNShifted,  iN,  iT)</td></tr>
<tr class="memdesc:ga4ee6d9b078ecc35a081a3a8cdbec0968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="a01121.html#gae2ad68ea7641a23751583c27ed1d77a7" title="Calculates QSquared = Q^2 mod n, where Q = 256^(operandSize) mod n.">mcuxClMath_QSquared</a>.  <br /></td></tr>
<tr class="separator:ga4ee6d9b078ecc35a081a3a8cdbec0968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcd348426e9998703dc6f93194a62f80"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#gadcd348426e9998703dc6f93194a62f80">MCUXCLMATH_FP_QSQUARED</a>(iQSqr,  iNShifted,  iN,  iT)</td></tr>
<tr class="memdesc:gadcd348426e9998703dc6f93194a62f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="a01121.html#gae2ad68ea7641a23751583c27ed1d77a7" title="Calculates QSquared = Q^2 mod n, where Q = 256^(operandSize) mod n.">mcuxClMath_QSquared</a> with flow protection.  <br /></td></tr>
<tr class="separator:gadcd348426e9998703dc6f93194a62f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa59866fd485a59868a2a594a5858f1de"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#gaa59866fd485a59868a2a594a5858f1de">MCUXCLMATH_MODINV</a>(iR,  iX,  iN,  iT)</td></tr>
<tr class="memdesc:gaa59866fd485a59868a2a594a5858f1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="a01121.html#ga9c01f0090ea0220a735ea6992515cf7a" title="Calculates modular inversion, with odd modulus.">mcuxClMath_ModInv</a>.  <br /></td></tr>
<tr class="separator:gaa59866fd485a59868a2a594a5858f1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab456571414ef2f49a91b61f0c91009ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#gab456571414ef2f49a91b61f0c91009ba">MCUXCLMATH_FP_MODINV</a>(iR,  iX,  iN,  iT)</td></tr>
<tr class="memdesc:gab456571414ef2f49a91b61f0c91009ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="a01121.html#ga9c01f0090ea0220a735ea6992515cf7a" title="Calculates modular inversion, with odd modulus.">mcuxClMath_ModInv</a> with flow protection.  <br /></td></tr>
<tr class="separator:gab456571414ef2f49a91b61f0c91009ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ee39987ba7de0e36abc848d77b4eaa3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#ga3ee39987ba7de0e36abc848d77b4eaa3">MCUXCLMATH_REDUCEMODEVEN</a>(iR,  iX,  iN,  iT0,  iT1,  iT2,  iT3)</td></tr>
<tr class="memdesc:ga3ee39987ba7de0e36abc848d77b4eaa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="a01121.html#gadcf87738f49ecf4c39ee725fa6cb88f9" title="Calculates modular reduction with even modulus.">mcuxClMath_ReduceModEven</a>.  <br /></td></tr>
<tr class="separator:ga3ee39987ba7de0e36abc848d77b4eaa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed2b24ff10b916eb07a842a2a05ad341"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#gaed2b24ff10b916eb07a842a2a05ad341">MCUXCLMATH_FP_REDUCEMODEVEN</a>(iR,  iX,  iN,  iT0,  iT1,  iT2,  iT3)</td></tr>
<tr class="memdesc:gaed2b24ff10b916eb07a842a2a05ad341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="a01121.html#gadcf87738f49ecf4c39ee725fa6cb88f9" title="Calculates modular reduction with even modulus.">mcuxClMath_ReduceModEven</a> with flow protection.  <br /></td></tr>
<tr class="separator:gaed2b24ff10b916eb07a842a2a05ad341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82842f4b45c0d86e4c2d6d29e23c259b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#ga82842f4b45c0d86e4c2d6d29e23c259b">MCUXCLMATH_MODEXP_SQRMULTL2R</a>(pExp,  byteLenExp,  iR,  iX,  iN,  iT)</td></tr>
<tr class="memdesc:ga82842f4b45c0d86e4c2d6d29e23c259b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="a01121.html#gabdd7a91f84faca1e208c143a25e318f8" title="Calculates modular exponentiation.">mcuxClMath_ModExp_SqrMultL2R</a>.  <br /></td></tr>
<tr class="separator:ga82842f4b45c0d86e4c2d6d29e23c259b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f0c8d67f0c192341fbf9ac436f02173"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#ga9f0c8d67f0c192341fbf9ac436f02173">MCUXCLMATH_FP_MODEXP_SQRMULTL2R</a>(pExp,  byteLenExp,  iR,  iX,  iN,  iT)</td></tr>
<tr class="memdesc:ga9f0c8d67f0c192341fbf9ac436f02173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="a01121.html#gabdd7a91f84faca1e208c143a25e318f8" title="Calculates modular exponentiation.">mcuxClMath_ModExp_SqrMultL2R</a> with flow protection.  <br /></td></tr>
<tr class="separator:ga9f0c8d67f0c192341fbf9ac436f02173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e0168ff93f7bffd7d56ce509ba29c59"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#ga3e0168ff93f7bffd7d56ce509ba29c59">MCUXCLMATH_SECMODEXP</a>(session,  pExp,  pExpTemp,  byteLenExp,  iR,  iX,  iN,  iTE,  iT0,  iT1,  iT2,  iT3)</td></tr>
<tr class="memdesc:ga3e0168ff93f7bffd7d56ce509ba29c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="a01121.html#ga4e9809a996e6671dcafb0a455b83e10a" title="Securely calculates modular exponentiation.">mcuxClMath_SecModExp</a>.  <br /></td></tr>
<tr class="separator:ga3e0168ff93f7bffd7d56ce509ba29c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae807c4ed789f67aa150addbae31de180"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#gae807c4ed789f67aa150addbae31de180">MCUXCLMATH_EXACTDIVIDEODD</a>(iR,  iX,  iN,  iT,  xPkcByteLen,  yPkcByteLen)</td></tr>
<tr class="memdesc:gae807c4ed789f67aa150addbae31de180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="a01121.html#ga7aa33c63d602fdb151d3e342284b2171" title="Calculates exact division with odd divisor.">mcuxClMath_ExactDivideOdd</a>.  <br /></td></tr>
<tr class="separator:gae807c4ed789f67aa150addbae31de180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1d62616daa224745d2ed40fdfa4d724"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#gaf1d62616daa224745d2ed40fdfa4d724">MCUXCLMATH_FP_EXACTDIVIDEODD</a>(iR,  iX,  iN,  iT,  xPkcByteLen,  yPkcByteLen)</td></tr>
<tr class="memdesc:gaf1d62616daa224745d2ed40fdfa4d724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="a01121.html#ga7aa33c63d602fdb151d3e342284b2171" title="Calculates exact division with odd divisor.">mcuxClMath_ExactDivideOdd</a> with flow protection.  <br /></td></tr>
<tr class="separator:gaf1d62616daa224745d2ed40fdfa4d724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae99e5e55dda4387e4384e974a112a760"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#gae99e5e55dda4387e4384e974a112a760">MCUXCLMATH_EXACTDIVIDE</a>(iR,  iX,  iN,  iT,  xPkcByteLen,  yPkcByteLen)</td></tr>
<tr class="memdesc:gae99e5e55dda4387e4384e974a112a760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="a01121.html#ga9416369d37627425ecac95580d1c3ee4" title="Calculates exact division (supporting even divisor).">mcuxClMath_ExactDivide</a>.  <br /></td></tr>
<tr class="separator:gae99e5e55dda4387e4384e974a112a760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dd21ea08b92f104bd3d9bff5ce7efe7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#ga4dd21ea08b92f104bd3d9bff5ce7efe7">MCUXCLMATH_FP_EXACTDIVIDE</a>(iR,  iX,  iN,  iT,  xPkcByteLen,  yPkcByteLen)</td></tr>
<tr class="memdesc:ga4dd21ea08b92f104bd3d9bff5ce7efe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for <a class="el" href="a01121.html#ga9416369d37627425ecac95580d1c3ee4" title="Calculates exact division (supporting even divisor).">mcuxClMath_ExactDivide</a> with flow protection.  <br /></td></tr>
<tr class="separator:ga4dd21ea08b92f104bd3d9bff5ce7efe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga716b9990024e2ea5e5984ca960a5e861"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#ga716b9990024e2ea5e5984ca960a5e861">mcuxClMath_InitLocalUptrt</a> (uint32_t i3_i2_i1_i0, uint32_t i7_i6_i5_i4, uint16_t *localPtrUptrt, uint8_t noOfIndices, const uint16_t **oldPtrUptrt)</td></tr>
<tr class="memdesc:ga716b9990024e2ea5e5984ca960a5e861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes and uses the new UPTRT and returns the address of original UPTRT.  <br /></td></tr>
<tr class="separator:ga716b9990024e2ea5e5984ca960a5e861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3418e7e61a5622de864d5cd72407cf32"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#ga3418e7e61a5622de864d5cd72407cf32">mcuxClMath_LeadingZeros</a> (uint8_t iX)</td></tr>
<tr class="memdesc:ga3418e7e61a5622de864d5cd72407cf32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts number of leading zero bits of a PKC operand.  <br /></td></tr>
<tr class="separator:ga3418e7e61a5622de864d5cd72407cf32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0203db0be2a5c09157c0db697cc2685f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#ga0203db0be2a5c09157c0db697cc2685f">mcuxClMath_TrailingZeros</a> (uint8_t iX)</td></tr>
<tr class="memdesc:ga0203db0be2a5c09157c0db697cc2685f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts number of trailing zero bits of a PKC operand.  <br /></td></tr>
<tr class="separator:ga0203db0be2a5c09157c0db697cc2685f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65003277bfc2c6eb64be0f23261cadd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#ga65003277bfc2c6eb64be0f23261cadd7">mcuxClMath_ShiftModulus</a> (uint16_t iNShifted_iN)</td></tr>
<tr class="memdesc:ga65003277bfc2c6eb64be0f23261cadd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares shifted modulus.  <br /></td></tr>
<tr class="separator:ga65003277bfc2c6eb64be0f23261cadd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47ca58caa097e65c0925aa488f287a1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#ga47ca58caa097e65c0925aa488f287a1e">mcuxClMath_NDash</a> (uint16_t iN_iT)</td></tr>
<tr class="memdesc:ga47ca58caa097e65c0925aa488f287a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares modulus (calculates NDash) for PKC modular multiplication.  <br /></td></tr>
<tr class="separator:ga47ca58caa097e65c0925aa488f287a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61ef022af097c89154560df0f81b3caa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#ga61ef022af097c89154560df0f81b3caa">mcuxClMath_QDash</a> (uint32_t iQDash_iNShifted_iN_iT, uint16_t length)</td></tr>
<tr class="memdesc:ga61ef022af097c89154560df0f81b3caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates QDash = Q * Q' mod n, where Q = 256^(operandSize) mod n, and Q' = 256^length mod n.  <br /></td></tr>
<tr class="separator:ga61ef022af097c89154560df0f81b3caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2ad68ea7641a23751583c27ed1d77a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#gae2ad68ea7641a23751583c27ed1d77a7">mcuxClMath_QSquared</a> (uint32_t iQSqr_iNShifted_iN_iT)</td></tr>
<tr class="memdesc:gae2ad68ea7641a23751583c27ed1d77a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates QSquared = Q^2 mod n, where Q = 256^(operandSize) mod n.  <br /></td></tr>
<tr class="separator:gae2ad68ea7641a23751583c27ed1d77a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c01f0090ea0220a735ea6992515cf7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#ga9c01f0090ea0220a735ea6992515cf7a">mcuxClMath_ModInv</a> (uint32_t iR_iX_iN_iT)</td></tr>
<tr class="memdesc:ga9c01f0090ea0220a735ea6992515cf7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates modular inversion, with odd modulus.  <br /></td></tr>
<tr class="separator:ga9c01f0090ea0220a735ea6992515cf7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcf87738f49ecf4c39ee725fa6cb88f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#gadcf87738f49ecf4c39ee725fa6cb88f9">mcuxClMath_ReduceModEven</a> (uint32_t iR_iX_iN_iT0, uint32_t iT1_iT2_iT3)</td></tr>
<tr class="memdesc:gadcf87738f49ecf4c39ee725fa6cb88f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates modular reduction with even modulus.  <br /></td></tr>
<tr class="separator:gadcf87738f49ecf4c39ee725fa6cb88f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdd7a91f84faca1e208c143a25e318f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#gabdd7a91f84faca1e208c143a25e318f8">mcuxClMath_ModExp_SqrMultL2R</a> (const uint8_t *pExp, uint32_t expByteLength, uint32_t iR_iX_iN_iT)</td></tr>
<tr class="memdesc:gabdd7a91f84faca1e208c143a25e318f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates modular exponentiation.  <br /></td></tr>
<tr class="separator:gabdd7a91f84faca1e208c143a25e318f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e9809a996e6671dcafb0a455b83e10a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01122.html#gaf541274a57cf9f823c029f73ff733ae0">mcuxClMath_Status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#ga4e9809a996e6671dcafb0a455b83e10a">mcuxClMath_SecModExp</a> (<a class="el" href="a01188.html#ga17fd337618b05459b4a343393e099b56">mcuxClSession_Handle_t</a> session, const uint8_t *pExp, uint32_t *pExpTemp, uint32_t expByteLength, uint32_t iT3_iX_iT2_iT1, uint32_t iN_iTE_iT0_iR)</td></tr>
<tr class="memdesc:ga4e9809a996e6671dcafb0a455b83e10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Securely calculates modular exponentiation.  <br /></td></tr>
<tr class="separator:ga4e9809a996e6671dcafb0a455b83e10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aa33c63d602fdb151d3e342284b2171"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#ga7aa33c63d602fdb151d3e342284b2171">mcuxClMath_ExactDivideOdd</a> (uint32_t iR_iX_iY_iT, uint32_t xPkcByteLength, uint32_t yPkcByteLength)</td></tr>
<tr class="memdesc:ga7aa33c63d602fdb151d3e342284b2171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates exact division with odd divisor.  <br /></td></tr>
<tr class="separator:ga7aa33c63d602fdb151d3e342284b2171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9416369d37627425ecac95580d1c3ee4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html#ga9416369d37627425ecac95580d1c3ee4">mcuxClMath_ExactDivide</a> (uint32_t iR_iX_iY_iT, uint32_t xPkcByteLength, uint32_t yPkcByteLength)</td></tr>
<tr class="memdesc:ga9416369d37627425ecac95580d1c3ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates exact division (supporting even divisor).  <br /></td></tr>
<tr class="separator:ga9416369d37627425ecac95580d1c3ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Defines all functions of <a class="el" href="a01120.html">mcuxClMath</a>. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaadd4485b0f1db32b6da6e6b7a2e6cc11" name="gaadd4485b0f1db32b6da6e6b7a2e6cc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadd4485b0f1db32b6da6e6b7a2e6cc11">&#9670;&#160;</a></span>MCUXCLMATH_SHIFTMODULUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_SHIFTMODULUS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iNShifted, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="a01121.html#ga65003277bfc2c6eb64be0f23261cadd7" title="Prepares shifted modulus.">mcuxClMath_ShiftModulus</a>. </p>

</div>
</div>
<a id="ga35df7cdad4c81c5e276f373c70c571d0" name="ga35df7cdad4c81c5e276f373c70c571d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35df7cdad4c81c5e276f373c70c571d0">&#9670;&#160;</a></span>MCUXCLMATH_FP_SHIFTMODULUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_SHIFTMODULUS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iNShifted, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="a01121.html#ga65003277bfc2c6eb64be0f23261cadd7" title="Prepares shifted modulus.">mcuxClMath_ShiftModulus</a> with flow protection. </p>

</div>
</div>
<a id="gab588855e23f750a4c9f7533b54a11325" name="gab588855e23f750a4c9f7533b54a11325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab588855e23f750a4c9f7533b54a11325">&#9670;&#160;</a></span>MCUXCLMATH_NDASH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_NDASH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="a01121.html#ga47ca58caa097e65c0925aa488f287a1e" title="Prepares modulus (calculates NDash) for PKC modular multiplication.">mcuxClMath_NDash</a>. </p>

</div>
</div>
<a id="gafa0d390f4eb5728edfd764936aeee313" name="gafa0d390f4eb5728edfd764936aeee313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa0d390f4eb5728edfd764936aeee313">&#9670;&#160;</a></span>MCUXCLMATH_FP_NDASH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_NDASH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="a01121.html#ga47ca58caa097e65c0925aa488f287a1e" title="Prepares modulus (calculates NDash) for PKC modular multiplication.">mcuxClMath_NDash</a> with flow protection. </p>

</div>
</div>
<a id="ga666d3347d6f96a09b791355e596de46d" name="ga666d3347d6f96a09b791355e596de46d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga666d3347d6f96a09b791355e596de46d">&#9670;&#160;</a></span>MCUXCLMATH_QDASH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_QDASH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iQDash, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iNShifted, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="a01121.html#ga61ef022af097c89154560df0f81b3caa" title="Calculates QDash = Q * Q&#39; mod n, where Q = 256^(operandSize) mod n, and Q&#39; = 256^length mod n.">mcuxClMath_QDash</a>. </p>

</div>
</div>
<a id="ga7703703d552c5446acdf38d82cd81971" name="ga7703703d552c5446acdf38d82cd81971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7703703d552c5446acdf38d82cd81971">&#9670;&#160;</a></span>MCUXCLMATH_FP_QDASH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_QDASH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iQDash, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iNShifted, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="a01121.html#ga61ef022af097c89154560df0f81b3caa" title="Calculates QDash = Q * Q&#39; mod n, where Q = 256^(operandSize) mod n, and Q&#39; = 256^length mod n.">mcuxClMath_QDash</a> with flow protection. </p>

</div>
</div>
<a id="ga4ee6d9b078ecc35a081a3a8cdbec0968" name="ga4ee6d9b078ecc35a081a3a8cdbec0968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ee6d9b078ecc35a081a3a8cdbec0968">&#9670;&#160;</a></span>MCUXCLMATH_QSQUARED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_QSQUARED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iQSqr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iNShifted, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="a01121.html#gae2ad68ea7641a23751583c27ed1d77a7" title="Calculates QSquared = Q^2 mod n, where Q = 256^(operandSize) mod n.">mcuxClMath_QSquared</a>. </p>

</div>
</div>
<a id="gadcd348426e9998703dc6f93194a62f80" name="gadcd348426e9998703dc6f93194a62f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcd348426e9998703dc6f93194a62f80">&#9670;&#160;</a></span>MCUXCLMATH_FP_QSQUARED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_QSQUARED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iQSqr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iNShifted, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="a01121.html#gae2ad68ea7641a23751583c27ed1d77a7" title="Calculates QSquared = Q^2 mod n, where Q = 256^(operandSize) mod n.">mcuxClMath_QSquared</a> with flow protection. </p>

</div>
</div>
<a id="gaa59866fd485a59868a2a594a5858f1de" name="gaa59866fd485a59868a2a594a5858f1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa59866fd485a59868a2a594a5858f1de">&#9670;&#160;</a></span>MCUXCLMATH_MODINV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_MODINV</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="a01121.html#ga9c01f0090ea0220a735ea6992515cf7a" title="Calculates modular inversion, with odd modulus.">mcuxClMath_ModInv</a>. </p>

</div>
</div>
<a id="gab456571414ef2f49a91b61f0c91009ba" name="gab456571414ef2f49a91b61f0c91009ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab456571414ef2f49a91b61f0c91009ba">&#9670;&#160;</a></span>MCUXCLMATH_FP_MODINV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_MODINV</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="a01121.html#ga9c01f0090ea0220a735ea6992515cf7a" title="Calculates modular inversion, with odd modulus.">mcuxClMath_ModInv</a> with flow protection. </p>

</div>
</div>
<a id="ga3ee39987ba7de0e36abc848d77b4eaa3" name="ga3ee39987ba7de0e36abc848d77b4eaa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ee39987ba7de0e36abc848d77b4eaa3">&#9670;&#160;</a></span>MCUXCLMATH_REDUCEMODEVEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_REDUCEMODEVEN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT0, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT3&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="a01121.html#gadcf87738f49ecf4c39ee725fa6cb88f9" title="Calculates modular reduction with even modulus.">mcuxClMath_ReduceModEven</a>. </p>

</div>
</div>
<a id="gaed2b24ff10b916eb07a842a2a05ad341" name="gaed2b24ff10b916eb07a842a2a05ad341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed2b24ff10b916eb07a842a2a05ad341">&#9670;&#160;</a></span>MCUXCLMATH_FP_REDUCEMODEVEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_REDUCEMODEVEN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT0, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT3&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="a01121.html#gadcf87738f49ecf4c39ee725fa6cb88f9" title="Calculates modular reduction with even modulus.">mcuxClMath_ReduceModEven</a> with flow protection. </p>

</div>
</div>
<a id="ga82842f4b45c0d86e4c2d6d29e23c259b" name="ga82842f4b45c0d86e4c2d6d29e23c259b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82842f4b45c0d86e4c2d6d29e23c259b">&#9670;&#160;</a></span>MCUXCLMATH_MODEXP_SQRMULTL2R</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_MODEXP_SQRMULTL2R</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pExp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">byteLenExp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="a01121.html#gabdd7a91f84faca1e208c143a25e318f8" title="Calculates modular exponentiation.">mcuxClMath_ModExp_SqrMultL2R</a>. </p>

</div>
</div>
<a id="ga9f0c8d67f0c192341fbf9ac436f02173" name="ga9f0c8d67f0c192341fbf9ac436f02173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f0c8d67f0c192341fbf9ac436f02173">&#9670;&#160;</a></span>MCUXCLMATH_FP_MODEXP_SQRMULTL2R</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_MODEXP_SQRMULTL2R</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pExp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">byteLenExp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="a01121.html#gabdd7a91f84faca1e208c143a25e318f8" title="Calculates modular exponentiation.">mcuxClMath_ModExp_SqrMultL2R</a> with flow protection. </p>

</div>
</div>
<a id="ga3e0168ff93f7bffd7d56ce509ba29c59" name="ga3e0168ff93f7bffd7d56ce509ba29c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e0168ff93f7bffd7d56ce509ba29c59">&#9670;&#160;</a></span>MCUXCLMATH_SECMODEXP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_SECMODEXP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">session, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pExp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pExpTemp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">byteLenExp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iTE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT0, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT3&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="a01121.html#ga4e9809a996e6671dcafb0a455b83e10a" title="Securely calculates modular exponentiation.">mcuxClMath_SecModExp</a>. </p>

</div>
</div>
<a id="gae807c4ed789f67aa150addbae31de180" name="gae807c4ed789f67aa150addbae31de180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae807c4ed789f67aa150addbae31de180">&#9670;&#160;</a></span>MCUXCLMATH_EXACTDIVIDEODD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_EXACTDIVIDEODD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xPkcByteLen, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">yPkcByteLen&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="a01121.html#ga7aa33c63d602fdb151d3e342284b2171" title="Calculates exact division with odd divisor.">mcuxClMath_ExactDivideOdd</a>. </p>

</div>
</div>
<a id="gaf1d62616daa224745d2ed40fdfa4d724" name="gaf1d62616daa224745d2ed40fdfa4d724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1d62616daa224745d2ed40fdfa4d724">&#9670;&#160;</a></span>MCUXCLMATH_FP_EXACTDIVIDEODD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_EXACTDIVIDEODD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xPkcByteLen, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">yPkcByteLen&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="a01121.html#ga7aa33c63d602fdb151d3e342284b2171" title="Calculates exact division with odd divisor.">mcuxClMath_ExactDivideOdd</a> with flow protection. </p>

</div>
</div>
<a id="gae99e5e55dda4387e4384e974a112a760" name="gae99e5e55dda4387e4384e974a112a760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae99e5e55dda4387e4384e974a112a760">&#9670;&#160;</a></span>MCUXCLMATH_EXACTDIVIDE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_EXACTDIVIDE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xPkcByteLen, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">yPkcByteLen&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="a01121.html#ga9416369d37627425ecac95580d1c3ee4" title="Calculates exact division (supporting even divisor).">mcuxClMath_ExactDivide</a>. </p>

</div>
</div>
<a id="ga4dd21ea08b92f104bd3d9bff5ce7efe7" name="ga4dd21ea08b92f104bd3d9bff5ce7efe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dd21ea08b92f104bd3d9bff5ce7efe7">&#9670;&#160;</a></span>MCUXCLMATH_FP_EXACTDIVIDE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MCUXCLMATH_FP_EXACTDIVIDE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iR, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iX, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iN, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iT, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xPkcByteLen, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">yPkcByteLen&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for <a class="el" href="a01121.html#ga9416369d37627425ecac95580d1c3ee4" title="Calculates exact division (supporting even divisor).">mcuxClMath_ExactDivide</a> with flow protection. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga716b9990024e2ea5e5984ca960a5e861" name="ga716b9990024e2ea5e5984ca960a5e861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga716b9990024e2ea5e5984ca960a5e861">&#9670;&#160;</a></span>mcuxClMath_InitLocalUptrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mcuxClMath_InitLocalUptrt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>i3_i2_i1_i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>i7_i6_i5_i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>localPtrUptrt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noOfIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t **&#160;</td>
          <td class="paramname"><em>oldPtrUptrt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes and uses the new UPTRT and returns the address of original UPTRT. </p>
<p>This function copies up to 8 offsets of PKC operands from current UPTRT to the new UPTRT, sets PKC to use the new UPTRT, and returns the address of original UPTRT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i3_i2_i1_i0</td><td>the first 4 indices of offsets to be copied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i7_i6_i5_i4</td><td>the second 4 indices of offsets to be copied </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">localPtrUptrt</td><td>address of the new UPTRT to be filled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noOfIndices</td><td>number of offsets to be copied from original UPTRT to new UPTRT </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">oldPtrUptrt</td><td>pointer to where receives the original UPTRT address</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>i3_i2_i1_i0</code>  </dt>
<dd><code>i0</code> (bits 0~7): originalUptrt[i0] will be copied to <code>localPtrUptrt</code>[0], if <code>noOfIndices</code> &gt;= 1. <br  />
<code>i1</code> (bits 8~15): originalUptrt[i1] will be copied to <code>localPtrUptrt</code>[1], if <code>noOfIndices</code> &gt;= 2. <br  />
<code>i2</code> (bits 16~23): originalUptrt[i2] will be copied to <code>localPtrUptrt</code>[2], if <code>noOfIndices</code> &gt;= 3. <br  />
<code>i3</code> (bits 24~31): originalUptrt[i3] will be copied to <code>localPtrUptrt</code>[3], if <code>noOfIndices</code> &gt;= 4. </dd>
<dt><code>i7_i6_i5_i4</code>  </dt>
<dd><code>i4</code> (bits 0~7): originalUptrt[i4] will be copied to <code>localPtrUptrt</code>[4], if <code>noOfIndices</code> &gt;= 5. <br  />
<code>i5</code> (bits 8~15): originalUptrt[i5] will be copied to <code>localPtrUptrt</code>[5], if <code>noOfIndices</code> &gt;= 6. <br  />
<code>i6</code> (bits 16~23): originalUptrt[i6] will be copied to <code>localPtrUptrt</code>[6], if <code>noOfIndices</code> &gt;= 7. <br  />
<code>i7</code> (bits 24~31): originalUptrt[i7] will be copied to <code>localPtrUptrt</code>[7], if <code>noOfIndices</code> &gt;= 8. </dd>
<dt><code>localPtrUptrt</code>  </dt>
<dd>This address shall be 2-byte aligned. <br  />
Caller shall allocate at least <code>noOfIndices</code> 2-byte entries in this table. </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>UPTRT </dt>
<dd>This function will retrieve the original UPTRT address and return it to caller via <code>oldPtrUptrt</code>. <br  />
This function will overwrite this address by <code>localPtrUptrt</code>. </dd>
<dt>PS1 lengths </dt>
<dd>Unused. </dd>
<dt>PS2 lengths </dt>
<dd>Unused. </dd>
<dt>ACTIV/GOANY </dt>
<dd>This function shall not be called during a running FUP program (i.e., GOANY bit is set). Caller shall call <a class="el" href="a01309.html#ga963b13a65f2ae869947cbbebf2f9a823" title="Wait until PKC is ready to accept new calculation.">mcuxClPkc_WaitForReady</a> before calling this function, if a FUP program has been called. </dd>
</dl>
</dd>
</dl>

</div>
</div>
<a id="ga3418e7e61a5622de864d5cd72407cf32" name="ga3418e7e61a5622de864d5cd72407cf32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3418e7e61a5622de864d5cd72407cf32">&#9670;&#160;</a></span>mcuxClMath_LeadingZeros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mcuxClMath_LeadingZeros </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>iX</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts number of leading zero bits of a PKC operand. </p>
<p>This function counts the number of leading zero bits of a PKC operand at offset UPTRT[iX] and of size PS1 OPLEN.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iX</td><td>index of PKC operand </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pNumLeadingZeros</td><td>pointer to where the number of leading zero bits will be stored</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>iX</code>  </dt>
<dd>index of X (PKC operand), size = operandSize. <br  />
The offset (UPTRT[iX]) shall be exactly a multiple of MCUXCLPKC_WORDSIZE. </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>PS1 lengths </dt>
<dd>PS1 OPLEN defines operandSize and shall be exactly a multiple of MCUXCLPKC_WORDSIZE. </dd>
<dt>PS2 lengths </dt>
<dd>Unused. </dd>
<dt>ACTIV/GOANY </dt>
<dd>This function will not use PKC, and assumes PKC will not modify the operand iX simultaneously. </dd>
</dl>
</dd>
</dl>

</div>
</div>
<a id="ga0203db0be2a5c09157c0db697cc2685f" name="ga0203db0be2a5c09157c0db697cc2685f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0203db0be2a5c09157c0db697cc2685f">&#9670;&#160;</a></span>mcuxClMath_TrailingZeros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mcuxClMath_TrailingZeros </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>iX</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts number of trailing zero bits of a PKC operand. </p>
<p>This function counts the number of trailing zero bits of a PKC operand at offset UPTRT[iX] and of size PS1 OPLEN.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iX</td><td>index of PKC operand</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>iX</code>  </dt>
<dd>index of X (PKC operand), size = operandSize. <br  />
The offset (UPTRT[iX]) shall be exactly a multiple of MCUXCLPKC_WORDSIZE. </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>PS1 lengths </dt>
<dd>PS1 OPLEN defines operandSize and shall be exactly a multiple of MCUXCLPKC_WORDSIZE. </dd>
<dt>PS2 lengths </dt>
<dd>Unused. </dd>
<dt>ACTIV/GOANY </dt>
<dd>This function will not use PKC, and assumes PKC will not modify the operand iX simultaneously. </dd>
</dl>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A code-flow protected error code (see <a class="el" href="a01200.html">Flow Protection API</a>) </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">#numTrailingZeroes</td><td>Number of trailing zeroes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga65003277bfc2c6eb64be0f23261cadd7" name="ga65003277bfc2c6eb64be0f23261cadd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65003277bfc2c6eb64be0f23261cadd7">&#9670;&#160;</a></span>mcuxClMath_ShiftModulus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mcuxClMath_ShiftModulus </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>iNShifted_iN</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares shifted modulus. </p>
<p>This function left shifts modulus (PKC operand iN) until there is no leading zero and stores the result in PKC operand iNShifted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iNShifted_iN</td><td>indices of PKC operands</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>iNShifted_iN</code>  </dt>
<dd><code>iN</code> (bits 0~7): index of modulus (PKC operand), size = operandSize. <br  />
The modulus shall be non-zero. <br  />
The offset (UPTRT[iN]) shall be exactly a multiple of MCUXCLPKC_WORDSIZE. <br  />
<code>iNShifted</code> (bits 8~15): index of shifted modulus (PKC operand), size = operandSize. <br  />
This function supports in-place operation, i.e., iNShifted = iN. </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>PS1 lengths </dt>
<dd>PS1 OPLEN defines operandSize and shall be exactly a multiple of MCUXCLPKC_WORDSIZE. </dd>
<dt>PS2 lengths </dt>
<dd>PS2 OPLEN and MCLEN will be modified, and original values will not be restored. </dd>
<dt>ACTIV/GOANY </dt>
<dd>The PKC calculation might be still on-going, call <a class="el" href="a01309.html#ga7d26efcc91094390f7c55fbd870692cd" title="Wait until PKC finishes calculations.">mcuxClPkc_WaitForFinish</a> before CPU accesses to the result. </dd>
</dl>
</dd>
</dl>

</div>
</div>
<a id="ga47ca58caa097e65c0925aa488f287a1e" name="ga47ca58caa097e65c0925aa488f287a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47ca58caa097e65c0925aa488f287a1e">&#9670;&#160;</a></span>mcuxClMath_NDash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mcuxClMath_NDash </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>iN_iT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares modulus (calculates NDash) for PKC modular multiplication. </p>
<p>This function calculates NDash = (-modulus)^(-1) mod 256^(MCUXCLPKC_WORDSIZE) and stores NDash in the PKC word in front of the PKC operand of modulus (iN).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iN_iT</td><td>indices of PKC operands</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>iN_iT</code>  </dt>
<dd><code>iT</code> (bits 0~7): index of temp (PKC operand). <br  />
The size of temp shall be at least (2 * MCUXCLPKC_WORDSIZE). <br  />
<code>iN</code> (bits 8~15): index of modulus (PKC operand). <br  />
The modulus shall be an odd number. <br  />
The result NDash will be stored in the PKC word before modulus, i.e., at the offset, (UPTRT[iN] - MCUXCLPKC_WORDSIZE). </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>PS1 lengths </dt>
<dd>Unused. </dd>
<dt>PS2 lengths </dt>
<dd>PS2 OPLEN and MCLEN will be modified, and original values will not be restored. </dd>
<dt>ACTIV/GOANY </dt>
<dd><a class="el" href="a01309.html#ga963b13a65f2ae869947cbbebf2f9a823" title="Wait until PKC is ready to accept new calculation.">mcuxClPkc_WaitForReady</a> will be called before returning to caller. <br  />
The PKC calculation might be still on-going, call <a class="el" href="a01309.html#ga7d26efcc91094390f7c55fbd870692cd" title="Wait until PKC finishes calculations.">mcuxClPkc_WaitForFinish</a> before CPU accesses to the result. </dd>
</dl>
</dd>
</dl>

</div>
</div>
<a id="ga61ef022af097c89154560df0f81b3caa" name="ga61ef022af097c89154560df0f81b3caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61ef022af097c89154560df0f81b3caa">&#9670;&#160;</a></span>mcuxClMath_QDash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mcuxClMath_QDash </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iQDash_iNShifted_iN_iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates QDash = Q * Q' mod n, where Q = 256^(operandSize) mod n, and Q' = 256^length mod n. </p>
<p>This function computes QDash which can be used to convert a PKC operand (of the size <code>length</code>) to its Montgomery representation (of the size operandSize).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iQDash_iNShifted_iN_iT</td><td>indices of PKC operands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>specify Q' = 256^length mod n</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>iQDash_iNShifted_iN_iT</code>  </dt>
<dd><code>iT</code> (bits 0~7): index of temp (PKC operand). <br  />
The size of temp shall be at least (operandSize + MCUXCLPKC_WORDSIZE). <br  />
<code>iN</code> (bits 8~15): index of modulus (PKC operand), size = operandSize. <br  />
NDash of modulus shall be stored in the PKC word before modulus. <br  />
<code>iNShifted</code> (bits 16~23): index of shifted modulus (PKC operand), size = operandSize. <br  />
If there is no leading zero in the PKC operand modulus, it can be iN. <br  />
<code>iQDash</code> (bits 24~31): index of result QDash (PKC operand), size = operandSize. <br  />
QDash might be greater than modulus. </dd>
<dt><code>length</code>  </dt>
<dd>It shall be nonzero. A zero length will cause undefined behavior. </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>PS1 lengths </dt>
<dd>PS1 OPLEN = MCLEN defines operandSize. </dd>
<dt>PS2 lengths </dt>
<dd>Unused. </dd>
<dt>ACTIV/GOANY </dt>
<dd><a class="el" href="a01309.html#ga963b13a65f2ae869947cbbebf2f9a823" title="Wait until PKC is ready to accept new calculation.">mcuxClPkc_WaitForReady</a> will be called before returning to caller. <br  />
The PKC calculation might be still on-going, call <a class="el" href="a01309.html#ga7d26efcc91094390f7c55fbd870692cd" title="Wait until PKC finishes calculations.">mcuxClPkc_WaitForFinish</a> before CPU accesses to the result. </dd>
</dl>
</dd>
</dl>

</div>
</div>
<a id="gae2ad68ea7641a23751583c27ed1d77a7" name="gae2ad68ea7641a23751583c27ed1d77a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2ad68ea7641a23751583c27ed1d77a7">&#9670;&#160;</a></span>mcuxClMath_QSquared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mcuxClMath_QSquared </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iQSqr_iNShifted_iN_iT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates QSquared = Q^2 mod n, where Q = 256^(operandSize) mod n. </p>
<p>This function computes QSquared which can be used to convert a PKC operand to its Montgomery representation (both are of the size operandSize).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iQSqr_iNShifted_iN_iT</td><td>indices of PKC operands</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>iQSqr_iNShifted_iN_iT</code>  </dt>
<dd><code>iT</code> (bits 0~7): index of temp (PKC operand). <br  />
The size of temp shall be at least (operandSize + MCUXCLPKC_WORDSIZE). <br  />
<code>iN</code> (bits 8~15): index of modulus (PKC operand), size = operandSize. <br  />
NDash of modulus shall be stored in the PKC word before modulus. <br  />
<code>iNShifted</code> (bits 16~23): index of shifted modulus (PKC operand), size = operandSize. <br  />
If there is no leading zero in the PKC operand modulus, it can be iN. <br  />
<code>iQSqr</code> (bits 24~31): index of result QSquared (PKC operand), size = operandSize. <br  />
QSquared might be greater than modulus. </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>PS1 lengths </dt>
<dd>PS1 OPLEN = MCLEN defines operandSize and shall be exactly a multiple of MCUXCLPKC_WORDSIZE. </dd>
<dt>PS2 lengths </dt>
<dd>Unused. </dd>
<dt>ACTIV/GOANY </dt>
<dd><a class="el" href="a01309.html#ga963b13a65f2ae869947cbbebf2f9a823" title="Wait until PKC is ready to accept new calculation.">mcuxClPkc_WaitForReady</a> will be called before returning to caller. <br  />
The PKC calculation might be still on-going, call <a class="el" href="a01309.html#ga7d26efcc91094390f7c55fbd870692cd" title="Wait until PKC finishes calculations.">mcuxClPkc_WaitForFinish</a> before CPU accesses to the result. </dd>
</dl>
</dd>
</dl>

</div>
</div>
<a id="ga9c01f0090ea0220a735ea6992515cf7a" name="ga9c01f0090ea0220a735ea6992515cf7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c01f0090ea0220a735ea6992515cf7a">&#9670;&#160;</a></span>mcuxClMath_ModInv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mcuxClMath_ModInv </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iR_iX_iN_iT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates modular inversion, with odd modulus. </p>
<p>This function calculates modular inversion, result = X^(-1) mod n.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iR_iX_iN_iT</td><td>indices of PKC operands</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>iR_iX_iN_iT</code>  </dt>
<dd><code>iT</code> (bits 0~7): index of temp (PKC operand). <br  />
Its size shall be at least (operandSize + MCUXCLPKC_WORDSIZE). <br  />
The offset (UPTRT[iT]) shall be exactly a multiple of MCUXCLPKC_WORDSIZE. <br  />
<code>iN</code> (bits 8~15): index of modulus (PKC operand), size = operandSize. <br  />
NDash of modulus shall be stored in the PKC word before modulus. <br  />
<code>iX</code> (bits 16~23): index of X (PKC operand), size = operandSize. <br  />
X will be destroyed by this function. <br  />
X and the modulus shall be coprime, otherwise the result will be incorrect. <br  />
<code>iR</code> (bits 24~31): index of result (PKC operand). <br  />
Its size shall be at least (operandSize + MCUXCLPKC_WORDSIZE). <br  />
The offset (UPTRT[iR]) shall be exactly a multiple of MCUXCLPKC_WORDSIZE. <br  />
The result fits in operandSize, but might be greater than modulus. </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>PS1 lengths </dt>
<dd>PS1 OPLEN = MCLEN defines operandSize. </dd>
<dt>PS2 lengths </dt>
<dd>PS2 OPLEN and MCLEN will be modified, and original values will not be restored. </dd>
<dt>ACTIV/GOANY </dt>
<dd><a class="el" href="a01309.html#ga963b13a65f2ae869947cbbebf2f9a823" title="Wait until PKC is ready to accept new calculation.">mcuxClPkc_WaitForReady</a> will be called before returning to caller. <br  />
The PKC calculation might be still on-going, call <a class="el" href="a01309.html#ga7d26efcc91094390f7c55fbd870692cd" title="Wait until PKC finishes calculations.">mcuxClPkc_WaitForFinish</a> before CPU accesses to the result. </dd>
</dl>
</dd>
</dl>

</div>
</div>
<a id="gadcf87738f49ecf4c39ee725fa6cb88f9" name="gadcf87738f49ecf4c39ee725fa6cb88f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcf87738f49ecf4c39ee725fa6cb88f9">&#9670;&#160;</a></span>mcuxClMath_ReduceModEven()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mcuxClMath_ReduceModEven </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iR_iX_iN_iT0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iT1_iT2_iT3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates modular reduction with even modulus. </p>
<p>This function calculates modular reduction result = X mod n, where the modulus n is even.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iR_iX_iN_iT0</td><td>indices of PKC operands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iT1_iT2_iT3</td><td>indices of PKC operands</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>iR_iX_iN_iT0</code>  </dt>
<dd><code>iT0</code> (bits 0~7): index of temp0 (PKC operand). <br  />
Its size shall be at least (lenN + MCUXCLPKC_WORDSIZE). <br  />
The operand of modulus can be used as temp0 (i.e., iT0 = iN), but the modulus will be destroyed. <br  />
<code>iN</code> (bits 8~15): index of modulus (PKC operand), size = lenN. <br  />
The offset (UPTRT[iN]) shall be exactly a multiple of MCUXCLPKC_WORDSIZE. <br  />
<code>iX</code> (bits 16~23): index of X (PKC operand). <br  />
Its size shall be at least (lenX + MCUXCLPKC_WORDSIZE). <br  />
<code>iR</code> (bits 24~31): index of result (PKC operand). <br  />
Its size shall be at least (lenN + MCUXCLPKC_WORDSIZE). </dd>
<dt><code>iT1_iT2_iT3</code>  </dt>
<dd><code>iT3</code> (bits 0~7): index of temp3 (PKC operand). <br  />
Its size shall be at least (lenN + MCUXCLPKC_WORDSIZE). <br  />
<code>iT2</code> (bits 8~15): index of temp2 (PKC operand). <br  />
Its size shall be at least lenN. <br  />
<code>iT1</code> (bits 16~23): index of temp1 (PKC operand). <br  />
Its size shall be at least lenN. <br  />
The operand of result can be used as temp1 (i.e., iT1 = iR). TODO: always use R (any reason not using R?) </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>PS1 lengths </dt>
<dd>PS1 OPLEN defines lenN (length of modulus n), and MCLEN defines lenX (length of X). <br  />
lenX (PS1 MCLEN) &gt;= lenN (PS1 OPLEN). <br  />
Both OPLEN and MCLEN shall be exactly a multiple of MCUXCLPKC_WORDSIZE. </dd>
<dt>PS2 lengths </dt>
<dd>PS2 OPLEN and MCLEN will be modified, and original values will not be restored. </dd>
<dt>ACTIV/GOANY </dt>
<dd><a class="el" href="a01309.html#ga963b13a65f2ae869947cbbebf2f9a823" title="Wait until PKC is ready to accept new calculation.">mcuxClPkc_WaitForReady</a> will be called before returning to caller. <br  />
The PKC calculation might be still on-going, call <a class="el" href="a01309.html#ga7d26efcc91094390f7c55fbd870692cd" title="Wait until PKC finishes calculations.">mcuxClPkc_WaitForFinish</a> before CPU accesses to the result. </dd>
</dl>
</dd>
</dl>

</div>
</div>
<a id="gabdd7a91f84faca1e208c143a25e318f8" name="gabdd7a91f84faca1e208c143a25e318f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdd7a91f84faca1e208c143a25e318f8">&#9670;&#160;</a></span>mcuxClMath_ModExp_SqrMultL2R()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mcuxClMath_ModExp_SqrMultL2R </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pExp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>expByteLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iR_iX_iN_iT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates modular exponentiation. </p>
<p>This function calculates modular exponentiation with left-to-right binary square-and-multiply algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pExp</td><td>pointer to exponent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expByteLength</td><td>byte length of exponent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iR_iX_iN_iT</td><td>indices of PKC operands</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>pExp</code>  </dt>
<dd>the exponent is a big-endian octet string and shall be non-zero. </dd>
<dt><code>iR_iX_iN_iT</code>  </dt>
<dd><code>iT</code> (bits 0~7): index of temp operand (PKC operand). <br  />
Its size shall be at least (lenN + MCUXCLPKC_WORDSIZE). <br  />
<code>iN</code> (bits 8~15): index of modulus (PKC operand), size = operandSize. <br  />
NDash of modulus shall be stored in the PKC word before modulus. <br  />
<code>iX</code> (bits 16~23): index of base number (PKC operand), size = operandSize. <code>iR</code> (bits 24~31): index of result (PKC operand). <br  />
Its size shall be at least (lenN + MCUXCLPKC_WORDSIZE). </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>PS1 lengths </dt>
<dd>PS1 OPLEN = MCLEN defines operandSize. </dd>
<dt>PS2 lengths </dt>
<dd>Unused. </dd>
<dt>ACTIV/GOANY </dt>
<dd>The PKC calculation might be still on-going, call <a class="el" href="a01309.html#ga7d26efcc91094390f7c55fbd870692cd" title="Wait until PKC finishes calculations.">mcuxClPkc_WaitForFinish</a> before CPU accesses to the result. </dd>
</dl>
</dd>
</dl>

</div>
</div>
<a id="ga4e9809a996e6671dcafb0a455b83e10a" name="ga4e9809a996e6671dcafb0a455b83e10a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e9809a996e6671dcafb0a455b83e10a">&#9670;&#160;</a></span>mcuxClMath_SecModExp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01122.html#gaf541274a57cf9f823c029f73ff733ae0">mcuxClMath_Status_t</a> mcuxClMath_SecModExp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01188.html#ga17fd337618b05459b4a343393e099b56">mcuxClSession_Handle_t</a>&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pExp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pExpTemp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>expByteLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iT3_iX_iT2_iT1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iN_iTE_iT0_iR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Securely calculates modular exponentiation. </p>
<p>This function calculates modular exponentiation in a secure manner. It randomizes the computation by Euclidean splitting: exponent = b * q + r, where b is a 64-bit odd random number (with both MSbit and LSbit set), and r = exponent % b. The exponentiation is calculated by two steps: (1) m0 = m^q mod n; and (2) result = m0^b * m^r mod n. In addition, base operands are re-randomized, by adding random multiples of the modulus to them before performing modular multiplications.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSession</td><td>handle for the current CL session. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pExp</td><td>pointer to exponent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pExpTemp</td><td>pointer to temporary buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expByteLength</td><td>byte length of exponent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iT3_iX_iT2_iT1</td><td>indices of PKC operands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iN_iTE_iT0_iR</td><td>indices of PKC operands</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>session:</code>  </dt>
<dd>The session pointed to by pSession has to be initialized prior to a call to this function. </dd>
<dt><code>pExp</code>  </dt>
<dd>the exponent is a big-endian octet string and shall be non-zero. </dd>
<dt><code>pExpTemp</code>  </dt>
<dd>the temporary buffer can be in either CPU or PKC workarea. <br  />
It shall be CPU word aligned, and its length shall be a multiple of CPU word and greater than <code>expByteLength</code>. <br  />
It can share the space with exponent (i.e., pExpTemp = pExp), but the exponent will be overwritten. </dd>
<dt><code>iT3_iX_iT2_iT1</code>  </dt>
<dd><code>iT1</code> (bits 0~7): index of temp1 (PKC operand). <br  />
Its size shall be at least max(MCUXCLPKC_ALIGN_TO_PKC_WORDSIZE(<code>expByteLength</code> + 1), lenN + MCUXCLPKC_WORDSIZE, 2 * MCUXCLPKC_WORDSIZE). <br  />
<code>iT2</code> (bits 8~15): index of temp2 (PKC operand). <br  />
Its size shall be at least max(lenN + MCUXCLPKC_WORDSIZE, 2 * MCUXCLPKC_WORDSIZE). <br  />
<code>iX</code> (bits 16~23): index of base number (PKC operand), size = operandSize + MCUXCLPKC_WORDSIZE (= lenN + MCUXCLPKC_WORDSIZE). <br  />
It will be overwritten. <br  />
<code>iT3</code> (bits 24~31): index of temp3 (PKC operand). <br  />
Its size shall be at least max(lenN + MCUXCLPKC_WORDSIZE, 2 * MCUXCLPKC_WORDSIZE). </dd>
<dt><code>iN_iTE_iT0_iR</code>  </dt>
<dd><code>iR</code> (bits 0~7): index of result (PKC operand). <br  />
The size shall be at least max(MCUXCLPKC_ALIGN_TO_PKC_WORDSIZE(<code>expByteLength</code> + 1), lenN + MCUXCLPKC_WORDSIZE). <br  />
<code>iT0</code> (bits 8~15): index of temp0 (PKC operand). <br  />
The size shall be at least max(MCUXCLPKC_ALIGN_TO_PKC_WORDSIZE(<code>expByteLength</code> + 1), lenN + MCUXCLPKC_WORDSIZE). <br  />
<code>iTE</code> (bits 16~23): index of temp4 (PKC operand). <br  />
The size shall be at least (6 * MCUXCLPKC_WORDSIZE). <br  />
<code>iN</code> (bits 24~31): index of modulus (PKC operand), size = operandSize (= lenN). <br  />
The upper 32 bits of N shall be null, which can be obtained for instance by applying 32-bit modulus blinding, or by artificially increasing PS1 lengths and all buffer sizes by 1 PKC word. <br  />
NDash of modulus shall be stored in the PKC word before modulus. </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>PS1 lengths </dt>
<dd>PS1 OPLEN = MCLEN defines operandSize = <a class="el" href="a01311.html#ga8c42266e3f46f637fd8d28d34b1ffdc3" title="Round-up a length to a multiple of PKC wordsize.">MCUXCLPKC_ALIGN_TO_PKC_WORDSIZE(lenN)</a>, where lenN is the length of modulus n. As the upper 32 bits of N should be null, operandSize &gt;= lenN + 4 bytes. </dd>
<dt>PS2 lengths </dt>
<dd>PS2 OPLEN and MCLEN will be modified, and original values will not be restored. </dd>
<dt>ACTIV/GOANY </dt>
<dd><a class="el" href="a01309.html#ga963b13a65f2ae869947cbbebf2f9a823" title="Wait until PKC is ready to accept new calculation.">mcuxClPkc_WaitForReady</a> will be called before returning to caller. The PKC calculation might be still on-going, call <a class="el" href="a01309.html#ga7d26efcc91094390f7c55fbd870692cd" title="Wait until PKC finishes calculations.">mcuxClPkc_WaitForFinish</a> before CPU accesses to the result. </dd>
</dl>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A code-flow protected error code (see <a class="el" href="a01200.html">Flow Protection API</a>) </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a01122.html#ga745dd2a8966d1760f3475089b2f7aa47" title="Math operation successful.">MCUXCLMATH_STATUS_OK</a></td><td>function executed successfully </td></tr>
    <tr><td class="paramname"><a class="el" href="a01122.html#ga6e43ca61303440dc7e9a83fbe9cce4d3" title="Error occurred during Math operation.">MCUXCLMATH_STATUS_ERROR</a></td><td>error occurred during operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>This function uses PRNG which has to be initialized prior to calling the function. </dd></dl>

</div>
</div>
<a id="ga7aa33c63d602fdb151d3e342284b2171" name="ga7aa33c63d602fdb151d3e342284b2171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7aa33c63d602fdb151d3e342284b2171">&#9670;&#160;</a></span>mcuxClMath_ExactDivideOdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mcuxClMath_ExactDivideOdd </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iR_iX_iY_iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xPkcByteLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>yPkcByteLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates exact division with odd divisor. </p>
<p>This function calculates exact division R = X/Y, where divisor Y is odd and dividend X shall be exactly a multiple of Y. If X is not a multiple of Y, result will be incorrect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iR_iX_iY_iT</td><td>indices of PKC operands </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xPkcByteLength</td><td>length of X </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yPkcByteLength</td><td>length of Y</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>iR_iX_iY_iT</code>  </dt>
<dd><code>iT</code> (bits 0~7): index of temp (PKC operand). <br  />
Its size shall be at least (3 * MCUXCLPKC_WORDSIZE). <br  />
The offset (UPTRT[iT]) shall be exactly a multiple of MCUXCLPKC_WORDSIZE. <br  />
<code>iY</code> (bits 8~15): index of divisor Y (PKC operand), size = yPkcByteLength. <br  />
The most significant PKC word of Y shall be nonzero. <br  />
<code>iX</code> (bits 16~23): index of dividend X (PKC operand), size = xPkcByteLength. <br  />
X will be destroyed by this function. <br  />
CAUTION: if xPkcByteLength = MCUXCLPKC_WORDSIZE, this function will access to (read) one extra PKC word of X, i.e., X[MCUXCLPKC_WORDSIZE ~ 2*MCUXCLPKC_WORDSIZE - 1]. The value of this PKC word will not affect correctness of the result, but caller shall ensure that this PKC word is accessible by PKC. <br  />
<code>iR</code> (bits 24~31): index of result R (PKC operand), size = (xPkcByteLength - yPkcByteLength + MCUXCLPKC_WORDSIZE). </dd>
<dt><code>xPkcByteLength</code>  </dt>
<dd>It shall be a multiple of MCUXCLPKC_WORDSIZE, and &gt;= <code>yPkcByteLength</code>. </dd>
<dt><code>yPkcByteLength</code>  </dt>
<dd>It shall be a multiple of MCUXCLPKC_WORDSIZE. </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>PS1 lengths </dt>
<dd>Unused (modified and restored in the function). </dd>
<dt>PS2 lengths </dt>
<dd>PS2 OPLEN and MCLEN will be modified, and original values will not be restored. </dd>
<dt>ACTIV/GOANY </dt>
<dd><a class="el" href="a01309.html#ga963b13a65f2ae869947cbbebf2f9a823" title="Wait until PKC is ready to accept new calculation.">mcuxClPkc_WaitForReady</a> will be called before returning to caller. <br  />
The PKC calculation might be still on-going, call <a class="el" href="a01309.html#ga7d26efcc91094390f7c55fbd870692cd" title="Wait until PKC finishes calculations.">mcuxClPkc_WaitForFinish</a> before CPU accesses to the result. </dd>
</dl>
</dd>
</dl>

</div>
</div>
<a id="ga9416369d37627425ecac95580d1c3ee4" name="ga9416369d37627425ecac95580d1c3ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9416369d37627425ecac95580d1c3ee4">&#9670;&#160;</a></span>mcuxClMath_ExactDivide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mcuxClMath_ExactDivide </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iR_iX_iY_iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xPkcByteLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>yPkcByteLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates exact division (supporting even divisor). </p>
<p>This function calculates exact division R = X/Y, where dividend X shall be exactly a multiple of divisor Y. If X is not a multiple of Y, result will be incorrect.</p>
<p>This function trims trailing zero bits of Y and gets Y' = Y &gt;&gt; trailingZeros(Y), and X' = X &gt;&gt; ((trailingZeros(Y) / 8*MCUXCLPKC_WORDSIZE) * 8*MCUXCLPKC_WORDSIZE). It relies on mcuxClMath_ExactDivideOdd to calculate R' = X'/Y', and then calculates R = R' &gt;&gt; (trailingZeros(Y) % (8*MCUXCLPKC_WORDSIZE)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iR_iX_iY_iT</td><td>Pointer table indices of parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xPkcByteLength</td><td>length of X </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yPkcByteLength</td><td>length of Y</td></tr>
  </table>
  </dd>
</dl>
<dl>
<dt>Parameter properties </dt>
<dd><dl>
<dt><code>iR_iX_iY_iT</code>  </dt>
<dd><code>iT</code> (bits 0~7): index of temp (PKC operand). <br  />
Its size shall be at least (3 * MCUXCLPKC_WORDSIZE). <br  />
<code>iY</code> (bits 8~15): index of divisor Y (PKC operand), size = yPkcByteLength. <br  />
The most significant PKC word of Y shall be nonzero. <br  />
The offset (UPTRT[iY]) shall be exactly a multiple of MCUXCLPKC_WORDSIZE. <br  />
<code>iX</code> (bits 16~23): index of dividend X (PKC operand), size = xPkcByteLength. <br  />
X will be destroyed by this function. <br  />
CAUTION: if the length of trimmed X' is MCUXCLPKC_WORDSIZE, this function will access to (read) one extra PKC word of X, i.e., X[xPkcByteLength ~ xPkcByteLength + MCUXCLPKC_WORDSIZE - 1]. The value of this PKC word will not affect correctness of the result, but caller shall ensure that this PKC word is accessible by PKC. If caller cannot guarantee the length of trimmed X' greater than MCUXCLPKC_WORDSIZE, X shall be stored in buffer of the size, xPkcByteLength + MCUXCLPKC_WORDSIZE. <br  />
<code>iR</code> (bits 24~31): index of result R (PKC operand). Its buffer size shall be at least (xPkcByteLength - yPkcByteLength + 2*MCUXCLPKC_WORDSIZE). The result fits in size = (xPkcByteLength - yPkcByteLength + MCUXCLPKC_WORDSIZE). </dd>
<dt><code>xPkcByteLength</code>  </dt>
<dd>It shall be a multiple of MCUXCLPKC_WORDSIZE. </dd>
<dt><code>yPkcByteLength</code>  </dt>
<dd>It shall be a multiple of MCUXCLPKC_WORDSIZE. </dd>
</dl>
</dd>
</dl>
<dl>
<dt>PKC properties </dt>
<dd><dl>
<dt>PS1 lengths </dt>
<dd>Unused (modified and restored in the function). </dd>
<dt>PS2 lengths </dt>
<dd>PS2 OPLEN and MCLEN will be modified, and original values will not be restored. </dd>
<dt>ACTIV/GOANY </dt>
<dd><a class="el" href="a01309.html#ga963b13a65f2ae869947cbbebf2f9a823" title="Wait until PKC is ready to accept new calculation.">mcuxClPkc_WaitForReady</a> will be called before returning to caller. <br  />
The PKC calculation might be still on-going, call <a class="el" href="a01309.html#ga7d26efcc91094390f7c55fbd870692cd" title="Wait until PKC finishes calculations.">mcuxClPkc_WaitForFinish</a> before CPU accesses to the result. </dd>
</dl>
</dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
