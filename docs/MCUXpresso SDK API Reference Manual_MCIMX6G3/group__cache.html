<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>MCUXpresso SDK API Reference Manual: CACHE: CACHE Memory Controller</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="fs_logo.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">MCUXpresso SDK API Reference Manual
   &#160;<span id="projectnumber">Rev. 0</span>
   </div>
   <div id="projectbrief">NXP Semiconductors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__cache.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">CACHE: CACHE Memory Controller</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<p>The MCUXpresso SDK provides Peripheral driver for the CACHE Controller.</p>
<p>CACHE driver is created to help user to operate the Cache memory more easy. The APIs for basic operations are including the following two levels: 1L. The L1 cache driver API. The L1 cache driver API here is a defined as core integrated caches controller driver for all core-A intergreated caches: a. L1 maintain only if L2 is not supported b. L1 and L2 cache maintain together.</p>
<p>2L. The combined cache driver API. This level provides unified APIs for combined cache maintain operations. This is provided for MCUXpresso SDK drivers (DMA, ENET, USDHC etc) which should do the cache maintenance in their transactional APIs. In this architecture, there is only core intergrated cache, so the unified APIs here is directly call the L1 cache driver API.</p>
<h1><a class="anchor" id="CACHEFuncGrps"></a>
Function groups</h1>
<h2>L1 CACHE Operation {#L1CACHE MaintainOperation}</h2>
<p>The L1 CACHE has both code cache and data cache. This function group provides independent two groups API for both code cache and data cache. There are Enable/Disable APIs for code cache and data cache control and cache maintenance operations as Invalidate/Clean/CleanInvalidate by all and by address range. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Driver version</h2></td></tr>
<tr class="memitem:gac954b8be2bb59a983a9594c59e4b4fa5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cache.html#gac954b8be2bb59a983a9594c59e4b4fa5">FSL_CACHE_DRIVER_VERSION</a>&#160;&#160;&#160;(MAKE_VERSION(2, 0, 0))</td></tr>
<tr class="memdesc:gac954b8be2bb59a983a9594c59e4b4fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">cache driver version 2.0.0.  <a href="#gac954b8be2bb59a983a9594c59e4b4fa5">More...</a><br/></td></tr>
<tr class="separator:gac954b8be2bb59a983a9594c59e4b4fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Cache Control for Cortex-a L1 cache</h2></td></tr>
<tr class="memitem:gaea07bb3879fa96b03f1ecaa6bf821c74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaea07bb3879fa96b03f1ecaa6bf821c74"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cache.html#gaea07bb3879fa96b03f1ecaa6bf821c74">L1CACHE_EnableICache</a> (void)</td></tr>
<tr class="memdesc:gaea07bb3879fa96b03f1ecaa6bf821c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables L1 instruction cache. <br/></td></tr>
<tr class="separator:gaea07bb3879fa96b03f1ecaa6bf821c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa6d1a14a0499342890eee0e104c8d96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafa6d1a14a0499342890eee0e104c8d96"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cache.html#gafa6d1a14a0499342890eee0e104c8d96">L1CACHE_DisableICache</a> (void)</td></tr>
<tr class="memdesc:gafa6d1a14a0499342890eee0e104c8d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables L1 instruction cache. <br/></td></tr>
<tr class="separator:gafa6d1a14a0499342890eee0e104c8d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabce0ccbe1684fef7eff231f3704025b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabce0ccbe1684fef7eff231f3704025b6"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cache.html#gabce0ccbe1684fef7eff231f3704025b6">L1CACHE_InvalidateICache</a> (void)</td></tr>
<tr class="memdesc:gabce0ccbe1684fef7eff231f3704025b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates L1 instruction cache all. <br/></td></tr>
<tr class="separator:gabce0ccbe1684fef7eff231f3704025b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62a60ab1f97162593c8b1d66b90db5de"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cache.html#ga62a60ab1f97162593c8b1d66b90db5de">L1CACHE_InvalidateICacheByRange</a> (uint32_t startAddr, uint32_t size_byte)</td></tr>
<tr class="memdesc:ga62a60ab1f97162593c8b1d66b90db5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates L1 instruction cache by range.  <a href="#ga62a60ab1f97162593c8b1d66b90db5de">More...</a><br/></td></tr>
<tr class="separator:ga62a60ab1f97162593c8b1d66b90db5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52d071c691c4ce9ead828e086f07f457"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga52d071c691c4ce9ead828e086f07f457"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cache.html#ga52d071c691c4ce9ead828e086f07f457">L1CACHE_EnableDCache</a> (void)</td></tr>
<tr class="memdesc:ga52d071c691c4ce9ead828e086f07f457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables L1 data cache. <br/></td></tr>
<tr class="separator:ga52d071c691c4ce9ead828e086f07f457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6eb154e5afc3a877aad4155cb90bca9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae6eb154e5afc3a877aad4155cb90bca9"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cache.html#gae6eb154e5afc3a877aad4155cb90bca9">L1CACHE_DisableDCache</a> (void)</td></tr>
<tr class="memdesc:gae6eb154e5afc3a877aad4155cb90bca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables L1 data cache. <br/></td></tr>
<tr class="separator:gae6eb154e5afc3a877aad4155cb90bca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6bb45d3f9feb8ed2a63b174d204f277"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad6bb45d3f9feb8ed2a63b174d204f277"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cache.html#gad6bb45d3f9feb8ed2a63b174d204f277">L1CACHE_InvalidateDCache</a> (void)</td></tr>
<tr class="memdesc:gad6bb45d3f9feb8ed2a63b174d204f277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates L1 data cache all. <br/></td></tr>
<tr class="separator:gad6bb45d3f9feb8ed2a63b174d204f277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga637e517f28aac4d3bc6366e14afac007"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cache.html#ga637e517f28aac4d3bc6366e14afac007">L1CACHE_InvalidateDCacheByRange</a> (uint32_t startAddr, uint32_t size_byte)</td></tr>
<tr class="memdesc:ga637e517f28aac4d3bc6366e14afac007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates L1 data cache by range.  <a href="#ga637e517f28aac4d3bc6366e14afac007">More...</a><br/></td></tr>
<tr class="separator:ga637e517f28aac4d3bc6366e14afac007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1dcfc930ee90724a807f69428a1f269"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab1dcfc930ee90724a807f69428a1f269"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cache.html#gab1dcfc930ee90724a807f69428a1f269">L1CACHE_CleanDCache</a> (void)</td></tr>
<tr class="memdesc:gab1dcfc930ee90724a807f69428a1f269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean L1 data cache all. <br/></td></tr>
<tr class="separator:gab1dcfc930ee90724a807f69428a1f269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37efdfa60ee28d5443e02acab61236fe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cache.html#ga37efdfa60ee28d5443e02acab61236fe">L1CACHE_CleanDCacheByRange</a> (uint32_t startAddr, uint32_t size_byte)</td></tr>
<tr class="memdesc:ga37efdfa60ee28d5443e02acab61236fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans L1 data cache by range.  <a href="#ga37efdfa60ee28d5443e02acab61236fe">More...</a><br/></td></tr>
<tr class="separator:ga37efdfa60ee28d5443e02acab61236fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49c6ba08328943022264442f6ce2c090"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga49c6ba08328943022264442f6ce2c090"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cache.html#ga49c6ba08328943022264442f6ce2c090">L1CACHE_CleanInvalidateDCache</a> (void)</td></tr>
<tr class="memdesc:ga49c6ba08328943022264442f6ce2c090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans and invalidates L1 data cache all. <br/></td></tr>
<tr class="separator:ga49c6ba08328943022264442f6ce2c090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5f7fdd71c5d7569ff3bb490e7d4e860"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cache.html#gaf5f7fdd71c5d7569ff3bb490e7d4e860">L1CACHE_CleanInvalidateDCacheByRange</a> (uint32_t startAddr, uint32_t size_byte)</td></tr>
<tr class="memdesc:gaf5f7fdd71c5d7569ff3bb490e7d4e860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans and invalidates L1 data cache by range.  <a href="#gaf5f7fdd71c5d7569ff3bb490e7d4e860">More...</a><br/></td></tr>
<tr class="separator:gaf5f7fdd71c5d7569ff3bb490e7d4e860"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Unified Cache Control for all caches which is mainly used for</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp5ff1ad7e65ab3cdad9418f47b7243124"></a>SDK Driver easy use cache driver </p>
</td></tr>
<tr class="memitem:ga00cdccb5c53201a747f2a3e2009f43cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cache.html#ga00cdccb5c53201a747f2a3e2009f43cc">ICACHE_InvalidateByRange</a> (uint32_t address, uint32_t size_byte)</td></tr>
<tr class="memdesc:ga00cdccb5c53201a747f2a3e2009f43cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates instruction cache by range.  <a href="#ga00cdccb5c53201a747f2a3e2009f43cc">More...</a><br/></td></tr>
<tr class="separator:ga00cdccb5c53201a747f2a3e2009f43cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5c47d7193562d7a763b1bc1bd91b28c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cache.html#gab5c47d7193562d7a763b1bc1bd91b28c">DCACHE_InvalidateByRange</a> (uint32_t address, uint32_t size_byte)</td></tr>
<tr class="memdesc:gab5c47d7193562d7a763b1bc1bd91b28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates data cache by range.  <a href="#gab5c47d7193562d7a763b1bc1bd91b28c">More...</a><br/></td></tr>
<tr class="separator:gab5c47d7193562d7a763b1bc1bd91b28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga893959336987f85910fe98ab9f7f8648"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cache.html#ga893959336987f85910fe98ab9f7f8648">DCACHE_CleanByRange</a> (uint32_t address, uint32_t size_byte)</td></tr>
<tr class="memdesc:ga893959336987f85910fe98ab9f7f8648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans data cache by range.  <a href="#ga893959336987f85910fe98ab9f7f8648">More...</a><br/></td></tr>
<tr class="separator:ga893959336987f85910fe98ab9f7f8648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac20095b525889cf55c105658877c2c84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cache.html#gac20095b525889cf55c105658877c2c84">DCACHE_CleanInvalidateByRange</a> (uint32_t address, uint32_t size_byte)</td></tr>
<tr class="memdesc:gac20095b525889cf55c105658877c2c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans and Invalidates data cache by range.  <a href="#gac20095b525889cf55c105658877c2c84">More...</a><br/></td></tr>
<tr class="separator:gac20095b525889cf55c105658877c2c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gac954b8be2bb59a983a9594c59e4b4fa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSL_CACHE_DRIVER_VERSION&#160;&#160;&#160;(MAKE_VERSION(2, 0, 0))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga62a60ab1f97162593c8b1d66b90db5de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void L1CACHE_InvalidateICacheByRange </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size_byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startAddr</td><td>The start startAddr of the memory to be invalidated. </td></tr>
    <tr><td class="paramname">size_byte</td><td>The memory size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The start startAddr and size_byte should be 32-byte(FSL_FEATURE_L1ICACHE_LINESIZE_BYTE) aligned due to the cache operation unit is one L1 I-cache line. The startAddr here will be forced to align to L1 I-cache line size if startAddr is not aligned. For the size_byte, application should make sure the alignment or make sure the right operation order if the size_byte is not aligned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga637e517f28aac4d3bc6366e14afac007"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void L1CACHE_InvalidateDCacheByRange </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size_byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startAddr</td><td>The start startAddr of the memory to be invalidated. </td></tr>
    <tr><td class="paramname">size_byte</td><td>The memory size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The start startAddr and size_byte should be 64-byte(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE) aligned due to the cache operation unit is one L1 D-cache line. The startAddr here will be forced to align to L1 D-cache line size if startAddr is not aligned. For the size_byte, application should make sure the alignment or make sure the right operation order if the size_byte is not aligned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga37efdfa60ee28d5443e02acab61236fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void L1CACHE_CleanDCacheByRange </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size_byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startAddr</td><td>The start startAddr of the memory to be cleaned. </td></tr>
    <tr><td class="paramname">size_byte</td><td>The memory size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The start startAddr and size_byte should be 64-byte(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE) aligned due to the cache operation unit is one L1 D-cache line. The startAddr here will be forced to align to L1 D-cache line size if startAddr is not aligned. For size_byte, application should make sure the alignment or make sure the right operation order if the size_byte is not aligned. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf5f7fdd71c5d7569ff3bb490e7d4e860"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void L1CACHE_CleanInvalidateDCacheByRange </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size_byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startAddr</td><td>The start startAddr of the memory to be clean and invalidated. </td></tr>
    <tr><td class="paramname">size_byte</td><td>The memory size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The start startAddr and size_byte should be 64-byte(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE) aligned due to the cache operation unit is one L1 D-cache line. The startAddr here will be forced to align to L1 D-cache line size if startAddr is not aligned. For size_byte, application should make sure the alignment or make sure the right operation order if the size_byte is not aligned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga00cdccb5c53201a747f2a3e2009f43cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ICACHE_InvalidateByRange </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size_byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cortex-a L1 instruction cache line length is 32-byte.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The physical address. </td></tr>
    <tr><td class="paramname">size_byte</td><td>size of the memory to be invalidated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Address and size should be aligned to cache line size 32-Byte due to the cache operation unit is one cache line. The startAddr here will be forced to align to the cache line size if startAddr is not aligned. For the size_byte, application should make sure the alignment or make sure the right operation order if the size_byte is not aligned. </dd></dl>

</div>
</div>
<a class="anchor" id="gab5c47d7193562d7a763b1bc1bd91b28c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCACHE_InvalidateByRange </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size_byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cortex-a L1 data cache line length is 64-byte.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The physical address. </td></tr>
    <tr><td class="paramname">size_byte</td><td>size of the memory to be invalidated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Address and size should be aligned to cache line size 64-byte due to the cache operation unit is one cache line. The startAddr here will be forced to align to the cache line size if startAddr is not aligned. For the size_byte, application should make sure the alignment or make sure the right operation order if the size_byte is not aligned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga893959336987f85910fe98ab9f7f8648"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCACHE_CleanByRange </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size_byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cortex-a L1 data cache line length is 64-byte.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The physical address. </td></tr>
    <tr><td class="paramname">size_byte</td><td>size of the memory to be cleaned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Address and size should be aligned to cache line size 64-byte due to the cache operation unit is one cache line. The startAddr here will be forced to align to the cache line size if startAddr is not aligned. For the size_byte, application should make sure the alignment or make sure the right operation order if the size_byte is not aligned. </dd></dl>

</div>
</div>
<a class="anchor" id="gac20095b525889cf55c105658877c2c84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DCACHE_CleanInvalidateByRange </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size_byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cortex-a L1 data cache line length is 64-byte.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The physical address. </td></tr>
    <tr><td class="paramname">size_byte</td><td>size of the memory to be cleaned and invalidated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Address and size should be aligned to cache line size 64-byte due to the cache operation unit is one cache line. The startAddr here will be forced to align to the cache line size if startAddr is not aligned. For the size_byte, application should make sure the alignment or make sure the right operation order if the size_byte is not aligned. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul class="foot">
    <li class="footer">&copy; 2016 NXP Semiconductors. All rights reserved.
    </li>
  </ul>
</div>
</body>
</html>
