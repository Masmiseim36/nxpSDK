<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>MCUXpresso SDK API Reference Manual: SRC: System Reset Controller Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="fs_logo.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">MCUXpresso SDK API Reference Manual
   &#160;<span id="projectnumber">Rev 2.14.0</span>
   </div>
   <div id="projectbrief">NXP Semiconductors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00278.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SRC: System Reset Controller Driver</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<p>The MCUXpresso SDK provides a peripheral driver for the System Reset Controller (SRC) module.</p>
<p>The System Reset Controller (SRC) controls the reset and boot operation of the SoC. It is responsible for the generation of all reset signals and boot decoding. The reset controller determines the source and the type of reset, such as POR, WARM, COLD, and performs the necessary reset qualification and stretching sequences. Based on the type of reset, the reset logic generates the reset sequence for the entire IC. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaf647f7dbfbed8b1612675ab132cfa244"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00278.html#gaf647f7dbfbed8b1612675ab132cfa244">_src_reset_status_flags</a> { <br/>
&#160;&#160;<a class="el" href="a00278.html#ggaf647f7dbfbed8b1612675ab132cfa244a1ec8e8b05164a48af564b20d8a3f667a">kSRC_WarmBootIndicationFlag</a> = SRC_SRSR_WBI_MASK, 
<br/>
&#160;&#160;<a class="el" href="a00278.html#ggaf647f7dbfbed8b1612675ab132cfa244a35d666ccd943a593bc1af289e6233adb">kSRC_TemperatureSensorResetFlag</a> = SRC_SRSR_TSR_MASK, 
<br/>
&#160;&#160;<a class="el" href="a00278.html#ggaf647f7dbfbed8b1612675ab132cfa244abc557d5e2e199f9727744af4b181602b">kSRC_JTAGSoftwareResetFlag</a> = SRC_SRSR_SJC_MASK, 
<br/>
&#160;&#160;<a class="el" href="a00278.html#ggaf647f7dbfbed8b1612675ab132cfa244a8a43d19a82614c4c1d571dad1f492628">kSRC_JTAGGeneratedResetFlag</a> = SRC_SRSR_JTAG_MASK, 
<br/>
&#160;&#160;<a class="el" href="a00278.html#ggaf647f7dbfbed8b1612675ab132cfa244abce52ce03031bdb1b0d76576daf418df">kSRC_WatchdogResetFlag</a> = SRC_SRSR_WDOG_MASK
<br/>
 }</td></tr>
<tr class="memdesc:gaf647f7dbfbed8b1612675ab132cfa244"><td class="mdescLeft">&#160;</td><td class="mdescRight">SRC reset status flags.  <a href="a00278.html#gaf647f7dbfbed8b1612675ab132cfa244">More...</a><br/></td></tr>
<tr class="separator:gaf647f7dbfbed8b1612675ab132cfa244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b40161d6cf7c90a651afd9047b6bedd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00278.html#ga5b40161d6cf7c90a651afd9047b6bedd">src_warm_reset_bypass_count_t</a> { <br/>
&#160;&#160;<a class="el" href="a00278.html#gga5b40161d6cf7c90a651afd9047b6beddae2e8afc71fab41ccbac78e6a8d69ff62">kSRC_WarmResetWaitAlways</a> = 0U, 
<br/>
&#160;&#160;<a class="el" href="a00278.html#gga5b40161d6cf7c90a651afd9047b6beddad20bc2e2d97c95046d65940f111e9584">kSRC_WarmResetWaitClk16</a> = 1U, 
<br/>
&#160;&#160;<a class="el" href="a00278.html#gga5b40161d6cf7c90a651afd9047b6bedda8c3d2f6cd0c0f36da9a342e3c3eb77f8">kSRC_WarmResetWaitClk32</a> = 2U, 
<br/>
&#160;&#160;<a class="el" href="a00278.html#gga5b40161d6cf7c90a651afd9047b6bedda5bbedec3e30404b252af1b02af0042c0">kSRC_WarmResetWaitClk64</a> = 3U
<br/>
 }</td></tr>
<tr class="memdesc:ga5b40161d6cf7c90a651afd9047b6bedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selection of WARM reset bypass count.  <a href="a00278.html#ga5b40161d6cf7c90a651afd9047b6bedd">More...</a><br/></td></tr>
<tr class="separator:ga5b40161d6cf7c90a651afd9047b6bedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac96321bdff82d5abc821d061323447df"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00278.html#gac96321bdff82d5abc821d061323447df">SRC_EnableWDOGReset</a> (SRC_Type *base, bool enable)</td></tr>
<tr class="memdesc:gac96321bdff82d5abc821d061323447df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the WDOG Reset in SRC.  <a href="#gac96321bdff82d5abc821d061323447df">More...</a><br/></td></tr>
<tr class="separator:gac96321bdff82d5abc821d061323447df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga855481246b5b5a4227d7d04f034ceaaa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00278.html#ga855481246b5b5a4227d7d04f034ceaaa">SRC_SetWarmResetBypassCount</a> (SRC_Type *base, <a class="el" href="a00278.html#ga5b40161d6cf7c90a651afd9047b6bedd">src_warm_reset_bypass_count_t</a> option)</td></tr>
<tr class="memdesc:ga855481246b5b5a4227d7d04f034ceaaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the delay count of waiting MMDC's acknowledge.  <a href="#ga855481246b5b5a4227d7d04f034ceaaa">More...</a><br/></td></tr>
<tr class="separator:ga855481246b5b5a4227d7d04f034ceaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga627a1af6de292a91078ce42a1d8976e6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00278.html#ga627a1af6de292a91078ce42a1d8976e6">SRC_EnableWarmReset</a> (SRC_Type *base, bool enable)</td></tr>
<tr class="memdesc:ga627a1af6de292a91078ce42a1d8976e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the WARM reset.  <a href="#ga627a1af6de292a91078ce42a1d8976e6">More...</a><br/></td></tr>
<tr class="separator:ga627a1af6de292a91078ce42a1d8976e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34abd9ece8bad43b617ced6e018af08c"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00278.html#ga34abd9ece8bad43b617ced6e018af08c">SRC_GetBootModeWord1</a> (SRC_Type *base)</td></tr>
<tr class="memdesc:ga34abd9ece8bad43b617ced6e018af08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the boot mode register 1 value.  <a href="#ga34abd9ece8bad43b617ced6e018af08c">More...</a><br/></td></tr>
<tr class="separator:ga34abd9ece8bad43b617ced6e018af08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab850f1217901abfd78a35096a3b30d64"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00278.html#gab850f1217901abfd78a35096a3b30d64">SRC_GetBootModeWord2</a> (SRC_Type *base)</td></tr>
<tr class="memdesc:gab850f1217901abfd78a35096a3b30d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the boot mode register 2 value.  <a href="#gab850f1217901abfd78a35096a3b30d64">More...</a><br/></td></tr>
<tr class="separator:gab850f1217901abfd78a35096a3b30d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7bdfcb753a5abc9428de4c6169410b4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00278.html#gae7bdfcb753a5abc9428de4c6169410b4">SRC_SetWarmBootIndication</a> (SRC_Type *base, bool enable)</td></tr>
<tr class="memdesc:gae7bdfcb753a5abc9428de4c6169410b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the warm boot indication flag.  <a href="#gae7bdfcb753a5abc9428de4c6169410b4">More...</a><br/></td></tr>
<tr class="separator:gae7bdfcb753a5abc9428de4c6169410b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac15086ff9e2d490efc95b8a5577cbae6"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00278.html#gac15086ff9e2d490efc95b8a5577cbae6">SRC_GetResetStatusFlags</a> (SRC_Type *base)</td></tr>
<tr class="memdesc:gac15086ff9e2d490efc95b8a5577cbae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status flags of SRC.  <a href="#gac15086ff9e2d490efc95b8a5577cbae6">More...</a><br/></td></tr>
<tr class="separator:gac15086ff9e2d490efc95b8a5577cbae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36d75f094528c8d5e37a77b4d45b617e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00278.html#ga36d75f094528c8d5e37a77b4d45b617e">SRC_ClearResetStatusFlags</a> (SRC_Type *base, uint32_t flags)</td></tr>
<tr class="memdesc:ga36d75f094528c8d5e37a77b4d45b617e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the status flags of SRC.  <a href="#ga36d75f094528c8d5e37a77b4d45b617e">More...</a><br/></td></tr>
<tr class="separator:ga36d75f094528c8d5e37a77b4d45b617e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c2062f093d4a0d164354ac7a2f4b3e2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00278.html#ga8c2062f093d4a0d164354ac7a2f4b3e2">SRC_SetGeneralPurposeRegister</a> (SRC_Type *base, uint32_t index, uint32_t value)</td></tr>
<tr class="memdesc:ga8c2062f093d4a0d164354ac7a2f4b3e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value to general purpose registers.  <a href="#ga8c2062f093d4a0d164354ac7a2f4b3e2">More...</a><br/></td></tr>
<tr class="separator:ga8c2062f093d4a0d164354ac7a2f4b3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c5e46dd8c4e1bd20aa737cfef532ab1"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00278.html#ga8c5e46dd8c4e1bd20aa737cfef532ab1">SRC_GetGeneralPurposeRegister</a> (SRC_Type *base, uint32_t index)</td></tr>
<tr class="memdesc:ga8c5e46dd8c4e1bd20aa737cfef532ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value from general purpose registers.  <a href="#ga8c5e46dd8c4e1bd20aa737cfef532ab1">More...</a><br/></td></tr>
<tr class="separator:ga8c5e46dd8c4e1bd20aa737cfef532ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Driver version</h2></td></tr>
<tr class="memitem:gab27a1d7efba9d270e93527f1d2c54605"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00278.html#gab27a1d7efba9d270e93527f1d2c54605">FSL_SRC_DRIVER_VERSION</a>&#160;&#160;&#160;(<a class="el" href="a00258.html#ga812138aa3315b0c6953c1a26130bcc37">MAKE_VERSION</a>(2, 0, 1))</td></tr>
<tr class="memdesc:gab27a1d7efba9d270e93527f1d2c54605"><td class="mdescLeft">&#160;</td><td class="mdescRight">SRC driver version 2.0.1.  <a href="#gab27a1d7efba9d270e93527f1d2c54605">More...</a><br/></td></tr>
<tr class="separator:gab27a1d7efba9d270e93527f1d2c54605"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gab27a1d7efba9d270e93527f1d2c54605"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSL_SRC_DRIVER_VERSION&#160;&#160;&#160;(<a class="el" href="a00258.html#ga812138aa3315b0c6953c1a26130bcc37">MAKE_VERSION</a>(2, 0, 1))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gaf647f7dbfbed8b1612675ab132cfa244"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00278.html#gaf647f7dbfbed8b1612675ab132cfa244">_src_reset_status_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggaf647f7dbfbed8b1612675ab132cfa244a1ec8e8b05164a48af564b20d8a3f667a"></a>kSRC_WarmBootIndicationFlag</em>&nbsp;</td><td class="fielddoc">
<p>WARM boot indication shows that WARM boot was initiated by software. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaf647f7dbfbed8b1612675ab132cfa244a35d666ccd943a593bc1af289e6233adb"></a>kSRC_TemperatureSensorResetFlag</em>&nbsp;</td><td class="fielddoc">
<p>Indicates whether the reset was the result of software reset from on-chip Temperature Sensor. </p>
<p>Temperature Sensor Interrupt needs to be served before this bit can be cleaned. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaf647f7dbfbed8b1612675ab132cfa244abc557d5e2e199f9727744af4b181602b"></a>kSRC_JTAGSoftwareResetFlag</em>&nbsp;</td><td class="fielddoc">
<p>Indicates whether the reset was the result of setting SJC_GPCCR bit 31. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaf647f7dbfbed8b1612675ab132cfa244a8a43d19a82614c4c1d571dad1f492628"></a>kSRC_JTAGGeneratedResetFlag</em>&nbsp;</td><td class="fielddoc">
<p>Indicates a reset has been caused by JTAG selection of certain IR codes: EXTEST or HIGHZ. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaf647f7dbfbed8b1612675ab132cfa244abce52ce03031bdb1b0d76576daf418df"></a>kSRC_WatchdogResetFlag</em>&nbsp;</td><td class="fielddoc">
<p>Indicates a reset has been caused by the watchdog timer timing out. </p>
<p>This reset source can be blocked by disabling the watchdog. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga5b40161d6cf7c90a651afd9047b6bedd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00278.html#ga5b40161d6cf7c90a651afd9047b6bedd">src_warm_reset_bypass_count_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type defines the 32KHz clock cycles to count before bypassing the MMDC acknowledge for WARM reset. If the MMDC acknowledge is not asserted before this counter is elapsed, a COLD reset will be initiated. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga5b40161d6cf7c90a651afd9047b6beddae2e8afc71fab41ccbac78e6a8d69ff62"></a>kSRC_WarmResetWaitAlways</em>&nbsp;</td><td class="fielddoc">
<p>System will wait until MMDC acknowledge is asserted. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga5b40161d6cf7c90a651afd9047b6beddad20bc2e2d97c95046d65940f111e9584"></a>kSRC_WarmResetWaitClk16</em>&nbsp;</td><td class="fielddoc">
<p>Wait 16 32KHz clock cycles before switching the reset. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga5b40161d6cf7c90a651afd9047b6bedda8c3d2f6cd0c0f36da9a342e3c3eb77f8"></a>kSRC_WarmResetWaitClk32</em>&nbsp;</td><td class="fielddoc">
<p>Wait 32 32KHz clock cycles before switching the reset. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga5b40161d6cf7c90a651afd9047b6bedda5bbedec3e30404b252af1b02af0042c0"></a>kSRC_WarmResetWaitClk64</em>&nbsp;</td><td class="fielddoc">
<p>Wait 64 32KHz clock cycles before switching the reset. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac96321bdff82d5abc821d061323447df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SRC_EnableWDOGReset </td>
          <td>(</td>
          <td class="paramtype">SRC_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>WDOG Reset is enabled in SRC by default. If the WDOG event to SRC is masked, it would not create a reset to the chip. During the time the WDOG event is masked, when the WDOG event flag is asserted, it would remain asserted regardless of servicing the WDOG module. The only way to clear that bit is the hardware reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>SRC peripheral base address. </td></tr>
    <tr><td class="paramname">enable</td><td>Enable the reset or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga855481246b5b5a4227d7d04f034ceaaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SRC_SetWarmResetBypassCount </td>
          <td>(</td>
          <td class="paramtype">SRC_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00278.html#ga5b40161d6cf7c90a651afd9047b6bedd">src_warm_reset_bypass_count_t</a>&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function would define the 32KHz clock cycles to count before bypassing the MMDC acknowledge for WARM reset. If the MMDC acknowledge is not asserted before this counter is elapsed, a COLD reset will be initiated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>SRC peripheral base address. </td></tr>
    <tr><td class="paramname">option</td><td>The option of setting mode, see to <a class="el" href="a00278.html#ga5b40161d6cf7c90a651afd9047b6bedd" title="Selection of WARM reset bypass count. ">src_warm_reset_bypass_count_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga627a1af6de292a91078ce42a1d8976e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SRC_EnableWarmReset </td>
          <td>(</td>
          <td class="paramtype">SRC_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Only when the WARM reset is enabled, the WARM reset requests would be served by WARM reset. Otherwise, all the WARM reset sources would generate COLD reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>SRC peripheral base address. </td></tr>
    <tr><td class="paramname">enable</td><td>Enable the WARM reset or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga34abd9ece8bad43b617ced6e018af08c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t SRC_GetBootModeWord1 </td>
          <td>(</td>
          <td class="paramtype">SRC_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The Boot Mode register contains bits that reflect the status of BOOT_CFGx pins of the chip. See to chip-specific document for detail information about value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>SRC peripheral base address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of BOOT_CFGx pins of the chip. </dd></dl>

</div>
</div>
<a class="anchor" id="gab850f1217901abfd78a35096a3b30d64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t SRC_GetBootModeWord2 </td>
          <td>(</td>
          <td class="paramtype">SRC_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The Boot Mode register contains bits that reflect the status of BOOT_MODEx Pins and fuse values that controls boot of the chip. See to chip-specific document for detail information about value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>SRC peripheral base address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of BOOT_MODEx Pins and fuse values that controls boot of the chip. </dd></dl>

</div>
</div>
<a class="anchor" id="gae7bdfcb753a5abc9428de4c6169410b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SRC_SetWarmBootIndication </td>
          <td>(</td>
          <td class="paramtype">SRC_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>WARM boot indication shows that WARM boot was initiated by software. This indicates to the software that it saved the needed information in the memory before initiating the WARM reset. In this case, software will set this bit to '1', before initiating the WARM reset. The warm_boot bit should be used as indication only after a warm_reset sequence. Software should clear this bit after warm_reset to indicate that the next warm_reset is not performed with warm_boot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>SRC peripheral base address. </td></tr>
    <tr><td class="paramname">enable</td><td>Assert the flag or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac15086ff9e2d490efc95b8a5577cbae6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t SRC_GetResetStatusFlags </td>
          <td>(</td>
          <td class="paramtype">SRC_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>SRC peripheral base address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mask value of status flags, see to <a class="el" href="a00278.html#gaf647f7dbfbed8b1612675ab132cfa244" title="SRC reset status flags. ">_src_reset_status_flags</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga36d75f094528c8d5e37a77b4d45b617e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SRC_ClearResetStatusFlags </td>
          <td>(</td>
          <td class="paramtype">SRC_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>SRC peripheral base address. </td></tr>
    <tr><td class="paramname">flags</td><td>value of status flags to be cleared, see to <a class="el" href="a00278.html#gaf647f7dbfbed8b1612675ab132cfa244" title="SRC reset status flags. ">_src_reset_status_flags</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8c2062f093d4a0d164354ac7a2f4b3e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SRC_SetGeneralPurposeRegister </td>
          <td>(</td>
          <td class="paramtype">SRC_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>General purpose registers (GPRx) would hold the value during reset process. Wakeup function could be kept in these register. For example, the GPR1 holds the entry function for waking-up from Partial SLEEP mode while the GPR2 holds the argument. Other GPRx register would store the arbitray values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>SRC peripheral base address. </td></tr>
    <tr><td class="paramname">index</td><td>The index of GPRx register array. Note index 0 reponses the GPR1 register. </td></tr>
    <tr><td class="paramname">value</td><td>Setting value for GPRx register. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8c5e46dd8c4e1bd20aa737cfef532ab1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t SRC_GetGeneralPurposeRegister </td>
          <td>(</td>
          <td class="paramtype">SRC_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>SRC peripheral base address. </td></tr>
    <tr><td class="paramname">index</td><td>The index of GPRx register array. Note index 0 reponses the GPR1 register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The setting value for GPRx register. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul class="foot">
    <li class="footer">&copy; 2016 NXP Semiconductors. All rights reserved.
    </li>
  </ul>
</div>
</body>
</html>
