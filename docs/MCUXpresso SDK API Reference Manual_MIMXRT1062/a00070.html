<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>MCUXpresso SDK API Reference Manual: Serial Manager</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="fs_logo.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">MCUXpresso SDK API Reference Manual
   &#160;<span id="projectnumber">Rev 2.15.000</span>
   </div>
   <div id="projectbrief">NXP Semiconductors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00070.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Serial Manager</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<p>This chapter describes the programming interface of the serial manager component.</p>
<p>The serial manager component provides a series of APIs to operate different serial port types. The port types it supports are UART, USB CDC and SWO. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:a00071"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html">Serial Port SWO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00072"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00072.html">Serial Port USB</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00310"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00310.html">Serial Port Uart</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:a00519"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a00519">_serial_manager_config</a></td></tr>
<tr class="memdesc:a00519"><td class="mdescLeft">&#160;</td><td class="mdescRight">serial manager config structure  <a href="a00070.html#a00519">More...</a><br/></td></tr>
<tr class="separator:a00519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00518"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a00518">_serial_manager_callback_message</a></td></tr>
<tr class="memdesc:a00518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback message structure.  <a href="a00070.html#a00518">More...</a><br/></td></tr>
<tr class="separator:a00518"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gabf238ccb327fd5316f765109d1235ae3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabf238ccb327fd5316f765109d1235ae3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#gabf238ccb327fd5316f765109d1235ae3">SERIAL_MANAGER_NON_BLOCKING_MODE</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="memdesc:gabf238ccb327fd5316f765109d1235ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable serial manager non-blocking mode (1 - enable, 0 - disable) <br/></td></tr>
<tr class="separator:gabf238ccb327fd5316f765109d1235ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71fc96165b245c238b1f5c821ce9ebf8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga71fc96165b245c238b1f5c821ce9ebf8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga71fc96165b245c238b1f5c821ce9ebf8">SERIAL_MANAGER_RING_BUFFER_FLOWCONTROL</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="memdesc:ga71fc96165b245c238b1f5c821ce9ebf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or ring buffer flow control (1 - enable, 0 - disable) <br/></td></tr>
<tr class="separator:ga71fc96165b245c238b1f5c821ce9ebf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58308509c0f8d97f157a3f9eb5d72ce2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga58308509c0f8d97f157a3f9eb5d72ce2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga58308509c0f8d97f157a3f9eb5d72ce2">SERIAL_PORT_TYPE_UART</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="memdesc:ga58308509c0f8d97f157a3f9eb5d72ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable uart port (1 - enable, 0 - disable) <br/></td></tr>
<tr class="separator:ga58308509c0f8d97f157a3f9eb5d72ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43b6bea88dad21ddfd0a9eeba15500fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga43b6bea88dad21ddfd0a9eeba15500fe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga43b6bea88dad21ddfd0a9eeba15500fe">SERIAL_PORT_TYPE_UART_DMA</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="memdesc:ga43b6bea88dad21ddfd0a9eeba15500fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable uart dma port (1 - enable, 0 - disable) <br/></td></tr>
<tr class="separator:ga43b6bea88dad21ddfd0a9eeba15500fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2e3166c5915cc3c3669d158da08cd51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf2e3166c5915cc3c3669d158da08cd51"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#gaf2e3166c5915cc3c3669d158da08cd51">SERIAL_PORT_TYPE_USBCDC</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="memdesc:gaf2e3166c5915cc3c3669d158da08cd51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable USB CDC port (1 - enable, 0 - disable) <br/></td></tr>
<tr class="separator:gaf2e3166c5915cc3c3669d158da08cd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c73031b5ccec048199e131e3b4eaafc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7c73031b5ccec048199e131e3b4eaafc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga7c73031b5ccec048199e131e3b4eaafc">SERIAL_PORT_TYPE_SWO</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="memdesc:ga7c73031b5ccec048199e131e3b4eaafc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable SWO port (1 - enable, 0 - disable) <br/></td></tr>
<tr class="separator:ga7c73031b5ccec048199e131e3b4eaafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95320da6bae985e8917dae79acad6857"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga95320da6bae985e8917dae79acad6857"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga95320da6bae985e8917dae79acad6857">SERIAL_PORT_TYPE_VIRTUAL</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="memdesc:ga95320da6bae985e8917dae79acad6857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable USB CDC virtual port (1 - enable, 0 - disable) <br/></td></tr>
<tr class="separator:ga95320da6bae985e8917dae79acad6857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8fb1fba8f9d1cea85a3203555fdb270"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf8fb1fba8f9d1cea85a3203555fdb270"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#gaf8fb1fba8f9d1cea85a3203555fdb270">SERIAL_PORT_TYPE_RPMSG</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="memdesc:gaf8fb1fba8f9d1cea85a3203555fdb270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable rPMSG port (1 - enable, 0 - disable) <br/></td></tr>
<tr class="separator:gaf8fb1fba8f9d1cea85a3203555fdb270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0930f57cce1c63e56b8ce280e7423304"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0930f57cce1c63e56b8ce280e7423304"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga0930f57cce1c63e56b8ce280e7423304">SERIAL_PORT_TYPE_SPI_MASTER</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="memdesc:ga0930f57cce1c63e56b8ce280e7423304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable SPI Master port (1 - enable, 0 - disable) <br/></td></tr>
<tr class="separator:ga0930f57cce1c63e56b8ce280e7423304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78917d72251361c814cc6c09177fbbf4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga78917d72251361c814cc6c09177fbbf4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga78917d72251361c814cc6c09177fbbf4">SERIAL_PORT_TYPE_SPI_SLAVE</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="memdesc:ga78917d72251361c814cc6c09177fbbf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable SPI Slave port (1 - enable, 0 - disable) <br/></td></tr>
<tr class="separator:ga78917d72251361c814cc6c09177fbbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe87e3d59c182fdceba8b869a5cf0a33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafe87e3d59c182fdceba8b869a5cf0a33"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#gafe87e3d59c182fdceba8b869a5cf0a33">SERIAL_PORT_TYPE_BLE_WU</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="memdesc:gafe87e3d59c182fdceba8b869a5cf0a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable BLE WU port (1 - enable, 0 - disable) <br/></td></tr>
<tr class="separator:gafe87e3d59c182fdceba8b869a5cf0a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefd7b994ea13ed385804afbe3268db7c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#gaefd7b994ea13ed385804afbe3268db7c">SERIAL_MANAGER_WRITE_TIME_DELAY_DEFAULT_VALUE</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="memdesc:gaefd7b994ea13ed385804afbe3268db7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default delay time in ms used by SerialManager_WriteTimeDelay().  <a href="#gaefd7b994ea13ed385804afbe3268db7c">More...</a><br/></td></tr>
<tr class="separator:gaefd7b994ea13ed385804afbe3268db7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e349416c81a583a8a98e99683624929"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga5e349416c81a583a8a98e99683624929">SERIAL_MANAGER_READ_TIME_DELAY_DEFAULT_VALUE</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="memdesc:ga5e349416c81a583a8a98e99683624929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default delay time in ms used by SerialManager_ReadTimeDelay().  <a href="#ga5e349416c81a583a8a98e99683624929">More...</a><br/></td></tr>
<tr class="separator:ga5e349416c81a583a8a98e99683624929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb98bd8be88e9a526f1e517bc6215a8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacb98bd8be88e9a526f1e517bc6215a8d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#gacb98bd8be88e9a526f1e517bc6215a8d">SERIAL_MANAGER_TASK_HANDLE_RX_AVAILABLE_NOTIFY</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="memdesc:gacb98bd8be88e9a526f1e517bc6215a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable SerialManager_Task() handle RX data available notify. <br/></td></tr>
<tr class="separator:gacb98bd8be88e9a526f1e517bc6215a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac278be51c3508495c1be1a4cff566f3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac278be51c3508495c1be1a4cff566f3f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#gac278be51c3508495c1be1a4cff566f3f">SERIAL_MANAGER_WRITE_HANDLE_SIZE</a>&#160;&#160;&#160;(44U)</td></tr>
<tr class="memdesc:gac278be51c3508495c1be1a4cff566f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set serial manager write handle size. <br/></td></tr>
<tr class="separator:gac278be51c3508495c1be1a4cff566f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae959bcddd181966d6c8bf4cbf140fea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#gaae959bcddd181966d6c8bf4cbf140fea">SERIAL_MANAGER_USE_COMMON_TASK</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="memdesc:gaae959bcddd181966d6c8bf4cbf140fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">SERIAL_PORT_UART_HANDLE_SIZE/SERIAL_PORT_USB_CDC_HANDLE_SIZE + serial manager dedicated size.  <a href="#gaae959bcddd181966d6c8bf4cbf140fea">More...</a><br/></td></tr>
<tr class="separator:gaae959bcddd181966d6c8bf4cbf140fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc4aa7ae83c31b66e437d7fd264aaebc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#gabc4aa7ae83c31b66e437d7fd264aaebc">SERIAL_MANAGER_HANDLE_SIZE</a>&#160;&#160;&#160;(SERIAL_MANAGER_HANDLE_SIZE_TEMP + 124U)</td></tr>
<tr class="memdesc:gabc4aa7ae83c31b66e437d7fd264aaebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of serial manager handle size.  <a href="#gabc4aa7ae83c31b66e437d7fd264aaebc">More...</a><br/></td></tr>
<tr class="separator:gabc4aa7ae83c31b66e437d7fd264aaebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad145f5877828fd4ec335f09b6790c673"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#gad145f5877828fd4ec335f09b6790c673">SERIAL_MANAGER_HANDLE_DEFINE</a>(name)&#160;&#160;&#160;uint32_t name[((<a class="el" href="a00070.html#gabc4aa7ae83c31b66e437d7fd264aaebc">SERIAL_MANAGER_HANDLE_SIZE</a> + sizeof(uint32_t) - 1U) / sizeof(uint32_t))]</td></tr>
<tr class="memdesc:gad145f5877828fd4ec335f09b6790c673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the serial manager handle.  <a href="#gad145f5877828fd4ec335f09b6790c673">More...</a><br/></td></tr>
<tr class="separator:gad145f5877828fd4ec335f09b6790c673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33eef6cd25374cbd49b00d2985b8be65"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga33eef6cd25374cbd49b00d2985b8be65">SERIAL_MANAGER_WRITE_HANDLE_DEFINE</a>(name)&#160;&#160;&#160;uint32_t name[((<a class="el" href="a00070.html#gac278be51c3508495c1be1a4cff566f3f">SERIAL_MANAGER_WRITE_HANDLE_SIZE</a> + sizeof(uint32_t) - 1U) / sizeof(uint32_t))]</td></tr>
<tr class="memdesc:ga33eef6cd25374cbd49b00d2985b8be65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the serial manager write handle.  <a href="#ga33eef6cd25374cbd49b00d2985b8be65">More...</a><br/></td></tr>
<tr class="separator:ga33eef6cd25374cbd49b00d2985b8be65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9206a431c26d9c557a0e32ab4d648e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#gae9206a431c26d9c557a0e32ab4d648e8">SERIAL_MANAGER_READ_HANDLE_DEFINE</a>(name)&#160;&#160;&#160;uint32_t name[((SERIAL_MANAGER_READ_HANDLE_SIZE + sizeof(uint32_t) - 1U) / sizeof(uint32_t))]</td></tr>
<tr class="memdesc:gae9206a431c26d9c557a0e32ab4d648e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the serial manager read handle.  <a href="#gae9206a431c26d9c557a0e32ab4d648e8">More...</a><br/></td></tr>
<tr class="separator:gae9206a431c26d9c557a0e32ab4d648e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bffc03255c48dae79cc2702f0980269"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga9bffc03255c48dae79cc2702f0980269">SERIAL_MANAGER_TASK_PRIORITY</a>&#160;&#160;&#160;(2U)</td></tr>
<tr class="memdesc:ga9bffc03255c48dae79cc2702f0980269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to set serial manager task priority.  <a href="#ga9bffc03255c48dae79cc2702f0980269">More...</a><br/></td></tr>
<tr class="separator:ga9bffc03255c48dae79cc2702f0980269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga460c59805f2a8ec37e008b5a285e1760"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga460c59805f2a8ec37e008b5a285e1760">SERIAL_MANAGER_TASK_STACK_SIZE</a>&#160;&#160;&#160;(1000U)</td></tr>
<tr class="memdesc:ga460c59805f2a8ec37e008b5a285e1760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to set serial manager task stack size.  <a href="#ga460c59805f2a8ec37e008b5a285e1760">More...</a><br/></td></tr>
<tr class="separator:ga460c59805f2a8ec37e008b5a285e1760"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaba1cc3859c4f829ee0bc6091184d4b08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaba1cc3859c4f829ee0bc6091184d4b08"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#gaba1cc3859c4f829ee0bc6091184d4b08">serial_handle_t</a></td></tr>
<tr class="memdesc:gaba1cc3859c4f829ee0bc6091184d4b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">The handle of the serial manager module. <br/></td></tr>
<tr class="separator:gaba1cc3859c4f829ee0bc6091184d4b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8319b6189019680778f230eb319530e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac8319b6189019680778f230eb319530e"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#gac8319b6189019680778f230eb319530e">serial_write_handle_t</a></td></tr>
<tr class="memdesc:gac8319b6189019680778f230eb319530e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The write handle of the serial manager module. <br/></td></tr>
<tr class="separator:gac8319b6189019680778f230eb319530e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bfec9c49e40728806d775fdb4bbf78e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8bfec9c49e40728806d775fdb4bbf78e"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga8bfec9c49e40728806d775fdb4bbf78e">serial_read_handle_t</a></td></tr>
<tr class="memdesc:ga8bfec9c49e40728806d775fdb4bbf78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The read handle of the serial manager module. <br/></td></tr>
<tr class="separator:ga8bfec9c49e40728806d775fdb4bbf78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7dc5f93aacda72d14bb0fa66b0401f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa7dc5f93aacda72d14bb0fa66b0401f3"></a>
typedef enum <a class="el" href="a00070.html#ga37012d03963b0a7aac96cda088362180">_serial_port_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#gaa7dc5f93aacda72d14bb0fa66b0401f3">serial_port_type_t</a></td></tr>
<tr class="memdesc:gaa7dc5f93aacda72d14bb0fa66b0401f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">serial port type <br/></td></tr>
<tr class="separator:gaa7dc5f93aacda72d14bb0fa66b0401f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1a68602a30a180467de438a4fc5f560"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac1a68602a30a180467de438a4fc5f560"></a>
typedef enum <a class="el" href="a00070.html#ga582a4193f06f2d326f72d6ec08d1cf1a">_serial_manager_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#gac1a68602a30a180467de438a4fc5f560">serial_manager_type_t</a></td></tr>
<tr class="memdesc:gac1a68602a30a180467de438a4fc5f560"><td class="mdescLeft">&#160;</td><td class="mdescRight">serial manager type <br/></td></tr>
<tr class="separator:gac1a68602a30a180467de438a4fc5f560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae9cb68d4f20901d9884b690d39a257a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaae9cb68d4f20901d9884b690d39a257a"></a>
typedef struct <br class="typebreak"/>
<a class="el" href="a00070.html#a00519">_serial_manager_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#gaae9cb68d4f20901d9884b690d39a257a">serial_manager_config_t</a></td></tr>
<tr class="memdesc:gaae9cb68d4f20901d9884b690d39a257a"><td class="mdescLeft">&#160;</td><td class="mdescRight">serial manager config structure <br/></td></tr>
<tr class="separator:gaae9cb68d4f20901d9884b690d39a257a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1d9f848c57ca245ad9da8d049369da9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac1d9f848c57ca245ad9da8d049369da9"></a>
typedef enum <a class="el" href="a00070.html#ga936dd06c6718edc81ad0423a2bb04ad8">_serial_manager_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a></td></tr>
<tr class="memdesc:gac1d9f848c57ca245ad9da8d049369da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">serial manager error code <br/></td></tr>
<tr class="separator:gac1d9f848c57ca245ad9da8d049369da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf1dca4823669f7e5e243b1e8826eb85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaf1dca4823669f7e5e243b1e8826eb85"></a>
typedef struct <br class="typebreak"/>
<a class="el" href="a00070.html#a00518">_serial_manager_callback_message</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#gaaf1dca4823669f7e5e243b1e8826eb85">serial_manager_callback_message_t</a></td></tr>
<tr class="memdesc:gaaf1dca4823669f7e5e243b1e8826eb85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback message structure. <br/></td></tr>
<tr class="separator:gaaf1dca4823669f7e5e243b1e8826eb85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe6a6263bb1570ea715938b2420af773"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabe6a6263bb1570ea715938b2420af773"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#gabe6a6263bb1570ea715938b2420af773">serial_manager_callback_t</a> )(void *callbackParam, <a class="el" href="a00070.html#gaaf1dca4823669f7e5e243b1e8826eb85">serial_manager_callback_message_t</a> *message, <a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a> status)</td></tr>
<tr class="memdesc:gabe6a6263bb1570ea715938b2420af773"><td class="mdescLeft">&#160;</td><td class="mdescRight">serial manager callback function <br/></td></tr>
<tr class="separator:gabe6a6263bb1570ea715938b2420af773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4c4ee505dbfd70c8869c63d8f8155e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab4c4ee505dbfd70c8869c63d8f8155e4"></a>
typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#gab4c4ee505dbfd70c8869c63d8f8155e4">serial_manager_lowpower_critical_callback_t</a> )(int32_t power_mode)</td></tr>
<tr class="memdesc:gab4c4ee505dbfd70c8869c63d8f8155e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">serial manager Lowpower Critical callback function <br/></td></tr>
<tr class="separator:gab4c4ee505dbfd70c8869c63d8f8155e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga37012d03963b0a7aac96cda088362180"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga37012d03963b0a7aac96cda088362180">_serial_port_type</a> { <br/>
&#160;&#160;<a class="el" href="a00070.html#gga37012d03963b0a7aac96cda088362180a8c0a9f0a39981fc49bddc88b23e170fb">kSerialPort_None</a> = 0U, 
<br/>
&#160;&#160;<a class="el" href="a00070.html#gga37012d03963b0a7aac96cda088362180a5b4d039d8c91cb19fca7c5dc196f8d77">kSerialPort_Uart</a> = 1U, 
<br/>
&#160;&#160;<a class="el" href="a00070.html#gga37012d03963b0a7aac96cda088362180a3785825f30826c61a4ef13bf983381c2">kSerialPort_UsbCdc</a>, 
<br/>
&#160;&#160;<a class="el" href="a00070.html#gga37012d03963b0a7aac96cda088362180af6a37935b2767a9ae22825f0bc49ef77">kSerialPort_Swo</a>, 
<br/>
&#160;&#160;<a class="el" href="a00070.html#gga37012d03963b0a7aac96cda088362180a1ff49cc235ba1b2cf110d9cad5121aa4">kSerialPort_Virtual</a>, 
<br/>
&#160;&#160;<a class="el" href="a00070.html#gga37012d03963b0a7aac96cda088362180aa0ec8166f72522a029c7bdb44dbd8cbe">kSerialPort_Rpmsg</a>, 
<br/>
&#160;&#160;<a class="el" href="a00070.html#gga37012d03963b0a7aac96cda088362180acad7e31b320242ceb4088c8a32635c5e">kSerialPort_UartDma</a>, 
<br/>
&#160;&#160;<a class="el" href="a00070.html#gga37012d03963b0a7aac96cda088362180aedeec3b53f1439f00620cadea84b0fea">kSerialPort_SpiMaster</a>, 
<br/>
&#160;&#160;<a class="el" href="a00070.html#gga37012d03963b0a7aac96cda088362180a7ae48951cbd3ca0ee687468af7f0a99a">kSerialPort_SpiSlave</a>, 
<br/>
&#160;&#160;<a class="el" href="a00070.html#gga37012d03963b0a7aac96cda088362180a068c303a297863ceefc8359eafc17b7f">kSerialPort_BleWu</a>
<br/>
 }</td></tr>
<tr class="memdesc:ga37012d03963b0a7aac96cda088362180"><td class="mdescLeft">&#160;</td><td class="mdescRight">serial port type  <a href="a00070.html#ga37012d03963b0a7aac96cda088362180">More...</a><br/></td></tr>
<tr class="separator:ga37012d03963b0a7aac96cda088362180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga582a4193f06f2d326f72d6ec08d1cf1a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga582a4193f06f2d326f72d6ec08d1cf1a">_serial_manager_type</a> { <br/>
&#160;&#160;<a class="el" href="a00070.html#gga582a4193f06f2d326f72d6ec08d1cf1aacae754a7dbe5f0d48d345a8b6120227c">kSerialManager_NonBlocking</a> = 0x0U, 
<br/>
&#160;&#160;<a class="el" href="a00070.html#gga582a4193f06f2d326f72d6ec08d1cf1aaa7834e61e5fcc82b73698f0465c3f24e">kSerialManager_Blocking</a> = 0x8F41U
<br/>
 }</td></tr>
<tr class="memdesc:ga582a4193f06f2d326f72d6ec08d1cf1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">serial manager type  <a href="a00070.html#ga582a4193f06f2d326f72d6ec08d1cf1a">More...</a><br/></td></tr>
<tr class="separator:ga582a4193f06f2d326f72d6ec08d1cf1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga936dd06c6718edc81ad0423a2bb04ad8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga936dd06c6718edc81ad0423a2bb04ad8">_serial_manager_status</a> { <br/>
&#160;&#160;<a class="el" href="a00070.html#gga936dd06c6718edc81ad0423a2bb04ad8a1e4ed7376c48b94ec9a60f272a629ed4">kStatus_SerialManager_Success</a> = kStatus_Success, 
<br/>
&#160;&#160;<a class="el" href="a00070.html#gga936dd06c6718edc81ad0423a2bb04ad8a61e6a331c5f789fe88fcf2bacf8a5553">kStatus_SerialManager_Error</a> = MAKE_STATUS(kStatusGroup_SERIALMANAGER, 1), 
<br/>
&#160;&#160;<a class="el" href="a00070.html#gga936dd06c6718edc81ad0423a2bb04ad8a67e18fb1e47f4f40dc58988b76a2d876">kStatus_SerialManager_Busy</a> = MAKE_STATUS(kStatusGroup_SERIALMANAGER, 2), 
<br/>
&#160;&#160;<a class="el" href="a00070.html#gga936dd06c6718edc81ad0423a2bb04ad8abdcdea0fcd8b4c01592728a4ba041154">kStatus_SerialManager_Notify</a> = MAKE_STATUS(kStatusGroup_SERIALMANAGER, 3), 
<br/>
&#160;&#160;<a class="el" href="a00070.html#gga936dd06c6718edc81ad0423a2bb04ad8af01c3a38751393325ab9791d8181ef38">kStatus_SerialManager_Canceled</a>, 
<br/>
&#160;&#160;<a class="el" href="a00070.html#gga936dd06c6718edc81ad0423a2bb04ad8a9f087536c7a9930159682ed03d8d71ea">kStatus_SerialManager_HandleConflict</a> = MAKE_STATUS(kStatusGroup_SERIALMANAGER, 5), 
<br/>
&#160;&#160;<a class="el" href="a00070.html#gga936dd06c6718edc81ad0423a2bb04ad8a41631953d2191b631fbe8443bfa856c8">kStatus_SerialManager_RingBufferOverflow</a>, 
<br/>
&#160;&#160;<a class="el" href="a00070.html#gga936dd06c6718edc81ad0423a2bb04ad8a1e09ebaf03a4d8599170987750b17ce6">kStatus_SerialManager_NotConnected</a> = MAKE_STATUS(kStatusGroup_SERIALMANAGER, 7)
<br/>
 }</td></tr>
<tr class="memdesc:ga936dd06c6718edc81ad0423a2bb04ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">serial manager error code  <a href="a00070.html#ga936dd06c6718edc81ad0423a2bb04ad8">More...</a><br/></td></tr>
<tr class="separator:ga936dd06c6718edc81ad0423a2bb04ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3a3439526ad4444ea2dc535cd6f69608"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga3a3439526ad4444ea2dc535cd6f69608">SerialManager_Init</a> (<a class="el" href="a00070.html#gaba1cc3859c4f829ee0bc6091184d4b08">serial_handle_t</a> serialHandle, const <a class="el" href="a00070.html#gaae9cb68d4f20901d9884b690d39a257a">serial_manager_config_t</a> *serialConfig)</td></tr>
<tr class="memdesc:ga3a3439526ad4444ea2dc535cd6f69608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a serial manager module with the serial manager handle and the user configuration structure.  <a href="#ga3a3439526ad4444ea2dc535cd6f69608">More...</a><br/></td></tr>
<tr class="separator:ga3a3439526ad4444ea2dc535cd6f69608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga467c8a817003eacd48f86aaef1ce8306"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga467c8a817003eacd48f86aaef1ce8306">SerialManager_Deinit</a> (<a class="el" href="a00070.html#gaba1cc3859c4f829ee0bc6091184d4b08">serial_handle_t</a> serialHandle)</td></tr>
<tr class="memdesc:ga467c8a817003eacd48f86aaef1ce8306"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initializes the serial manager module instance.  <a href="#ga467c8a817003eacd48f86aaef1ce8306">More...</a><br/></td></tr>
<tr class="separator:ga467c8a817003eacd48f86aaef1ce8306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d26249a8331e6ca17e9c60838b56d20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga3d26249a8331e6ca17e9c60838b56d20">SerialManager_OpenWriteHandle</a> (<a class="el" href="a00070.html#gaba1cc3859c4f829ee0bc6091184d4b08">serial_handle_t</a> serialHandle, <a class="el" href="a00070.html#gac8319b6189019680778f230eb319530e">serial_write_handle_t</a> writeHandle)</td></tr>
<tr class="memdesc:ga3d26249a8331e6ca17e9c60838b56d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a writing handle for the serial manager module.  <a href="#ga3d26249a8331e6ca17e9c60838b56d20">More...</a><br/></td></tr>
<tr class="separator:ga3d26249a8331e6ca17e9c60838b56d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb8df1d54da32e6de17680264ca4106a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#gadb8df1d54da32e6de17680264ca4106a">SerialManager_CloseWriteHandle</a> (<a class="el" href="a00070.html#gac8319b6189019680778f230eb319530e">serial_write_handle_t</a> writeHandle)</td></tr>
<tr class="memdesc:gadb8df1d54da32e6de17680264ca4106a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a writing handle for the serial manager module.  <a href="#gadb8df1d54da32e6de17680264ca4106a">More...</a><br/></td></tr>
<tr class="separator:gadb8df1d54da32e6de17680264ca4106a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66915bf8f50a417620ef94951d1df4b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga66915bf8f50a417620ef94951d1df4b8">SerialManager_OpenReadHandle</a> (<a class="el" href="a00070.html#gaba1cc3859c4f829ee0bc6091184d4b08">serial_handle_t</a> serialHandle, <a class="el" href="a00070.html#ga8bfec9c49e40728806d775fdb4bbf78e">serial_read_handle_t</a> readHandle)</td></tr>
<tr class="memdesc:ga66915bf8f50a417620ef94951d1df4b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a reading handle for the serial manager module.  <a href="#ga66915bf8f50a417620ef94951d1df4b8">More...</a><br/></td></tr>
<tr class="separator:ga66915bf8f50a417620ef94951d1df4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c8831eb6ca6e544881dcbf18dcb4a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga09c8831eb6ca6e544881dcbf18dcb4a7">SerialManager_CloseReadHandle</a> (<a class="el" href="a00070.html#ga8bfec9c49e40728806d775fdb4bbf78e">serial_read_handle_t</a> readHandle)</td></tr>
<tr class="memdesc:ga09c8831eb6ca6e544881dcbf18dcb4a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a reading for the serial manager module.  <a href="#ga09c8831eb6ca6e544881dcbf18dcb4a7">More...</a><br/></td></tr>
<tr class="separator:ga09c8831eb6ca6e544881dcbf18dcb4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fab1d6bffd89459be9f23d40874248e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga3fab1d6bffd89459be9f23d40874248e">SerialManager_WriteBlocking</a> (<a class="el" href="a00070.html#gac8319b6189019680778f230eb319530e">serial_write_handle_t</a> writeHandle, uint8_t *buffer, uint32_t length)</td></tr>
<tr class="memdesc:ga3fab1d6bffd89459be9f23d40874248e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmits data with the blocking mode.  <a href="#ga3fab1d6bffd89459be9f23d40874248e">More...</a><br/></td></tr>
<tr class="separator:ga3fab1d6bffd89459be9f23d40874248e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03b1bb5c3dbaa5ea2f0a6e7003f0b4eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga03b1bb5c3dbaa5ea2f0a6e7003f0b4eb">SerialManager_ReadBlocking</a> (<a class="el" href="a00070.html#ga8bfec9c49e40728806d775fdb4bbf78e">serial_read_handle_t</a> readHandle, uint8_t *buffer, uint32_t length)</td></tr>
<tr class="memdesc:ga03b1bb5c3dbaa5ea2f0a6e7003f0b4eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data with the blocking mode.  <a href="#ga03b1bb5c3dbaa5ea2f0a6e7003f0b4eb">More...</a><br/></td></tr>
<tr class="separator:ga03b1bb5c3dbaa5ea2f0a6e7003f0b4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga195f1c0ebf9a66952302003d25a50e6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga195f1c0ebf9a66952302003d25a50e6b">SerialManager_WriteNonBlocking</a> (<a class="el" href="a00070.html#gac8319b6189019680778f230eb319530e">serial_write_handle_t</a> writeHandle, uint8_t *buffer, uint32_t length)</td></tr>
<tr class="memdesc:ga195f1c0ebf9a66952302003d25a50e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmits data with the non-blocking mode.  <a href="#ga195f1c0ebf9a66952302003d25a50e6b">More...</a><br/></td></tr>
<tr class="separator:ga195f1c0ebf9a66952302003d25a50e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73b6a8e57790ee4d41476ef25488c495"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga73b6a8e57790ee4d41476ef25488c495">SerialManager_ReadNonBlocking</a> (<a class="el" href="a00070.html#ga8bfec9c49e40728806d775fdb4bbf78e">serial_read_handle_t</a> readHandle, uint8_t *buffer, uint32_t length)</td></tr>
<tr class="memdesc:ga73b6a8e57790ee4d41476ef25488c495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data with the non-blocking mode.  <a href="#ga73b6a8e57790ee4d41476ef25488c495">More...</a><br/></td></tr>
<tr class="separator:ga73b6a8e57790ee4d41476ef25488c495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f0a934ae5f1e8c20caff894f94bc70e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga3f0a934ae5f1e8c20caff894f94bc70e">SerialManager_TryRead</a> (<a class="el" href="a00070.html#ga8bfec9c49e40728806d775fdb4bbf78e">serial_read_handle_t</a> readHandle, uint8_t *buffer, uint32_t length, uint32_t *receivedLength)</td></tr>
<tr class="memdesc:ga3f0a934ae5f1e8c20caff894f94bc70e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to read data.  <a href="#ga3f0a934ae5f1e8c20caff894f94bc70e">More...</a><br/></td></tr>
<tr class="separator:ga3f0a934ae5f1e8c20caff894f94bc70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54a5b67dbaed110666666e24469fad13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga54a5b67dbaed110666666e24469fad13">SerialManager_CancelWriting</a> (<a class="el" href="a00070.html#gac8319b6189019680778f230eb319530e">serial_write_handle_t</a> writeHandle)</td></tr>
<tr class="memdesc:ga54a5b67dbaed110666666e24469fad13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels unfinished send transmission.  <a href="#ga54a5b67dbaed110666666e24469fad13">More...</a><br/></td></tr>
<tr class="separator:ga54a5b67dbaed110666666e24469fad13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cb009a3fcc17375bfa591b68008c94e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga7cb009a3fcc17375bfa591b68008c94e">SerialManager_CancelReading</a> (<a class="el" href="a00070.html#ga8bfec9c49e40728806d775fdb4bbf78e">serial_read_handle_t</a> readHandle)</td></tr>
<tr class="memdesc:ga7cb009a3fcc17375bfa591b68008c94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels unfinished receive transmission.  <a href="#ga7cb009a3fcc17375bfa591b68008c94e">More...</a><br/></td></tr>
<tr class="separator:ga7cb009a3fcc17375bfa591b68008c94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59eadfa140fe4cb42b306514a02288d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga59eadfa140fe4cb42b306514a02288d4">SerialManager_InstallTxCallback</a> (<a class="el" href="a00070.html#gac8319b6189019680778f230eb319530e">serial_write_handle_t</a> writeHandle, <a class="el" href="a00070.html#gabe6a6263bb1570ea715938b2420af773">serial_manager_callback_t</a> callback, void *callbackParam)</td></tr>
<tr class="memdesc:ga59eadfa140fe4cb42b306514a02288d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a TX callback and callback parameter.  <a href="#ga59eadfa140fe4cb42b306514a02288d4">More...</a><br/></td></tr>
<tr class="separator:ga59eadfa140fe4cb42b306514a02288d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8a8947d239858adf3626fe937ccda56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#gab8a8947d239858adf3626fe937ccda56">SerialManager_InstallRxCallback</a> (<a class="el" href="a00070.html#ga8bfec9c49e40728806d775fdb4bbf78e">serial_read_handle_t</a> readHandle, <a class="el" href="a00070.html#gabe6a6263bb1570ea715938b2420af773">serial_manager_callback_t</a> callback, void *callbackParam)</td></tr>
<tr class="memdesc:gab8a8947d239858adf3626fe937ccda56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a RX callback and callback parameter.  <a href="#gab8a8947d239858adf3626fe937ccda56">More...</a><br/></td></tr>
<tr class="separator:gab8a8947d239858adf3626fe937ccda56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26a6c26eacf1277930e69676ab77cbec"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga26a6c26eacf1277930e69676ab77cbec">SerialManager_needPollingIsr</a> (void)</td></tr>
<tr class="memdesc:ga26a6c26eacf1277930e69676ab77cbec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if need polling ISR.  <a href="#ga26a6c26eacf1277930e69676ab77cbec">More...</a><br/></td></tr>
<tr class="separator:ga26a6c26eacf1277930e69676ab77cbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32cdccd6df5d87f17037f34cf9f1e416"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga32cdccd6df5d87f17037f34cf9f1e416">SerialManager_EnterLowpower</a> (<a class="el" href="a00070.html#gaba1cc3859c4f829ee0bc6091184d4b08">serial_handle_t</a> serialHandle)</td></tr>
<tr class="memdesc:ga32cdccd6df5d87f17037f34cf9f1e416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares to enter low power consumption.  <a href="#ga32cdccd6df5d87f17037f34cf9f1e416">More...</a><br/></td></tr>
<tr class="separator:ga32cdccd6df5d87f17037f34cf9f1e416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef5c404d43871f6d8f761b27dbf183fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#gaef5c404d43871f6d8f761b27dbf183fa">SerialManager_ExitLowpower</a> (<a class="el" href="a00070.html#gaba1cc3859c4f829ee0bc6091184d4b08">serial_handle_t</a> serialHandle)</td></tr>
<tr class="memdesc:gaef5c404d43871f6d8f761b27dbf183fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores from low power consumption.  <a href="#gaef5c404d43871f6d8f761b27dbf183fa">More...</a><br/></td></tr>
<tr class="separator:gaef5c404d43871f6d8f761b27dbf183fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71bd55adb7a6a552ce5dac06b5794cea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ga71bd55adb7a6a552ce5dac06b5794cea">SerialManager_SetLowpowerCriticalCb</a> (const serial_manager_lowpower_critical_CBs_t *pfCallback)</td></tr>
<tr class="memdesc:ga71bd55adb7a6a552ce5dac06b5794cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs initialization of the callbacks structure used to disable lowpower when serial manager is active.  <a href="#ga71bd55adb7a6a552ce5dac06b5794cea">More...</a><br/></td></tr>
<tr class="separator:ga71bd55adb7a6a552ce5dac06b5794cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="a00519" id="a00519"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct _serial_manager_config</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:aab05900ee3fc3efa8b6c04fccc04e53f"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#aab05900ee3fc3efa8b6c04fccc04e53f">ringBuffer</a></td></tr>
<tr class="memdesc:aab05900ee3fc3efa8b6c04fccc04e53f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ring buffer address, it is used to buffer data received by the hardware.  <a href="#aab05900ee3fc3efa8b6c04fccc04e53f">More...</a><br/></td></tr>
<tr class="separator:aab05900ee3fc3efa8b6c04fccc04e53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0050101153ca0b44e74601a3ed10fe2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0050101153ca0b44e74601a3ed10fe2"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#aa0050101153ca0b44e74601a3ed10fe2">ringBufferSize</a></td></tr>
<tr class="memdesc:aa0050101153ca0b44e74601a3ed10fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the ring buffer. <br/></td></tr>
<tr class="separator:aa0050101153ca0b44e74601a3ed10fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4a4626ec722139dc792c97bca59adc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f4a4626ec722139dc792c97bca59adc"></a>
<a class="el" href="a00070.html#gaa7dc5f93aacda72d14bb0fa66b0401f3">serial_port_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a2f4a4626ec722139dc792c97bca59adc">type</a></td></tr>
<tr class="memdesc:a2f4a4626ec722139dc792c97bca59adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serial port type. <br/></td></tr>
<tr class="separator:a2f4a4626ec722139dc792c97bca59adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3338dd3f68a1960de0415c2563a0d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e3338dd3f68a1960de0415c2563a0d4"></a>
<a class="el" href="a00070.html#gac1a68602a30a180467de438a4fc5f560">serial_manager_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a8e3338dd3f68a1960de0415c2563a0d4">blockType</a></td></tr>
<tr class="memdesc:a8e3338dd3f68a1960de0415c2563a0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serial manager port type. <br/></td></tr>
<tr class="separator:a8e3338dd3f68a1960de0415c2563a0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca883359bc9c8977424d91cf54c867e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ca883359bc9c8977424d91cf54c867e"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a3ca883359bc9c8977424d91cf54c867e">portConfig</a></td></tr>
<tr class="memdesc:a3ca883359bc9c8977424d91cf54c867e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serial port configuration. <br/></td></tr>
<tr class="separator:a3ca883359bc9c8977424d91cf54c867e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="aab05900ee3fc3efa8b6c04fccc04e53f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* _serial_manager_config::ringBuffer</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Besides, the memory space cannot be free during the lifetime of the serial manager module. </p>

</div>
</div>

</div>
</div>
<a name="a00518" id="a00518"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct _serial_manager_callback_message</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a57fd13ae8f34fe58cc055bafd936c5f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57fd13ae8f34fe58cc055bafd936c5f4"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a57fd13ae8f34fe58cc055bafd936c5f4">buffer</a></td></tr>
<tr class="memdesc:a57fd13ae8f34fe58cc055bafd936c5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transferred buffer. <br/></td></tr>
<tr class="separator:a57fd13ae8f34fe58cc055bafd936c5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18eb3f893e218b84d4d8d0a16627421b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18eb3f893e218b84d4d8d0a16627421b"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a18eb3f893e218b84d4d8d0a16627421b">length</a></td></tr>
<tr class="memdesc:a18eb3f893e218b84d4d8d0a16627421b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transferred data length. <br/></td></tr>
<tr class="separator:a18eb3f893e218b84d4d8d0a16627421b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gaefd7b994ea13ed385804afbe3268db7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SERIAL_MANAGER_WRITE_TIME_DELAY_DEFAULT_VALUE&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5e349416c81a583a8a98e99683624929"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SERIAL_MANAGER_READ_TIME_DELAY_DEFAULT_VALUE&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaae959bcddd181966d6c8bf4cbf140fea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SERIAL_MANAGER_USE_COMMON_TASK&#160;&#160;&#160;(0U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro to determine whether use common task. </p>

</div>
</div>
<a class="anchor" id="gabc4aa7ae83c31b66e437d7fd264aaebc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SERIAL_MANAGER_HANDLE_SIZE&#160;&#160;&#160;(SERIAL_MANAGER_HANDLE_SIZE_TEMP + 124U)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gad145f5877828fd4ec335f09b6790c673"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SERIAL_MANAGER_HANDLE_DEFINE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name</td><td>)</td>
          <td>&#160;&#160;&#160;uint32_t name[((<a class="el" href="a00070.html#gabc4aa7ae83c31b66e437d7fd264aaebc">SERIAL_MANAGER_HANDLE_SIZE</a> + sizeof(uint32_t) - 1U) / sizeof(uint32_t))]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This macro is used to define a 4 byte aligned serial manager handle. Then use "(serial_handle_t)name" to get the serial manager handle.</p>
<p>The macro should be global and could be optional. You could also define serial manager handle by yourself.</p>
<p>This is an example, </p>
<div class="fragment"><div class="line">* <a class="code" href="a00070.html#gad145f5877828fd4ec335f09b6790c673">SERIAL_MANAGER_HANDLE_DEFINE</a>(serialManagerHandle);</div>
<div class="line">* </div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name string of the serial manager handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga33eef6cd25374cbd49b00d2985b8be65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SERIAL_MANAGER_WRITE_HANDLE_DEFINE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name</td><td>)</td>
          <td>&#160;&#160;&#160;uint32_t name[((<a class="el" href="a00070.html#gac278be51c3508495c1be1a4cff566f3f">SERIAL_MANAGER_WRITE_HANDLE_SIZE</a> + sizeof(uint32_t) - 1U) / sizeof(uint32_t))]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This macro is used to define a 4 byte aligned serial manager write handle. Then use "(serial_write_handle_t)name" to get the serial manager write handle.</p>
<p>The macro should be global and could be optional. You could also define serial manager write handle by yourself.</p>
<p>This is an example, </p>
<div class="fragment"><div class="line">* <a class="code" href="a00070.html#ga33eef6cd25374cbd49b00d2985b8be65">SERIAL_MANAGER_WRITE_HANDLE_DEFINE</a>(serialManagerwriteHandle);</div>
<div class="line">* </div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name string of the serial manager write handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae9206a431c26d9c557a0e32ab4d648e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SERIAL_MANAGER_READ_HANDLE_DEFINE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name</td><td>)</td>
          <td>&#160;&#160;&#160;uint32_t name[((SERIAL_MANAGER_READ_HANDLE_SIZE + sizeof(uint32_t) - 1U) / sizeof(uint32_t))]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This macro is used to define a 4 byte aligned serial manager read handle. Then use "(serial_read_handle_t)name" to get the serial manager read handle.</p>
<p>The macro should be global and could be optional. You could also define serial manager read handle by yourself.</p>
<p>This is an example, </p>
<div class="fragment"><div class="line">* <a class="code" href="a00070.html#gae9206a431c26d9c557a0e32ab4d648e8">SERIAL_MANAGER_READ_HANDLE_DEFINE</a>(serialManagerReadHandle);</div>
<div class="line">* </div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name string of the serial manager read handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9bffc03255c48dae79cc2702f0980269"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SERIAL_MANAGER_TASK_PRIORITY&#160;&#160;&#160;(2U)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga460c59805f2a8ec37e008b5a285e1760"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SERIAL_MANAGER_TASK_STACK_SIZE&#160;&#160;&#160;(1000U)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga37012d03963b0a7aac96cda088362180"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00070.html#ga37012d03963b0a7aac96cda088362180">_serial_port_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga37012d03963b0a7aac96cda088362180a8c0a9f0a39981fc49bddc88b23e170fb"></a>kSerialPort_None</em>&nbsp;</td><td class="fielddoc">
<p>Serial port is none. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga37012d03963b0a7aac96cda088362180a5b4d039d8c91cb19fca7c5dc196f8d77"></a>kSerialPort_Uart</em>&nbsp;</td><td class="fielddoc">
<p>Serial port UART. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga37012d03963b0a7aac96cda088362180a3785825f30826c61a4ef13bf983381c2"></a>kSerialPort_UsbCdc</em>&nbsp;</td><td class="fielddoc">
<p>Serial port USB CDC. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga37012d03963b0a7aac96cda088362180af6a37935b2767a9ae22825f0bc49ef77"></a>kSerialPort_Swo</em>&nbsp;</td><td class="fielddoc">
<p>Serial port SWO. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga37012d03963b0a7aac96cda088362180a1ff49cc235ba1b2cf110d9cad5121aa4"></a>kSerialPort_Virtual</em>&nbsp;</td><td class="fielddoc">
<p>Serial port Virtual. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga37012d03963b0a7aac96cda088362180aa0ec8166f72522a029c7bdb44dbd8cbe"></a>kSerialPort_Rpmsg</em>&nbsp;</td><td class="fielddoc">
<p>Serial port RPMSG. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga37012d03963b0a7aac96cda088362180acad7e31b320242ceb4088c8a32635c5e"></a>kSerialPort_UartDma</em>&nbsp;</td><td class="fielddoc">
<p>Serial port UART DMA. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga37012d03963b0a7aac96cda088362180aedeec3b53f1439f00620cadea84b0fea"></a>kSerialPort_SpiMaster</em>&nbsp;</td><td class="fielddoc">
<p>Serial port SPIMASTER. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga37012d03963b0a7aac96cda088362180a7ae48951cbd3ca0ee687468af7f0a99a"></a>kSerialPort_SpiSlave</em>&nbsp;</td><td class="fielddoc">
<p>Serial port SPISLAVE. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga37012d03963b0a7aac96cda088362180a068c303a297863ceefc8359eafc17b7f"></a>kSerialPort_BleWu</em>&nbsp;</td><td class="fielddoc">
<p>Serial port BLE WU. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga582a4193f06f2d326f72d6ec08d1cf1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00070.html#ga582a4193f06f2d326f72d6ec08d1cf1a">_serial_manager_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga582a4193f06f2d326f72d6ec08d1cf1aacae754a7dbe5f0d48d345a8b6120227c"></a>kSerialManager_NonBlocking</em>&nbsp;</td><td class="fielddoc">
<p>None blocking handle. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga582a4193f06f2d326f72d6ec08d1cf1aaa7834e61e5fcc82b73698f0465c3f24e"></a>kSerialManager_Blocking</em>&nbsp;</td><td class="fielddoc">
<p>Blocking handle. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga936dd06c6718edc81ad0423a2bb04ad8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00070.html#ga936dd06c6718edc81ad0423a2bb04ad8">_serial_manager_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga936dd06c6718edc81ad0423a2bb04ad8a1e4ed7376c48b94ec9a60f272a629ed4"></a>kStatus_SerialManager_Success</em>&nbsp;</td><td class="fielddoc">
<p>Success. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga936dd06c6718edc81ad0423a2bb04ad8a61e6a331c5f789fe88fcf2bacf8a5553"></a>kStatus_SerialManager_Error</em>&nbsp;</td><td class="fielddoc">
<p>Failed. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga936dd06c6718edc81ad0423a2bb04ad8a67e18fb1e47f4f40dc58988b76a2d876"></a>kStatus_SerialManager_Busy</em>&nbsp;</td><td class="fielddoc">
<p>Busy. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga936dd06c6718edc81ad0423a2bb04ad8abdcdea0fcd8b4c01592728a4ba041154"></a>kStatus_SerialManager_Notify</em>&nbsp;</td><td class="fielddoc">
<p>Ring buffer is not empty. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga936dd06c6718edc81ad0423a2bb04ad8af01c3a38751393325ab9791d8181ef38"></a>kStatus_SerialManager_Canceled</em>&nbsp;</td><td class="fielddoc">
<p>the non-blocking request is canceled </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga936dd06c6718edc81ad0423a2bb04ad8a9f087536c7a9930159682ed03d8d71ea"></a>kStatus_SerialManager_HandleConflict</em>&nbsp;</td><td class="fielddoc">
<p>The handle is opened. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga936dd06c6718edc81ad0423a2bb04ad8a41631953d2191b631fbe8443bfa856c8"></a>kStatus_SerialManager_RingBufferOverflow</em>&nbsp;</td><td class="fielddoc">
<p>The ring buffer is overflowed. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga936dd06c6718edc81ad0423a2bb04ad8a1e09ebaf03a4d8599170987750b17ce6"></a>kStatus_SerialManager_NotConnected</em>&nbsp;</td><td class="fielddoc">
<p>The host is not connected. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga3a3439526ad4444ea2dc535cd6f69608"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a> SerialManager_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00070.html#gaba1cc3859c4f829ee0bc6091184d4b08">serial_handle_t</a>&#160;</td>
          <td class="paramname"><em>serialHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00070.html#gaae9cb68d4f20901d9884b690d39a257a">serial_manager_config_t</a> *&#160;</td>
          <td class="paramname"><em>serialConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function configures the Serial Manager module with user-defined settings. The user can configure the configuration structure. The parameter serialHandle is a pointer to point to a memory space of size <a class="el" href="a00070.html#gabc4aa7ae83c31b66e437d7fd264aaebc" title="Definition of serial manager handle size. ">SERIAL_MANAGER_HANDLE_SIZE</a> allocated by the caller. The Serial Manager module supports three types of serial port, UART (includes UART, USART, LPSCI, LPUART, etc), USB CDC and swo. Please refer to <a class="el" href="a00070.html#gaa7dc5f93aacda72d14bb0fa66b0401f3" title="serial port type ">serial_port_type_t</a> for serial port setting. These three types can be set by using <a class="el" href="a00070.html#gaae9cb68d4f20901d9884b690d39a257a" title="serial manager config structure ">serial_manager_config_t</a>.</p>
<p>Example below shows how to use this API to configure the Serial Manager. For UART, </p>
<div class="fragment"><div class="line">*   #define SERIAL_MANAGER_RING_BUFFER_SIZE (256U)</div>
<div class="line">*   <span class="keyword">static</span> <a class="code" href="a00070.html#gad145f5877828fd4ec335f09b6790c673">SERIAL_MANAGER_HANDLE_DEFINE</a>(s_serialHandle);</div>
<div class="line">*   <span class="keyword">static</span> uint8_t s_ringBuffer[SERIAL_MANAGER_RING_BUFFER_SIZE];</div>
<div class="line">*</div>
<div class="line">*   <a class="code" href="a00070.html#a00519">serial_manager_config_t</a> config;</div>
<div class="line">*   serial_port_uart_config_t uartConfig;</div>
<div class="line">*   config.<a class="code" href="a00070.html#a2f4a4626ec722139dc792c97bca59adc">type</a> = <a class="code" href="a00070.html#gga37012d03963b0a7aac96cda088362180a5b4d039d8c91cb19fca7c5dc196f8d77">kSerialPort_Uart</a>;</div>
<div class="line">*   config.<a class="code" href="a00070.html#aab05900ee3fc3efa8b6c04fccc04e53f">ringBuffer</a> = &amp;s_ringBuffer[0];</div>
<div class="line">*   config.<a class="code" href="a00070.html#aa0050101153ca0b44e74601a3ed10fe2">ringBufferSize</a> = SERIAL_MANAGER_RING_BUFFER_SIZE;</div>
<div class="line">*   uartConfig.instance = 0;</div>
<div class="line">*   uartConfig.clockRate = 24000000;</div>
<div class="line">*   uartConfig.baudRate = 115200;</div>
<div class="line">*   uartConfig.parityMode = <a class="code" href="a00310.html#gga2d84542a7efc9d896f4e8d7221e1ec98a208958aa923a2c50ac1192a5085ab8b1">kSerialManager_UartParityDisabled</a>;</div>
<div class="line">*   uartConfig.stopBitCount = <a class="code" href="a00310.html#gga97aea0fa091f5d31407cd8b94bdc5f35a5caed34146b357a7061aaacfe378e039">kSerialManager_UartOneStopBit</a>;</div>
<div class="line">*   uartConfig.enableRx = 1;</div>
<div class="line">*   uartConfig.enableTx = 1;</div>
<div class="line">*   uartConfig.enableRxRTS = 0;</div>
<div class="line">*   uartConfig.enableTxCTS = 0;</div>
<div class="line">*   config.<a class="code" href="a00070.html#a3ca883359bc9c8977424d91cf54c867e">portConfig</a> = &amp;uartConfig;</div>
<div class="line">*   <a class="code" href="a00070.html#ga3a3439526ad4444ea2dc535cd6f69608">SerialManager_Init</a>((<a class="code" href="a00070.html#gaba1cc3859c4f829ee0bc6091184d4b08">serial_handle_t</a>)s_serialHandle, &amp;config);</div>
<div class="line">*  </div>
</div><!-- fragment --><p> For USB CDC, </p>
<div class="fragment"><div class="line">*   #define SERIAL_MANAGER_RING_BUFFER_SIZE (256U)</div>
<div class="line">*   <span class="keyword">static</span> <a class="code" href="a00070.html#gad145f5877828fd4ec335f09b6790c673">SERIAL_MANAGER_HANDLE_DEFINE</a>(s_serialHandle);</div>
<div class="line">*   <span class="keyword">static</span> uint8_t s_ringBuffer[SERIAL_MANAGER_RING_BUFFER_SIZE];</div>
<div class="line">*</div>
<div class="line">*   <a class="code" href="a00070.html#a00519">serial_manager_config_t</a> config;</div>
<div class="line">*   <a class="code" href="a00072.html#a00521">serial_port_usb_cdc_config_t</a> usbCdcConfig;</div>
<div class="line">*   config.<a class="code" href="a00070.html#a2f4a4626ec722139dc792c97bca59adc">type</a> = <a class="code" href="a00070.html#gga37012d03963b0a7aac96cda088362180a3785825f30826c61a4ef13bf983381c2">kSerialPort_UsbCdc</a>;</div>
<div class="line">*   config.<a class="code" href="a00070.html#aab05900ee3fc3efa8b6c04fccc04e53f">ringBuffer</a> = &amp;s_ringBuffer[0];</div>
<div class="line">*   config.<a class="code" href="a00070.html#aa0050101153ca0b44e74601a3ed10fe2">ringBufferSize</a> = SERIAL_MANAGER_RING_BUFFER_SIZE;</div>
<div class="line">*   usbCdcConfig.<a class="code" href="a00072.html#a14bbabeb7c5689a76a6a9fde038406cb">controllerIndex</a> = <a class="code" href="a00072.html#gga655b3e8c0c8f2b005fda4d47e4f48c3daba414efbedc13dd6605fdc76daee832f">kSerialManager_UsbControllerKhci0</a>;</div>
<div class="line">*   config.<a class="code" href="a00070.html#a3ca883359bc9c8977424d91cf54c867e">portConfig</a> = &amp;usbCdcConfig;</div>
<div class="line">*   <a class="code" href="a00070.html#ga3a3439526ad4444ea2dc535cd6f69608">SerialManager_Init</a>((<a class="code" href="a00070.html#gaba1cc3859c4f829ee0bc6091184d4b08">serial_handle_t</a>)s_serialHandle, &amp;config);</div>
<div class="line">*  </div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serialHandle</td><td>Pointer to point to a memory space of size <a class="el" href="a00070.html#gabc4aa7ae83c31b66e437d7fd264aaebc" title="Definition of serial manager handle size. ">SERIAL_MANAGER_HANDLE_SIZE</a> allocated by the caller. The handle should be 4 byte aligned, because unaligned access doesn't be supported on some devices. You can define the handle in the following two ways: <a class="el" href="a00070.html#gad145f5877828fd4ec335f09b6790c673" title="Defines the serial manager handle. ">SERIAL_MANAGER_HANDLE_DEFINE(serialHandle)</a>; or uint32_t serialHandle[((SERIAL_MANAGER_HANDLE_SIZE + sizeof(uint32_t) - 1U) / sizeof(uint32_t))]; </td></tr>
    <tr><td class="paramname">serialConfig</td><td>Pointer to user-defined configuration structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_SerialManager_Error</td><td>An error occurred. </td></tr>
    <tr><td class="paramname">kStatus_SerialManager_Success</td><td>The Serial Manager module initialization succeed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga467c8a817003eacd48f86aaef1ce8306"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a> SerialManager_Deinit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00070.html#gaba1cc3859c4f829ee0bc6091184d4b08">serial_handle_t</a>&#160;</td>
          <td class="paramname"><em>serialHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function de-initializes the serial manager module instance. If the opened writing or reading handle is not closed, the function will return kStatus_SerialManager_Busy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serialHandle</td><td>The serial manager module handle pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_SerialManager_Success</td><td>The serial manager de-initialization succeed. </td></tr>
    <tr><td class="paramname">kStatus_SerialManager_Busy</td><td>Opened reading or writing handle is not closed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3d26249a8331e6ca17e9c60838b56d20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a> SerialManager_OpenWriteHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00070.html#gaba1cc3859c4f829ee0bc6091184d4b08">serial_handle_t</a>&#160;</td>
          <td class="paramname"><em>serialHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00070.html#gac8319b6189019680778f230eb319530e">serial_write_handle_t</a>&#160;</td>
          <td class="paramname"><em>writeHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function Opens a writing handle for the serial manager module. If the serial manager needs to be used in different tasks, the task should open a dedicated write handle for itself by calling <a class="el" href="a00070.html#ga3d26249a8331e6ca17e9c60838b56d20" title="Opens a writing handle for the serial manager module. ">SerialManager_OpenWriteHandle</a>. Since there can only one buffer for transmission for the writing handle at the same time, multiple writing handles need to be opened when the multiple transmission is needed for a task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serialHandle</td><td>The serial manager module handle pointer. The handle should be 4 byte aligned, because unaligned access doesn't be supported on some devices. </td></tr>
    <tr><td class="paramname">writeHandle</td><td>The serial manager module writing handle pointer. The handle should be 4 byte aligned, because unaligned access doesn't be supported on some devices. You can define the handle in the following two ways: <a class="el" href="a00070.html#ga33eef6cd25374cbd49b00d2985b8be65" title="Defines the serial manager write handle. ">SERIAL_MANAGER_WRITE_HANDLE_DEFINE(writeHandle)</a>; or uint32_t writeHandle[((SERIAL_MANAGER_WRITE_HANDLE_SIZE + sizeof(uint32_t) - 1U) / sizeof(uint32_t))]; </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_SerialManager_Error</td><td>An error occurred. </td></tr>
    <tr><td class="paramname">kStatus_SerialManager_HandleConflict</td><td>The writing handle was opened. </td></tr>
    <tr><td class="paramname">kStatus_SerialManager_Success</td><td>The writing handle is opened.</td></tr>
  </table>
  </dd>
</dl>
<p>Example below shows how to use this API to write data. For task 1, </p>
<div class="fragment"><div class="line">*   <span class="keyword">static</span> <a class="code" href="a00070.html#ga33eef6cd25374cbd49b00d2985b8be65">SERIAL_MANAGER_WRITE_HANDLE_DEFINE</a>(s_serialWriteHandle1);</div>
<div class="line">*   <span class="keyword">static</span> uint8_t s_nonBlockingWelcome1[] = <span class="stringliteral">&quot;This is non-blocking writing log for task1!\r\n&quot;</span>;</div>
<div class="line">*   <a class="code" href="a00070.html#ga3d26249a8331e6ca17e9c60838b56d20">SerialManager_OpenWriteHandle</a>((<a class="code" href="a00070.html#gaba1cc3859c4f829ee0bc6091184d4b08">serial_handle_t</a>)serialHandle, (<a class="code" href="a00070.html#gac8319b6189019680778f230eb319530e">serial_write_handle_t</a>)s_serialWriteHandle1);</div>
<div class="line">*   <a class="code" href="a00070.html#ga59eadfa140fe4cb42b306514a02288d4">SerialManager_InstallTxCallback</a>((<a class="code" href="a00070.html#gac8319b6189019680778f230eb319530e">serial_write_handle_t</a>)s_serialWriteHandle1,</div>
<div class="line">*                                    Task1_SerialManagerTxCallback,</div>
<div class="line">*                                    s_serialWriteHandle1);</div>
<div class="line">*   <a class="code" href="a00070.html#ga195f1c0ebf9a66952302003d25a50e6b">SerialManager_WriteNonBlocking</a>((<a class="code" href="a00070.html#gac8319b6189019680778f230eb319530e">serial_write_handle_t</a>)s_serialWriteHandle1,</div>
<div class="line">*                                   s_nonBlockingWelcome1,</div>
<div class="line">*                                   <span class="keyword">sizeof</span>(s_nonBlockingWelcome1) - 1U);</div>
<div class="line">*  </div>
</div><!-- fragment --><p> For task 2, </p>
<div class="fragment"><div class="line">*   <span class="keyword">static</span> <a class="code" href="a00070.html#ga33eef6cd25374cbd49b00d2985b8be65">SERIAL_MANAGER_WRITE_HANDLE_DEFINE</a>(s_serialWriteHandle2);</div>
<div class="line">*   <span class="keyword">static</span> uint8_t s_nonBlockingWelcome2[] = <span class="stringliteral">&quot;This is non-blocking writing log for task2!\r\n&quot;</span>;</div>
<div class="line">*   <a class="code" href="a00070.html#ga3d26249a8331e6ca17e9c60838b56d20">SerialManager_OpenWriteHandle</a>((<a class="code" href="a00070.html#gaba1cc3859c4f829ee0bc6091184d4b08">serial_handle_t</a>)serialHandle, (<a class="code" href="a00070.html#gac8319b6189019680778f230eb319530e">serial_write_handle_t</a>)s_serialWriteHandle2);</div>
<div class="line">*   <a class="code" href="a00070.html#ga59eadfa140fe4cb42b306514a02288d4">SerialManager_InstallTxCallback</a>((<a class="code" href="a00070.html#gac8319b6189019680778f230eb319530e">serial_write_handle_t</a>)s_serialWriteHandle2,</div>
<div class="line">*                                    Task2_SerialManagerTxCallback,</div>
<div class="line">*                                    s_serialWriteHandle2);</div>
<div class="line">*   <a class="code" href="a00070.html#ga195f1c0ebf9a66952302003d25a50e6b">SerialManager_WriteNonBlocking</a>((<a class="code" href="a00070.html#gac8319b6189019680778f230eb319530e">serial_write_handle_t</a>)s_serialWriteHandle2,</div>
<div class="line">*                                   s_nonBlockingWelcome2,</div>
<div class="line">*                                   <span class="keyword">sizeof</span>(s_nonBlockingWelcome2) - 1U);</div>
<div class="line">*  </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gadb8df1d54da32e6de17680264ca4106a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a> SerialManager_CloseWriteHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00070.html#gac8319b6189019680778f230eb319530e">serial_write_handle_t</a>&#160;</td>
          <td class="paramname"><em>writeHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function Closes a writing handle for the serial manager module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">writeHandle</td><td>The serial manager module writing handle pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_SerialManager_Success</td><td>The writing handle is closed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga66915bf8f50a417620ef94951d1df4b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a> SerialManager_OpenReadHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00070.html#gaba1cc3859c4f829ee0bc6091184d4b08">serial_handle_t</a>&#160;</td>
          <td class="paramname"><em>serialHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00070.html#ga8bfec9c49e40728806d775fdb4bbf78e">serial_read_handle_t</a>&#160;</td>
          <td class="paramname"><em>readHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function Opens a reading handle for the serial manager module. The reading handle can not be opened multiple at the same time. The error code kStatus_SerialManager_Busy would be returned when the previous reading handle is not closed. And there can only be one buffer for receiving for the reading handle at the same time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serialHandle</td><td>The serial manager module handle pointer. The handle should be 4 byte aligned, because unaligned access doesn't be supported on some devices. </td></tr>
    <tr><td class="paramname">readHandle</td><td>The serial manager module reading handle pointer. The handle should be 4 byte aligned, because unaligned access doesn't be supported on some devices. You can define the handle in the following two ways: <a class="el" href="a00070.html#gae9206a431c26d9c557a0e32ab4d648e8" title="Defines the serial manager read handle. ">SERIAL_MANAGER_READ_HANDLE_DEFINE(readHandle)</a>; or uint32_t readHandle[((SERIAL_MANAGER_READ_HANDLE_SIZE + sizeof(uint32_t) - 1U) / sizeof(uint32_t))]; </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_SerialManager_Error</td><td>An error occurred. </td></tr>
    <tr><td class="paramname">kStatus_SerialManager_Success</td><td>The reading handle is opened. </td></tr>
    <tr><td class="paramname">kStatus_SerialManager_Busy</td><td>Previous reading handle is not closed.</td></tr>
  </table>
  </dd>
</dl>
<p>Example below shows how to use this API to read data. </p>
<div class="fragment"><div class="line">*   <span class="keyword">static</span> <a class="code" href="a00070.html#gae9206a431c26d9c557a0e32ab4d648e8">SERIAL_MANAGER_READ_HANDLE_DEFINE</a>(s_serialReadHandle);</div>
<div class="line">*   <a class="code" href="a00070.html#ga66915bf8f50a417620ef94951d1df4b8">SerialManager_OpenReadHandle</a>((<a class="code" href="a00070.html#gaba1cc3859c4f829ee0bc6091184d4b08">serial_handle_t</a>)serialHandle, (<a class="code" href="a00070.html#ga8bfec9c49e40728806d775fdb4bbf78e">serial_read_handle_t</a>)s_serialReadHandle);</div>
<div class="line">*   <span class="keyword">static</span> uint8_t s_nonBlockingBuffer[64];</div>
<div class="line">*   <a class="code" href="a00070.html#gab8a8947d239858adf3626fe937ccda56">SerialManager_InstallRxCallback</a>((<a class="code" href="a00070.html#ga8bfec9c49e40728806d775fdb4bbf78e">serial_read_handle_t</a>)s_serialReadHandle,</div>
<div class="line">*                                    APP_SerialManagerRxCallback,</div>
<div class="line">*                                    s_serialReadHandle);</div>
<div class="line">*   <a class="code" href="a00070.html#ga73b6a8e57790ee4d41476ef25488c495">SerialManager_ReadNonBlocking</a>((<a class="code" href="a00070.html#ga8bfec9c49e40728806d775fdb4bbf78e">serial_read_handle_t</a>)s_serialReadHandle,</div>
<div class="line">*                                  s_nonBlockingBuffer,</div>
<div class="line">*                                  <span class="keyword">sizeof</span>(s_nonBlockingBuffer));</div>
<div class="line">*  </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga09c8831eb6ca6e544881dcbf18dcb4a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a> SerialManager_CloseReadHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00070.html#ga8bfec9c49e40728806d775fdb4bbf78e">serial_read_handle_t</a>&#160;</td>
          <td class="paramname"><em>readHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function Closes a reading for the serial manager module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">readHandle</td><td>The serial manager module reading handle pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_SerialManager_Success</td><td>The reading handle is closed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3fab1d6bffd89459be9f23d40874248e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a> SerialManager_WriteBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00070.html#gac8319b6189019680778f230eb319530e">serial_write_handle_t</a>&#160;</td>
          <td class="paramname"><em>writeHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a blocking function, which polls the sending queue, waits for the sending queue to be empty. This function sends data using an interrupt method. The interrupt of the hardware could not be disabled. And There can only one buffer for transmission for the writing handle at the same time.</p>
<dl class="section note"><dt>Note</dt><dd>The function <a class="el" href="a00070.html#ga3fab1d6bffd89459be9f23d40874248e" title="Transmits data with the blocking mode. ">SerialManager_WriteBlocking</a> and the function SerialManager_WriteNonBlocking cannot be used at the same time. And, the function SerialManager_CancelWriting cannot be used to abort the transmission of this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">writeHandle</td><td>The serial manager module handle pointer. </td></tr>
    <tr><td class="paramname">buffer</td><td>Start address of the data to write. </td></tr>
    <tr><td class="paramname">length</td><td>Length of the data to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_SerialManager_Success</td><td>Successfully sent all data. </td></tr>
    <tr><td class="paramname">kStatus_SerialManager_Busy</td><td>Previous transmission still not finished; data not all sent yet. </td></tr>
    <tr><td class="paramname">kStatus_SerialManager_Error</td><td>An error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga03b1bb5c3dbaa5ea2f0a6e7003f0b4eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a> SerialManager_ReadBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00070.html#ga8bfec9c49e40728806d775fdb4bbf78e">serial_read_handle_t</a>&#160;</td>
          <td class="paramname"><em>readHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a blocking function, which polls the receiving buffer, waits for the receiving buffer to be full. This function receives data using an interrupt method. The interrupt of the hardware could not be disabled. And There can only one buffer for receiving for the reading handle at the same time.</p>
<dl class="section note"><dt>Note</dt><dd>The function <a class="el" href="a00070.html#ga03b1bb5c3dbaa5ea2f0a6e7003f0b4eb" title="Reads data with the blocking mode. ">SerialManager_ReadBlocking</a> and the function SerialManager_ReadNonBlocking cannot be used at the same time. And, the function SerialManager_CancelReading cannot be used to abort the transmission of this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">readHandle</td><td>The serial manager module handle pointer. </td></tr>
    <tr><td class="paramname">buffer</td><td>Start address of the data to store the received data. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the data to be received. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_SerialManager_Success</td><td>Successfully received all data. </td></tr>
    <tr><td class="paramname">kStatus_SerialManager_Busy</td><td>Previous transmission still not finished; data not all received yet. </td></tr>
    <tr><td class="paramname">kStatus_SerialManager_Error</td><td>An error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga195f1c0ebf9a66952302003d25a50e6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a> SerialManager_WriteNonBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00070.html#gac8319b6189019680778f230eb319530e">serial_write_handle_t</a>&#160;</td>
          <td class="paramname"><em>writeHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a non-blocking function, which returns directly without waiting for all data to be sent. When all data is sent, the module notifies the upper layer through a TX callback function and passes the status parameter <a class="el" href="a00070.html#gga936dd06c6718edc81ad0423a2bb04ad8a1e4ed7376c48b94ec9a60f272a629ed4">kStatus_SerialManager_Success</a>. This function sends data using an interrupt method. The interrupt of the hardware could not be disabled. And There can only one buffer for transmission for the writing handle at the same time.</p>
<dl class="section note"><dt>Note</dt><dd>The function <a class="el" href="a00070.html#ga3fab1d6bffd89459be9f23d40874248e" title="Transmits data with the blocking mode. ">SerialManager_WriteBlocking</a> and the function <a class="el" href="a00070.html#ga195f1c0ebf9a66952302003d25a50e6b" title="Transmits data with the non-blocking mode. ">SerialManager_WriteNonBlocking</a> cannot be used at the same time. And, the TX callback is mandatory before the function could be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">writeHandle</td><td>The serial manager module handle pointer. </td></tr>
    <tr><td class="paramname">buffer</td><td>Start address of the data to write. </td></tr>
    <tr><td class="paramname">length</td><td>Length of the data to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_SerialManager_Success</td><td>Successfully sent all data. </td></tr>
    <tr><td class="paramname">kStatus_SerialManager_Busy</td><td>Previous transmission still not finished; data not all sent yet. </td></tr>
    <tr><td class="paramname">kStatus_SerialManager_Error</td><td>An error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga73b6a8e57790ee4d41476ef25488c495"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a> SerialManager_ReadNonBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00070.html#ga8bfec9c49e40728806d775fdb4bbf78e">serial_read_handle_t</a>&#160;</td>
          <td class="paramname"><em>readHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a non-blocking function, which returns directly without waiting for all data to be received. When all data is received, the module driver notifies the upper layer through a RX callback function and passes the status parameter <a class="el" href="a00070.html#gga936dd06c6718edc81ad0423a2bb04ad8a1e4ed7376c48b94ec9a60f272a629ed4">kStatus_SerialManager_Success</a>. This function receives data using an interrupt method. The interrupt of the hardware could not be disabled. And There can only one buffer for receiving for the reading handle at the same time.</p>
<dl class="section note"><dt>Note</dt><dd>The function <a class="el" href="a00070.html#ga03b1bb5c3dbaa5ea2f0a6e7003f0b4eb" title="Reads data with the blocking mode. ">SerialManager_ReadBlocking</a> and the function <a class="el" href="a00070.html#ga73b6a8e57790ee4d41476ef25488c495" title="Reads data with the non-blocking mode. ">SerialManager_ReadNonBlocking</a> cannot be used at the same time. And, the RX callback is mandatory before the function could be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">readHandle</td><td>The serial manager module handle pointer. </td></tr>
    <tr><td class="paramname">buffer</td><td>Start address of the data to store the received data. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the data to be received. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_SerialManager_Success</td><td>Successfully received all data. </td></tr>
    <tr><td class="paramname">kStatus_SerialManager_Busy</td><td>Previous transmission still not finished; data not all received yet. </td></tr>
    <tr><td class="paramname">kStatus_SerialManager_Error</td><td>An error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3f0a934ae5f1e8c20caff894f94bc70e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a> SerialManager_TryRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00070.html#ga8bfec9c49e40728806d775fdb4bbf78e">serial_read_handle_t</a>&#160;</td>
          <td class="paramname"><em>readHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>receivedLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function tries to read data from internal ring buffer. If the ring buffer is not empty, the data will be copied from ring buffer to up layer buffer. The copied length is the minimum of the ring buffer and up layer length. After the data is copied, the actual data length is passed by the parameter length. And There can only one buffer for receiving for the reading handle at the same time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">readHandle</td><td>The serial manager module handle pointer. </td></tr>
    <tr><td class="paramname">buffer</td><td>Start address of the data to store the received data. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the data to be received. </td></tr>
    <tr><td class="paramname">receivedLength</td><td>Length received from the ring buffer directly. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_SerialManager_Success</td><td>Successfully received all data. </td></tr>
    <tr><td class="paramname">kStatus_SerialManager_Busy</td><td>Previous transmission still not finished; data not all received yet. </td></tr>
    <tr><td class="paramname">kStatus_SerialManager_Error</td><td>An error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga54a5b67dbaed110666666e24469fad13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a> SerialManager_CancelWriting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00070.html#gac8319b6189019680778f230eb319530e">serial_write_handle_t</a>&#160;</td>
          <td class="paramname"><em>writeHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function cancels unfinished send transmission. When the transfer is canceled, the module notifies the upper layer through a TX callback function and passes the status parameter <a class="el" href="a00070.html#gga936dd06c6718edc81ad0423a2bb04ad8af01c3a38751393325ab9791d8181ef38">kStatus_SerialManager_Canceled</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The function <a class="el" href="a00070.html#ga54a5b67dbaed110666666e24469fad13" title="Cancels unfinished send transmission. ">SerialManager_CancelWriting</a> cannot be used to abort the transmission of the function <a class="el" href="a00070.html#ga3fab1d6bffd89459be9f23d40874248e" title="Transmits data with the blocking mode. ">SerialManager_WriteBlocking</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">writeHandle</td><td>The serial manager module handle pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_SerialManager_Success</td><td>Get successfully abort the sending. </td></tr>
    <tr><td class="paramname">kStatus_SerialManager_Error</td><td>An error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7cb009a3fcc17375bfa591b68008c94e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a> SerialManager_CancelReading </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00070.html#ga8bfec9c49e40728806d775fdb4bbf78e">serial_read_handle_t</a>&#160;</td>
          <td class="paramname"><em>readHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function cancels unfinished receive transmission. When the transfer is canceled, the module notifies the upper layer through a RX callback function and passes the status parameter <a class="el" href="a00070.html#gga936dd06c6718edc81ad0423a2bb04ad8af01c3a38751393325ab9791d8181ef38">kStatus_SerialManager_Canceled</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The function <a class="el" href="a00070.html#ga7cb009a3fcc17375bfa591b68008c94e" title="Cancels unfinished receive transmission. ">SerialManager_CancelReading</a> cannot be used to abort the transmission of the function <a class="el" href="a00070.html#ga03b1bb5c3dbaa5ea2f0a6e7003f0b4eb" title="Reads data with the blocking mode. ">SerialManager_ReadBlocking</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">readHandle</td><td>The serial manager module handle pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_SerialManager_Success</td><td>Get successfully abort the receiving. </td></tr>
    <tr><td class="paramname">kStatus_SerialManager_Error</td><td>An error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga59eadfa140fe4cb42b306514a02288d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a> SerialManager_InstallTxCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00070.html#gac8319b6189019680778f230eb319530e">serial_write_handle_t</a>&#160;</td>
          <td class="paramname"><em>writeHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00070.html#gabe6a6263bb1570ea715938b2420af773">serial_manager_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to install the TX callback and callback parameter for the serial manager module. When any status of TX transmission changed, the driver will notify the upper layer by the installed callback function. And the status is also passed as status parameter when the callback is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">writeHandle</td><td>The serial manager module handle pointer. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback function. </td></tr>
    <tr><td class="paramname">callbackParam</td><td>The parameter of the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_SerialManager_Success</td><td>Successfully install the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab8a8947d239858adf3626fe937ccda56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a> SerialManager_InstallRxCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00070.html#ga8bfec9c49e40728806d775fdb4bbf78e">serial_read_handle_t</a>&#160;</td>
          <td class="paramname"><em>readHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00070.html#gabe6a6263bb1570ea715938b2420af773">serial_manager_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to install the RX callback and callback parameter for the serial manager module. When any status of RX transmission changed, the driver will notify the upper layer by the installed callback function. And the status is also passed as status parameter when the callback is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">readHandle</td><td>The serial manager module handle pointer. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback function. </td></tr>
    <tr><td class="paramname">callbackParam</td><td>The parameter of the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_SerialManager_Success</td><td>Successfully install the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga26a6c26eacf1277930e69676ab77cbec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool SerialManager_needPollingIsr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is used to check if need polling ISR.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if need polling. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga32cdccd6df5d87f17037f34cf9f1e416"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a> SerialManager_EnterLowpower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00070.html#gaba1cc3859c4f829ee0bc6091184d4b08">serial_handle_t</a>&#160;</td>
          <td class="paramname"><em>serialHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to prepare to enter low power consumption.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serialHandle</td><td>The serial manager module handle pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_SerialManager_Success</td><td>Successful operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaef5c404d43871f6d8f761b27dbf183fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html#gac1d9f848c57ca245ad9da8d049369da9">serial_manager_status_t</a> SerialManager_ExitLowpower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00070.html#gaba1cc3859c4f829ee0bc6091184d4b08">serial_handle_t</a>&#160;</td>
          <td class="paramname"><em>serialHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to restore from low power consumption.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serialHandle</td><td>The serial manager module handle pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_SerialManager_Success</td><td>Successful operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga71bd55adb7a6a552ce5dac06b5794cea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SerialManager_SetLowpowerCriticalCb </td>
          <td>(</td>
          <td class="paramtype">const serial_manager_lowpower_critical_CBs_t *&#160;</td>
          <td class="paramname"><em>pfCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfCallback</td><td>Pointer to the function structure used to allow/disable lowpower. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul class="foot">
    <li class="footer">&copy; 2016 NXP Semiconductors. All rights reserved.
    </li>
  </ul>
</div>
</body>
</html>
