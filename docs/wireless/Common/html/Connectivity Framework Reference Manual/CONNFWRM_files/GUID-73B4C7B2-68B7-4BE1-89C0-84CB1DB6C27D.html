<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en-us" lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2005"/>
<meta name="DC.rights.owner" content="(C) Copyright 2005"/>
<meta name="DC.Type" content="topic"/>
<meta name="DC.Title" content="Deep sleep mode 8"/>
<meta name="DC.Relation" scheme="URI" content="GUID-CE2F9CC6-8F36-459B-BA30-27DF49158879.html"/>
<meta name="prodname" content=""/>
<meta name="version" content="1"/>
<meta name="release" content="0"/>
<meta name="modification" content="0"/>
<meta name="DC.Creator" content="NXP Semiconductors"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-73B4C7B2-68B7-4BE1-89C0-84CB1DB6C27D"/>
<meta name="DC.Language" content="en-us"/>
<link rel="stylesheet" type="text/css" href="commonltr.css"/>
<title>Deep sleep mode 8</title>
</head>
<body id="GUID-73B4C7B2-68B7-4BE1-89C0-84CB1DB6C27D">


    <h1 class="title topictitle1">Deep sleep mode 8</h1>

    <div class="body">
        <p class="p">This low-power mode is similar with the low-power mode 1. The main difference is that the
            MCU enters VLLS2 or VLLS3, depending on the amount of RAM preserved configured by the
                <em class="ph i">cPWR_RamRetentionInVLLS</em> define.</p>

        <p class="p">Also, this low-power mode is intended to be used with a warm-boot sequence, to skip over
            the data initialization since the RAM is retained.</p>

        <p class="p">The SoC wakes up from this mode by the on-board switches, by LPTMR timeout, or by BLE
            Link Layer wakeup interrupt (BLE_LL reference clock reaches wake up instance register)
            using LLWU module. The LPTMR timer is used to measure the time that the MCU spends in
            deep sleep to synchronize low-power timers at wakeup .</p>
<p class="p"><strong class="ph b">Warm boot support</strong>
        </p>

        <div class="p">When the warm-boot is enabled, the application data, BLE stack data, Connectivity
            Framework is retained in RAM. Also, BLE LL and XCVR are in state retention in VLLS2/3,
            so no re-initialization is required. However, MCU general registers and peripherals that
            are not in state retention need to be restored. To achieve this, the application must
            implement the following callbacks that the Low Power Manager module will call at low
            power entry and low power exit: 
        <ol class="ol">
            <li class="li"> At VLLS entry to save application specific
                        context.<pre class="pre codeblock">void PWR_RegisterVLLSEnterCallback(pfPWRCallBack_t vllsEnterCallback);</pre>
<div class="p">
                        In the application provided as example it saves:<ul class="ul">
                            <li class="li">VTOR </li>

                            <li class="li">NVIC interrupt configuration </li>

                            <li class="li">System clock gating control registers for enabled peripherals </li>

                            <li class="li">System Tick</li>

                        </ul>
</div>

                </li>

         <li class="li"> At warm boot to restore the application entry context and re-init
                    modules.<pre class="pre codeblock">void PWR_RegisterWarmbootCallback(pfPWRCallBack_t warmBootCallback);</pre>

                    It restores everything that was saved in the VLLS entry callback and re-inits:
                        <ul class="ul" id="GUID-73B4C7B2-68B7-4BE1-89C0-84CB1DB6C27D__UL_QNP_STG_C3B">
                        <li class="li"> DCDC </li>

                        <li class="li">Stack Timer </li>

                        <li class="li">Switches  </li>

                    </ul>
</li>

      
        </ol>
</div>

        <div class="p">The Low Power Manager in the connectivity framework will handle the rest of the
            support:<ul class="ul">
        <li class="li">At VLLS2/3 entry in the LPM module, the CPU context is saved using setjmp.</li>

        <li class="li">Startup sequence has been modified to skip over data initialization and execute a warm
                    boot instead of normal boot at VLLS exit.</li>

        <li class="li">Warm main executes the application callback on a dedicated warm boot stack.</li>

        <li class="li">It then restores the CPU context with longjmp and execution is resumed.</li>
</ul>
</div>

    
        <p class="p">The CPU start-up code was updated to check if this Reset is caused by a wake-up from
            VLLS2 or VLLS3 and if the warm-boot sequence is enabled (WARMBOOT_SEQUENCE =
            WARMBOOT_CONFIG stored), the program will skip over the RAM data initialization since it
            is preserved, and call warmmain().  </p>

        <p class="p">The warmmain() function will use a dedicated stack by default. The warm-boot stack should
            be in a RAM region which is not preserved in VLLS2 and has a default size of 1 KB.</p>

        <p class="p">The warm-boot config region must be located after the RAM vector table, at a location
            which is always preserved in VLLS2, and needs 8 bytes allocated.  </p>

        <p class="p">When the warm-bsoot is enabled, the application stack is placed immediately after the
            program data, to be preserved in VLLS2. </p>

        <p class="p">By default, the Low Power Module will enable the warm-boot sequence with a dedicated
            stack (USE_WARMBOOT_SP=1) when low power modes 5 or 8 are enabled. </p>

        <div class="p">To enable the warm-boot config and stack for IAR IDE in linker file, the
            "gUseWarmBootLink_d=1" symbol must be added to the project linker configuration. The
            stack size value can be configured using the "__warmboot_stack_size__" linker symbol.
            <div class="fig fignone" id="GUID-73B4C7B2-68B7-4BE1-89C0-84CB1DB6C27D__FIG_QQF_G5G_C3B"><img class="image" src="GUID-88A54413-4132-4B7D-AD33-6A293A09B1F8-high.png"/></div>
 To enable warm-boot config and stack for MCUX, the
            WARMBOOT_CONFIG and WARMBOOT_STACK memory regions must be added in the memory config of
            the MCU settings.<div class="fig fignone" id="GUID-73B4C7B2-68B7-4BE1-89C0-84CB1DB6C27D__FIG_LRF_G5G_C3B"><img class="image" src="GUID-FC9DB31F-C917-4D71-A0DC-65A4AE846DC8-high.png"/></div>
<strong class="ph b">RTOS Support for Warm Boot</strong></div>

        <p class="p">The warm-boot support is also available for FreeRTOS. In this case there is no need for a
            dedicated warm-boot stack (USE_WARMBOOT_SP=0), since the main stack (MSP) which is used
            by the interrupts is separated from the process stack (PSP) and can be used instead.</p>

    </div>

<div class="related-links">
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="GUID-CE2F9CC6-8F36-459B-BA30-27DF49158879.html">Deep sleep modes</a></div>
</div>
</div>

</body>
</html>