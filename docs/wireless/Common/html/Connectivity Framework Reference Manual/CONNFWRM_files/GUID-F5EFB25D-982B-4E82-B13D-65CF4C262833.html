<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en-us" lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2005"/>
<meta name="DC.rights.owner" content="(C) Copyright 2005"/>
<meta name="DC.Type" content="topic"/>
<meta name="DC.Title" content="Flash Management and Non-Volatile Storage Module API primitives"/>
<meta name="DC.Relation" scheme="URI" content="GUID-0E23C916-82C8-415A-8469-773251C6D3F3.html"/>
<meta name="prodname" content=""/>
<meta name="version" content="1"/>
<meta name="release" content="0"/>
<meta name="modification" content="0"/>
<meta name="DC.Creator" content="NXP Semiconductors"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833"/>
<meta name="DC.Language" content="en-us"/>
<link rel="stylesheet" type="text/css" href="commonltr.css"/>
<title>Flash Management and Non-Volatile Storage Module API primitives</title>
</head>
<body id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833">


	<h1 class="title topictitle1">Flash Management and Non-Volatile Storage Module API primitives</h1>

	<div class="body">
		<p class="p"><strong class="ph b"><span class="ph" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833___TOC346017098">NvModuleInit</span></strong></p>

		<p class="p"><strong class="ph b">Prototype:</strong></p>

		<pre class="pre codeblock">NVM_Status_t NvModuleInit
(
    void
);</pre>

		<p class="p"><strong class="ph b">Description:</strong></p>

		<p class="p">This function is used to initialize the Flash Management and Non-Volatile Storage Module. It indirectly initializes the flash HAL driver and gets the active page ID. It initializes internal state variables and counters. If the RAM entries are different from flash entries, a page copy is triggered and the different entries are skipped in the process. It also handles NVM table changes. For example, the MCU program was changed and the NVM table was updated by automaticly doing a table upgrade. To trigger this behavior, the application must change gNvFlashTableVersion_c.</p>

		<p class="p"><strong class="ph b">Parameters:</strong></p>

		<p class="p">None.</p>

		<p class="p"><strong class="ph b">Returns:</strong></p>

		<p class="p">The status of the initialization:</p>

		<pre class="pre codeblock">gNVM_OK_c
gNVM_FormatFailure_c
gNVM_ModuleAlreadyInitialized_c
gNVM_InvalidSectorsCount_c
gNVM_NvWrongFlashDataIFRMap_c
gNVM_MissingEndOfTableMarker_c</pre>

		<p class="p"><strong class="ph b"><span class="ph" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833___TOC346017100">NvSaveOnIdle</span></strong></p>

		<p class="p"><strong class="ph b">Prototype:</strong></p>

		<pre class="pre codeblock">NVM_Status_t NvSaveOnIdle
(
    void* ptrData,
    bool_t saveAll
);</pre>

		<p class="p"> </p>

		<p class="p"><strong class="ph b">Description:</strong></p>

		<p class="p">This function saves the element or the entire NV table entry (dataset) pointed to by the ptrData argument, as soon as the NvIdle() function is called. If ptrData belongs to an unmirrored dataset, after the save the RAM pointer is freed and pData points to the flash backup. No other saves can be made while the data is in flash.</p>

		<p class="p"><strong class="ph b">Parameters:</strong></p>

		
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833__TABLE_TXN_SJM_2Z" class="table" frame="border" border="1" rules="all">
				
				
				
				
				<thead class="thead" align="left">
					<tr class="row">
						<th class="entry" valign="top" id="d78191e118"><strong class="ph b">Name</strong></th>

						<th class="entry" valign="top" id="d78191e122"><strong class="ph b">Type</strong></th>

						<th class="entry" valign="top" id="d78191e126"><strong class="ph b">Direction</strong></th>

						<th class="entry" valign="top" id="d78191e130"><strong class="ph b">Description</strong></th>

					</tr>

				</thead>

				<tbody class="tbody">
					<tr class="row">
						<td class="entry" valign="top" headers="d78191e118 ">ptrData</td>

						<td class="entry" valign="top" headers="d78191e122 ">void*</td>

						<td class="entry" valign="top" headers="d78191e126 ">IN</td>

						<td class="entry" valign="top" headers="d78191e130 ">A pointer to the element or the table entry to be saved</td>

					</tr>

					<tr class="row">
						<td class="entry" valign="top" headers="d78191e118 ">saveAll</td>

						<td class="entry" valign="top" headers="d78191e122 ">bool_t</td>

						<td class="entry" valign="top" headers="d78191e126 ">IN</td>

						<td class="entry" valign="top" headers="d78191e130 ">A flag used to specify, whether the entire table entry is saved, or just the element pointed to by ptrData</td>

					</tr>

				</tbody>

			</table>
</div>

		<p class="p"><strong class="ph b">Returns:</strong></p>

		<p class="p">One of the following: </p>

		<pre class="pre codeblock">gNVM_OK_c 
gNVM_ModuleNotInitialized_c
gNVM_NullPointer_c
gNVM_InvalidTableEntry_c
gNVM_SaveRequestRejected_c</pre>

		<p class="p"><strong class="ph b">NvSaveOnInterval</strong></p>

		<p class="p"><strong class="ph b">Prototype:</strong></p>

		<pre class="pre codeblock">NVM_Status_t NvSaveOnInterval
(
    void* ptrData
);</pre>

		<p class="p"><strong class="ph b">Description:</strong></p>

		<p class="p">This function saves the specified dataset no more often than at a given time interval. If it has been at least that long since the last save, this function causes a save as soon as the NvIdle() function is called. If ptrData belongs to an unmirrored dataset, after the save the RAM pointer is freed and pData points to the flash backup. No other saves can be made while the data is in flash. If ptrData belongs to a mirrored dataset, a full save is made. Otherwise, only the element indicated by the ptrData is saved. If the function is called before a previous save on interval was processed, the call is ignored.</p>

		<p class="p"><strong class="ph b">Parameters:</strong></p>

		
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833__TABLE_VCK_ZJM_2Z" class="table" frame="border" border="1" rules="all">
				
				
				
				
				<thead class="thead" align="left">
					<tr class="row">
						<th class="entry" valign="top" id="d78191e221"><strong class="ph b">Name</strong></th>

						<th class="entry" valign="top" id="d78191e225"><strong class="ph b">Type</strong></th>

						<th class="entry" valign="top" id="d78191e229"><strong class="ph b">Direction</strong></th>

						<th class="entry" valign="top" id="d78191e233"><strong class="ph b">Description</strong></th>

					</tr>

				</thead>

				<tbody class="tbody">
					<tr class="row">
						<td class="entry" valign="top" headers="d78191e221 ">ptrData</td>

						<td class="entry" valign="top" headers="d78191e225 ">void*</td>

						<td class="entry" valign="top" headers="d78191e229 ">IN</td>

						<td class="entry" valign="top" headers="d78191e233 ">A pointer to the table entry to be saved.</td>

					</tr>

				</tbody>

			</table>
</div>

		<p class="p"><strong class="ph b">Returns:</strong></p>

		<pre class="pre codeblock">gNVM_OK_c 
gNVM_ModuleNotInitialized_c
gNVM_NullPointer_c
gNVM_InvalidTableEntry_c
gNVM_SaveRequestRejected_c</pre>

		<p class="p"><strong class="ph b"><span class="ph" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833___TOC346017102">NvSaveOnCount</span></strong></p>

		<p class="p"><strong class="ph b">Prototype:</strong></p>

		<pre class="pre codeblock">NVM_Status_t NvSaveOnCount
(
    void* ptrData
);</pre>

		<p class="p"><strong class="ph b">Description:</strong></p>

		<p class="p">This function decrements a counter that is associated with the dataset specified by the function argument. When that counter reaches zero, the dataset is saved as soon as the NvIdle() function is called. If the ptrData belongs to an unmirrored dataset, after the save, the RAM pointer is freed and pData points to the flash backup. No other saves can be made while the data is in flash. If ptrData belongs to a mirrored dataset, a full save is made. Otherwise, only the element indicated by ptrData is saved.</p>

		<p class="p"><strong class="ph b">Parameters:</strong></p>

		
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833__TABLE_XSB_GKM_2Z" class="table" frame="border" border="1" rules="all">
				
				
				
				
				<thead class="thead" align="left">
					<tr class="row">
						<th class="entry" valign="top" id="d78191e308"><strong class="ph b">Name</strong></th>

						<th class="entry" valign="top" id="d78191e312"><strong class="ph b">Type</strong></th>

						<th class="entry" valign="top" id="d78191e316"><strong class="ph b">Direction</strong></th>

						<th class="entry" valign="top" id="d78191e320"><strong class="ph b">Description</strong></th>

					</tr>

				</thead>

				<tbody class="tbody">
					<tr class="row">
						<td class="entry" valign="top" headers="d78191e308 ">ptrData</td>

						<td class="entry" valign="top" headers="d78191e312 ">void*</td>

						<td class="entry" valign="top" headers="d78191e316 ">IN</td>

						<td class="entry" valign="top" headers="d78191e320 ">A pointer to the table entry to be saved</td>

					</tr>

				</tbody>

			</table>
</div>

		<p class="p"><strong class="ph b">Returns:</strong></p>

		<pre class="pre codeblock">gNVM_OK_c
gNVM_ModuleNotInitialized_c 
gNVM_NullPointer_c
gNVM_InvalidTableEntry_c
gNVM_SaveRequestRejected_c</pre>

		<p class="p"><strong class="ph b"><span class="ph" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833___TOC346017103">NvSetMinimumTicksBetweenSaves</span></strong></p>

		<p class="p"><strong class="ph b">Prototype:</strong></p>

		<pre class="pre codeblock">void NvSetMinimumTicksBetweenSaves
(
    NvSaveInterval_t newInterval
);</pre>

		<p class="p"><strong class="ph b">Description:</strong></p>

		<p class="p">This function sets a new value of the timer interval that is used by the “save on interval” mechanism. The change takes effect after the next save is completed.</p>

		<p class="p"><strong class="ph b">Parameters:</strong></p>

		
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833__TABLE_WHD_LKM_2Z" class="table" frame="border" border="1" rules="all">
				
				
				
				
				<thead class="thead" align="left">
					<tr class="row">
						<th class="entry" valign="top" id="d78191e394"><strong class="ph b">Name</strong></th>

						<th class="entry" valign="top" id="d78191e398"><strong class="ph b">Type</strong></th>

						<th class="entry" valign="top" id="d78191e402"><strong class="ph b">Direction</strong></th>

						<th class="entry" valign="top" id="d78191e406"><strong class="ph b">Description</strong></th>

					</tr>

				</thead>

				<tbody class="tbody">
					<tr class="row">
						<td class="entry" valign="top" headers="d78191e394 ">newInterval</td>

						<td class="entry" valign="top" headers="d78191e398 ">NvSaveInterval_t</td>

						<td class="entry" valign="top" headers="d78191e402 ">IN</td>

						<td class="entry" valign="top" headers="d78191e406 ">The new value to be applied to the “save on interval” functionality</td>

					</tr>

				</tbody>

			</table>
</div>

		<p class="p"><strong class="ph b">Returns:</strong></p>

		<p class="p">None.</p>

		<p class="p"><strong class="ph b"><span class="ph" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833___TOC346017104">NvSetCountsBetweenSaves</span></strong></p>

		<p class="p"><strong class="ph b">Prototype:</strong></p>

		<pre class="pre codeblock">void NvSetCountsBetweenSaves
(
 	NvSaveCounter_t newCounter
);</pre>

		<p class="p"><strong class="ph b">Description:</strong></p>

		<p class="p">This function sets a new value of the counter trigger that is used by the “save on count” mechanism. The change takes effect after the next save is completed.</p>

		<p class="p"><strong class="ph b">Parameters:</strong></p>

		
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833__TABLE_WDJ_NKM_2Z" class="table" frame="border" border="1" rules="all">
				
				
				
				
				<thead class="thead" align="left">
					<tr class="row">
						<th class="entry" valign="top" id="d78191e481"><strong class="ph b">Name</strong></th>

						<th class="entry" valign="top" id="d78191e485"><strong class="ph b">Type</strong></th>

						<th class="entry" valign="top" id="d78191e489"><strong class="ph b">Direction</strong></th>

						<th class="entry" valign="top" id="d78191e493"><strong class="ph b">Description</strong></th>

					</tr>

				</thead>

				<tbody class="tbody">
					<tr class="row">
						<td class="entry" valign="top" headers="d78191e481 ">newCounter</td>

						<td class="entry" valign="top" headers="d78191e485 ">NvSaveCounter_t</td>

						<td class="entry" valign="top" headers="d78191e489 ">IN</td>

						<td class="entry" valign="top" headers="d78191e493 ">The new value to be applied to “save on count” functionality</td>

					</tr>

				</tbody>

			</table>
</div>

		<p class="p"><strong class="ph b">Returns:</strong></p>

		<p class="p">None.</p>

		<p class="p"><strong class="ph b">NvSyncSave</strong></p>

		<p class="p"><strong class="ph b">Prototype:</strong></p>

		<pre class="pre codeblock">NVM_Status_t NvSyncSave
(
    void* ptrData,
    bool_t saveAll
);</pre>

		<p class="p"><strong class="ph b">Description:</strong></p>

		<p class="p">This function saves the pointed element or the entire table entry to the storage system. The save operation is not performed on the idle task but within this function call. If ptrData belongs to an unmirrored dataset, after the save, the RAM pointer will be freed and pData will point to the flash backup. Also, saveAll is ignored and only individual elements can be saved. No other saves can be made while the data is in flash.</p>

		<p class="p"><strong class="ph b">Parameters:</strong></p>

		
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833__TABLE_MRY_QKM_2Z" class="table" frame="border" border="1" rules="all">
				
				
				
				
				<thead class="thead" align="left">
					<tr class="row">
						<th class="entry" valign="top" id="d78191e566"><strong class="ph b">Name</strong></th>

						<th class="entry" valign="top" id="d78191e570"><strong class="ph b">Type</strong></th>

						<th class="entry" valign="top" id="d78191e574"><strong class="ph b">Direction</strong></th>

						<th class="entry" valign="top" id="d78191e578"><strong class="ph b">Description</strong></th>

					</tr>

				</thead>

				<tbody class="tbody">
					<tr class="row">
						<td class="entry" valign="top" headers="d78191e566 ">ptrData</td>

						<td class="entry" valign="top" headers="d78191e570 ">void*</td>

						<td class="entry" valign="top" headers="d78191e574 ">IN</td>

						<td class="entry" valign="top" headers="d78191e578 "> <p class="p">Pointer to the table entry to be saved</p>
 <p class="p"> </p>
 </td>

					</tr>

					<tr class="row">
						<td class="entry" valign="top" headers="d78191e566 ">saveAll</td>

						<td class="entry" valign="top" headers="d78191e570 ">bool_t</td>

						<td class="entry" valign="top" headers="d78191e574 ">IN</td>

						<td class="entry" valign="top" headers="d78191e578 ">Specifies whether the entire table entry shall be saved, or just the pointed element</td>

					</tr>

				</tbody>

			</table>
</div>

		<p class="p"><strong class="ph b">Returns:</strong></p>

		<p class="p">One of the following:</p>

		<pre class="pre codeblock">gNVM_OK_c
gNVM_ModuleNotInitialized_c
gNVM_CriticalSectionActive_c
gNVM_PointerOutOfRange_c
gNVM_NullPointer_c
gNVM_SaveRequestRejected_c</pre>

		<p class="p"><strong class="ph b">NvAtomicSave</strong></p>

		<p class="p"><strong class="ph b">Prototype:</strong></p>

		<pre class="pre codeblock">NVM_Status_t NvAtomicSave
(
    void
);</pre>

		<p class="p"><strong class="ph b">Description:</strong></p>

		<p class="p">This function performs an atomic save of the entire NV table to the storage system. All the required save operations are performed in place.</p>

		<p class="p"><strong class="ph b">Parameters:</strong></p>

		<p class="p">None.</p>

		<p class="p"><strong class="ph b">Returns:</strong></p>

		<p class="p">One of the following:</p>

		<pre class="pre codeblock">gNVM_OK_c
gNVM_ModuleNotInitialized_c
gNVM_CriticalSectionActive_c
gNVM_PointerOutOfRange_c
gNVM_NullPointer_c
gNVM_SaveRequestRejected_c</pre>

		<p class="p"><strong class="ph b"><span class="ph" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833___TOC346017107">NvTimerTick</span></strong></p>

		<p class="p"><strong class="ph b">Prototype:</strong></p>

		<pre class="pre codeblock">bool_t NvTimerTick
(
    bool_t countTick
);</pre>

		<p class="p"><strong class="ph b">Description:</strong></p>

		<p class="p">This function processes NvSaveOnInterval() requests. If the call of this function counts a timer tick, call it with countTick set to TRUE. Otherwise, call it with countTick set to FALSE. Regardless of the value of countTick, NvTimerTick() returns TRUE if one or more of the datasets tick counters have not yet counted down to zero, or FALSE if all data set tick counters have reached zero. This function is called automatically inside the module to process interval saves, but it can be called from the application if required.</p>

		<p class="p"><strong class="ph b">Parameters:</strong></p>

		
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833__TABLE_HP1_DLM_2Z" class="table" frame="border" border="1" rules="all">
				
				
				
				
				<thead class="thead" align="left">
					<tr class="row">
						<th class="entry" valign="top" id="d78191e714"><strong class="ph b">Name</strong></th>

						<th class="entry" valign="top" id="d78191e718"><strong class="ph b">Type</strong></th>

						<th class="entry" valign="top" id="d78191e722"><strong class="ph b">Direction</strong></th>

						<th class="entry" valign="top" id="d78191e726"><strong class="ph b">Description</strong></th>

					</tr>

				</thead>

				<tbody class="tbody">
					<tr class="row">
						<td class="entry" valign="top" headers="d78191e714 ">countTick</td>

						<td class="entry" valign="top" headers="d78191e718 ">bool_t</td>

						<td class="entry" valign="top" headers="d78191e722 ">IN</td>

						<td class="entry" valign="top" headers="d78191e726 ">See API description</td>

					</tr>

				</tbody>

			</table>
</div>

		<p class="p"><strong class="ph b">Returns:</strong></p>

		<p class="p">See description.</p>

		<p class="p"><strong class="ph b"><span class="ph" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833___TOC346017099">NvRestoreDataSet</span></strong></p>

		<p class="p"><strong class="ph b">Prototype:</strong></p>

		<pre class="pre codeblock">NVM_Status_t NvRestoreDataSet
(
    void* ptrData, 
    bool_t restoreAll
);</pre>

		<p class="p"><strong class="ph b">Description:</strong></p>

		<p class="p">This function restores the element or the entire NV table entry specified by the function argument ptrData. If a valid table entry copy is found in the flash memory, it will be restored to RAM NV Table.</p>

		<p class="p">For unmirrored datasets, the function only restores a pointer to the flash location of the entry. In order to restore the data from flash to RAM, the application has to call NvMoveToRam.</p>

		<p class="p"><strong class="ph b">Parameters:</strong></p>

		
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833__TABLE_EKQ_HLM_2Z" class="table" frame="border" border="1" rules="all">
				
				
				
				
				<thead class="thead" align="left">
					<tr class="row">
						<th class="entry" valign="top" id="d78191e803"><strong class="ph b">Name</strong></th>

						<th class="entry" valign="top" id="d78191e807"><strong class="ph b">Type</strong></th>

						<th class="entry" valign="top" id="d78191e811"><strong class="ph b">Direction</strong></th>

						<th class="entry" valign="top" id="d78191e815"><strong class="ph b">Description</strong></th>

					</tr>

				</thead>

				<tbody class="tbody">
					<tr class="row">
						<td class="entry" valign="top" headers="d78191e803 ">ptrData</td>

						<td class="entry" valign="top" headers="d78191e807 ">void*</td>

						<td class="entry" valign="top" headers="d78191e811 ">IN</td>

						<td class="entry" valign="top" headers="d78191e815 ">A pointer to a NV table entry / element to be restored with the data from flash.</td>

					</tr>

					<tr class="row">
						<td class="entry" valign="top" headers="d78191e803 ">restoreAll</td>

						<td class="entry" valign="top" headers="d78191e807 ">bool_t</td>

						<td class="entry" valign="top" headers="d78191e811 ">IN</td>

						<td class="entry" valign="top" headers="d78191e815 ">A flag used to indicate if the entire table entry shall be restored, or just a single element (indicated by ptrData). If ptrData points to an unmirrored dataset, the flag is set to false internally.</td>

					</tr>

				</tbody>

			</table>
</div>

		<p class="p"><strong class="ph b">Returns:</strong></p>

		<pre class="pre codeblock">gNVM_OK_c
gNVM_ModuleNotInitialized_c
gNVM_NullPointer_c
gNVM_PointerOutOfRange_c
gNVM_PageIsEmpty_c
gNVM_Error_c</pre>

		<p class="p"><strong class="ph b"><span class="ph">NvSetCriticalSection</span></strong></p>

		<p class="p"><strong class="ph b">Prototype:</strong></p>

		<pre class="pre codeblock">void NvSetCriticalSection
(
    void
);</pre>

		<p class="p"><strong class="ph b">Description:</strong></p>

		<p class="p">This function increments an internal counter variable each time it is called. All the sync save/erase/copy functions are checking this counter before executing their code. If the counter has a nonzero value, the function returns with no further operations. This function guarantees that all the sync save/erase/copy operations are put in the pending queue while the critical section is on and processed when the critical section is lifter, on the idle task. </p>

		<p class="p"><strong class="ph b">Parameters:</strong></p>

		<p class="p">None.</p>

		<p class="p"><strong class="ph b">Returns:</strong></p>

		<p class="p">None.</p>

		<p class="p"><strong class="ph b"><span class="ph">NvClearCriticalSection</span></strong></p>

		<p class="p"><strong class="ph b">Prototype:</strong></p>

		<pre class="pre codeblock">void NvClearCriticalSection
(
    void
);</pre>

		<p class="p"><strong class="ph b">Description:</strong></p>

		<p class="p">This function decrements an internal counter variable each time it is called. All the sync save/erase/copy functions are checking this counter before executing their code. If the counter has a nonzero value, the function returns with no further operations.</p>

		<p class="p"><strong class="ph b">Parameters:</strong></p>

		<p class="p">None.</p>

		<p class="p"><strong class="ph b">Returns:</strong></p>

		<p class="p">None.</p>

		<p class="p"><strong class="ph b"><span class="ph" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833___TOC346017106">NvIdle</span></strong></p>

		<p class="p"><strong class="ph b">Prototype:</strong></p>

		<pre class="pre codeblock">void NvIdle
(
    void
);</pre>

		<p class="p"><strong class="ph b">Description:</strong></p>

		<p class="p">This function processes the NvSaveOnIdle() and NvSaveOnCount() requests. It also checks if the internal timer made a tick and determines if any save on interval should be processed. It also does page copy and erase. Any saves that were not processed when the critical section was active will be processed here. It must be called from a low priority task, such as Idle task.</p>

		<p class="p"><strong class="ph b">Parameters:</strong></p>

		<p class="p">None.</p>

		<p class="p"><strong class="ph b">Returns:</strong></p>

		<p class="p">None.</p>

		<p class="p"><strong class="ph b"><span class="ph" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833___TOC346017105">NvIsDataSetDirty</span></strong></p>

		<p class="p"><strong class="ph b">Prototype:</strong></p>

		<pre class="pre codeblock">bool_t NvIsDataSetDirty
(
    void* ptrData
);</pre>

		<p class="p"><strong class="ph b">Description:</strong></p>

		<p class="p">This function checks if the table entry specified by the function argument is dirty (a save is pending on the specified dataset).</p>

		<p class="p"><strong class="ph b">Parameters:</strong></p>

		
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833__TABLE_CZB_5TM_2Z" class="table" frame="border" border="1" rules="all">
				
				
				
				
				<thead class="thead" align="left">
					<tr class="row">
						<th class="entry" valign="top" id="d78191e1008"><strong class="ph b">Name</strong></th>

						<th class="entry" valign="top" id="d78191e1012"><strong class="ph b">Type</strong></th>

						<th class="entry" valign="top" id="d78191e1016"><strong class="ph b">Direction</strong></th>

						<th class="entry" valign="top" id="d78191e1020"><strong class="ph b">Description</strong></th>

					</tr>

				</thead>

				<tbody class="tbody">
					<tr class="row">
						<td class="entry" valign="top" headers="d78191e1008 ">ptrData</td>

						<td class="entry" valign="top" headers="d78191e1012 ">void*</td>

						<td class="entry" valign="top" headers="d78191e1016 ">IN</td>

						<td class="entry" valign="top" headers="d78191e1020 ">A pointer to the NV table entry to be checked</td>

					</tr>

				</tbody>

			</table>
</div>

		<p class="p"><strong class="ph b">Returns:</strong></p>

		<p class="p">TRUE if the specified table entry is dirty/FALSE otherwise.</p>

		<p class="p"><span class="ph"><strong class="ph b">NvGetPageStatistics</strong></span></p>

		<p class="p"><strong class="ph b">Prototype:</strong></p>

		<pre class="pre codeblock">void NvGetPagesStatistics
(
    NVM_Statistics_t* ptrStat 
);</pre>

		<p class="p"><strong class="ph b">Description:</strong></p>

		<p class="p">Retrieves the virtual pages statistics (how many times each virtual page has been erased). The function is not available on FlexNVM.</p>

		<p class="p"><strong class="ph b">Parameters:</strong></p>

		
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833__TABLE_FFT_YTM_2Z" class="table" frame="border" border="1" rules="all">
				
				
				
				
				<thead class="thead" align="left">
					<tr class="row">
						<th class="entry" valign="top" id="d78191e1095"><strong class="ph b">Name</strong></th>

						<th class="entry" valign="top" id="d78191e1099"><strong class="ph b">Type</strong></th>

						<th class="entry" valign="top" id="d78191e1103"><strong class="ph b">Direction</strong></th>

						<th class="entry" valign="top" id="d78191e1107"><strong class="ph b">Description</strong></th>

					</tr>

				</thead>

				<tbody class="tbody">
					<tr class="row">
						<td class="entry" valign="top" headers="d78191e1095 ">ptrStat</td>

						<td class="entry" valign="top" headers="d78191e1099 ">NVM_Statistics_t*</td>

						<td class="entry" valign="top" headers="d78191e1103 ">OUT</td>

						<td class="entry" valign="top" headers="d78191e1107 ">Pointer to a memory location where the statistics are to be stored</td>

					</tr>

				</tbody>

			</table>
</div>

		<p class="p"><strong class="ph b">Returns:</strong></p>

		<p class="p">None.</p>

		<p class="p"><span class="ph"><strong class="ph b">NvFormat</strong></span></p>

		<p class="p"><strong class="ph b">Prototype:</strong></p>

		<pre class="pre codeblock">NVM_Status_t NvFormat
(
    void
);</pre>

		<p class="p"><strong class="ph b">Description:</strong></p>

		<p class="p">This function performs a full format of both virtual pages. The page counter value is preserved during formatting.</p>

		<p class="p"><strong class="ph b">Parameters:</strong></p>

		
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833__TABLE_ZDL_D5M_2Z" class="table" frame="border" border="1" rules="all">
				
				
				
				
				<thead class="thead" align="left">
					<tr class="row">
						<th class="entry" valign="top" id="d78191e1181"><strong class="ph b">Name</strong></th>

						<th class="entry" valign="top" id="d78191e1185"><strong class="ph b">Type</strong></th>

						<th class="entry" valign="top" id="d78191e1189"><strong class="ph b">Direction</strong></th>

						<th class="entry" valign="top" id="d78191e1193"><strong class="ph b">Description</strong></th>

					</tr>

				</thead>

				<tbody class="tbody">
					<tr class="row">
						<td class="entry" valign="top" headers="d78191e1181 ">–</td>

						<td class="entry" valign="top" headers="d78191e1185 ">–</td>

						<td class="entry" valign="top" headers="d78191e1189 ">–</td>

						<td class="entry" valign="top" headers="d78191e1193 ">–</td>

					</tr>

				</tbody>

			</table>
</div>

		<p class="p"><strong class="ph b">Returns:</strong></p>

		<p class="p">One of the following:</p>

		<pre class="pre codeblock">gNVM_OK_c
gNVM_ModuleNotInitialized_c
gNVM_CriticalSectionActive_c
gNVM_FormatFailure_c</pre>

		<p class="p"><strong class="ph b">NvRegisterTableEntry</strong></p>

		<p class="p"><strong class="ph b">Prototype:</strong></p>

		<pre class="pre codeblock">NVM_Status_t NvRegisterTableEntry
(
    void* ptrData,
    NvTableEntryId_t uniqueId,
    uint16_t elemCount,
    uint16_t elemSize,
    uint16_t dataEntryType,
    bool_t overwrite
);</pre>

		<p class="p"><strong class="ph b">Description:</strong></p>

		<p class="p">This function enables registering a new table entry or updating an existing one. To register a new table entry, the NV table must contain at least one invalid entry (unused/previously erased table entry). If overwrite is TRUE, the old table entry with the specified ID will be overwritten. This will trigger a page copy. If the critical section is active, the page copy is done as soon as it is deactivated. Extended functionality must be enabled if this function is required.</p>

		<p class="p"><strong class="ph b">Parameters:</strong></p>

		
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833__TABLE_UYM_K5M_2Z" class="table" frame="border" border="1" rules="all">
				
				
				
				
				<thead class="thead" align="left">
					<tr class="row">
						<th class="entry" valign="top" id="d78191e1270"><strong class="ph b">Name</strong></th>

						<th class="entry" valign="top" id="d78191e1274"><strong class="ph b">Type</strong></th>

						<th class="entry" valign="top" id="d78191e1278"><strong class="ph b">Direction</strong></th>

						<th class="entry" valign="top" id="d78191e1282"><strong class="ph b">Description</strong></th>

					</tr>

				</thead>

				<tbody class="tbody">
					<tr class="row">
						<td class="entry" valign="top" headers="d78191e1270 ">ptrData</td>

						<td class="entry" valign="top" headers="d78191e1274 ">void*</td>

						<td class="entry" valign="top" headers="d78191e1278 ">IN</td>

						<td class="entry" valign="top" headers="d78191e1282 ">Pointer to the table entry to be registered/updated</td>

					</tr>

					<tr class="row">
						<td class="entry" valign="top" headers="d78191e1270 ">uniqueId</td>

						<td class="entry" valign="top" headers="d78191e1274 ">NvTableEntryId_t</td>

						<td class="entry" valign="top" headers="d78191e1278 ">IN</td>

						<td class="entry" valign="top" headers="d78191e1282 ">The ID of the table entry to be registered/updated</td>

					</tr>

					<tr class="row">
						<td class="entry" valign="top" headers="d78191e1270 ">elemCount</td>

						<td class="entry" valign="top" headers="d78191e1274 ">uint16_t</td>

						<td class="entry" valign="top" headers="d78191e1278 ">IN</td>

						<td class="entry" valign="top" headers="d78191e1282 ">The elements count of the table entry to be registered/updated</td>

					</tr>

					<tr class="row">
						<td class="entry" valign="top" headers="d78191e1270 ">elemSize</td>

						<td class="entry" valign="top" headers="d78191e1274 ">uint16_t</td>

						<td class="entry" valign="top" headers="d78191e1278 ">IN</td>

						<td class="entry" valign="top" headers="d78191e1282 ">The size of one element of the table entry</td>

					</tr>

					<tr class="row">
						<td class="entry" valign="top" headers="d78191e1270 ">dataEntryType</td>

						<td class="entry" valign="top" headers="d78191e1274 ">uint16_t</td>

						<td class="entry" valign="top" headers="d78191e1278 ">IN</td>

						<td class="entry" valign="top" headers="d78191e1282 ">The type of the entry to be registered</td>

					</tr>

					<tr class="row">
						<td class="entry" valign="top" headers="d78191e1270 ">overwrite</td>

						<td class="entry" valign="top" headers="d78191e1274 ">bool_t</td>

						<td class="entry" valign="top" headers="d78191e1278 ">IN</td>

						<td class="entry" valign="top" headers="d78191e1282 ">If set to TRUE and the table entry ID already exists, the table entry will be updated with data provided by the function arguments. Otherwise, if overwrite is set to FALSE, the data will be placed in the first free position in the table.</td>

					</tr>

				</tbody>

			</table>
</div>

		<p class="p"><strong class="ph b">Returns:</strong></p>

		<p class="p">One of the following:</p>

		<pre class="pre codeblock">gNVM_OK_c
gNVM_ModuleNotInitialized_c
gNVM_AlreadyRegistered
gNVM_RegisterFailure_c</pre>

		<p class="p"><strong class="ph b">NvEraseEntryFromStorage</strong></p>

		<p class="p"><strong class="ph b">Prototype:</strong></p>

		<pre class="pre codeblock">NVM_Status_t NvEraseEntryFromStorage
(
    void* ptrData
);</pre>

		<p class="p"><strong class="ph b">Description:</strong></p>

		<p class="p">This function removes the table entry specified by the function argument, ptrData. A page copy is triggered and the data associated with the entry is not copied. If the critical section is active, the page copy is done as soon as it is deactivated. It sets entrySize and entryCount to 0 and pData to NULL. EntryId remains unchanged. For unmirrored datasets, use NvErase because it can delete individual elements. The extended functionality must be enabled if this function is required.</p>

		<p class="p"><strong class="ph b">Parameters:</strong></p>

		
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833__TABLE_WLS_55M_2Z" class="table" frame="border" border="1" rules="all">
				
				
				
				
				<thead class="thead" align="left">
					<tr class="row">
						<th class="entry" valign="top" id="d78191e1435"><strong class="ph b">Name</strong></th>

						<th class="entry" valign="top" id="d78191e1439"><strong class="ph b">Type</strong></th>

						<th class="entry" valign="top" id="d78191e1443"><strong class="ph b">Direction</strong></th>

						<th class="entry" valign="top" id="d78191e1447"><strong class="ph b">Description</strong></th>

					</tr>

				</thead>

				<tbody class="tbody">
					<tr class="row">
						<td class="entry" valign="top" headers="d78191e1435 ">ptrData</td>

						<td class="entry" valign="top" headers="d78191e1439 ">void*</td>

						<td class="entry" valign="top" headers="d78191e1443 ">IN</td>

						<td class="entry" valign="top" headers="d78191e1447 ">Pointer to the table entry to be removed</td>

					</tr>

				</tbody>

			</table>
</div>

		<p class="p"><strong class="ph b">Returns:</strong></p>

		<p class="p">One of the following:</p>

		<pre class="pre codeblock">gNVM_OK_c
gNVM_ModuleNotInitialized_c
gNVM_CriticalSectionActive_c
gNVM_PointerOutOfRange_c
gNVM_NullPointer_c
gNVM_InvalidTableEntry_c</pre>

		<p class="p"><strong class="ph b">GetFlashTableVersion</strong></p>

		<p class="p"><strong class="ph b">Prototype:</strong></p>

		<pre class="pre codeblock">uint16_t GetFlashTableVersion
(
    void
);</pre>

		<p class="p"><strong class="ph b">Description:</strong></p>

		<p class="p">This function returns the version stored in the flash table or 0 if no table is detected. The extended functionality must be enabled if this function is required.</p>

		<p class="p"><strong class="ph b">Parameters:</strong></p>

		
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833__TABLE_HWC_1VM_2Z" class="table" frame="border" border="1" rules="all">
				
				
				
				
				<thead class="thead" align="left">
					<tr class="row">
						<th class="entry" valign="top" id="d78191e1523"><strong class="ph b">Name</strong></th>

						<th class="entry" valign="top" id="d78191e1527"><strong class="ph b">Type</strong></th>

						<th class="entry" valign="top" id="d78191e1531"><strong class="ph b">Direction</strong></th>

						<th class="entry" valign="top" id="d78191e1535"><strong class="ph b">Description</strong></th>

					</tr>

				</thead>

				<tbody class="tbody">
					<tr class="row">
						<td class="entry" valign="top" headers="d78191e1523 ">–</td>

						<td class="entry" valign="top" headers="d78191e1527 ">–</td>

						<td class="entry" valign="top" headers="d78191e1531 ">–</td>

						<td class="entry" valign="top" headers="d78191e1535 ">–</td>

					</tr>

				</tbody>

			</table>
</div>

		<p class="p"><strong class="ph b">Returns:</strong></p>

		<p class="p">See description.</p>

		<p class="p"><strong class="ph b">RecoverNvEntry</strong></p>

		<p class="p"><strong class="ph b">Prototype:</strong></p>

		<pre class="pre codeblock">NVM_Status_t RecoverNvEntry
(
    uint16_t index,
    NVM_DataEntry_tag *entry
);</pre>

		<p class="p"><strong class="ph b">Description:</strong></p>

		<p class="p">This function reads the flash entry data for a specified dataset. It is used to determine before initialization if some flash entries are different than the RAM counterparts. To use data stored in the flash table, the application should copy the members returned by this function in their respective RAM entry and allocate pData. The extended functionality must be enabled if this function is required.</p>

		<p class="p"><strong class="ph b">Parameters:</strong></p>

		
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833__TABLE_NPL_FVM_2Z" class="table" frame="border" border="1" rules="all">
				
				
				
				
				<thead class="thead" align="left">
					<tr class="row">
						<th class="entry" valign="top" id="d78191e1609"><strong class="ph b">Name</strong></th>

						<th class="entry" valign="top" id="d78191e1613"><strong class="ph b">Type</strong></th>

						<th class="entry" valign="top" id="d78191e1617"><strong class="ph b">Direction</strong></th>

						<th class="entry" valign="top" id="d78191e1621"><strong class="ph b">Description</strong></th>

					</tr>

				</thead>

				<tbody class="tbody">
					<tr class="row">
						<td class="entry" valign="top" headers="d78191e1609 ">index</td>

						<td class="entry" valign="top" headers="d78191e1613 ">uint16_t</td>

						<td class="entry" valign="top" headers="d78191e1617 ">IN</td>

						<td class="entry" valign="top" headers="d78191e1621 ">The index of the RAM entry that needs to be restored</td>

					</tr>

					<tr class="row">
						<td class="entry" valign="top" headers="d78191e1609 ">entry</td>

						<td class="entry" valign="top" headers="d78191e1613 ">NVM_DataEntry_tag*</td>

						<td class="entry" valign="top" headers="d78191e1617 ">OUT</td>

						<td class="entry" valign="top" headers="d78191e1621 ">The entry data from flash</td>

					</tr>

				</tbody>

			</table>
</div>

		<p class="p"><strong class="ph b">Returns: </strong></p>

		<p class="p">One of the following:</p>

		<pre class="pre codeblock">gNVM_OK_c
gNVM_RestoreFailure_c
gNVM_AddressOutOfRange_c</pre>

		<p class="p"><strong class="ph b">NvMoveToRam</strong></p>

		<p class="p"><strong class="ph b">Prototype:</strong></p>

		<pre class="pre codeblock">NVM_Status_t NvMoveToram
(
    void** ppData
);</pre>

		<p class="p"><strong class="ph b">Description:</strong></p>

		<p class="p">This function moves the data pointed to by ppData from flash to RAM (allocates space and copies the data). It can only move a single element. It changes pData in the NVM table to point to the new location. If the specified element is already in RAM, the function cancels any pending saves and returns. The unmirrored functionality must be enabled if this function is required.</p>

		<p class="p"><strong class="ph b">Parameters:</strong></p>

		
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833__TABLE_VBZ_JVM_2Z" class="table" frame="border" border="1" rules="all">
				
				
				
				
				<thead class="thead" align="left">
					<tr class="row">
						<th class="entry" valign="top" id="d78191e1712"><strong class="ph b">Name</strong></th>

						<th class="entry" valign="top" id="d78191e1716"><strong class="ph b">Type</strong></th>

						<th class="entry" valign="top" id="d78191e1720"><strong class="ph b">Direction</strong></th>

						<th class="entry" valign="top" id="d78191e1724"><strong class="ph b">Description</strong></th>

					</tr>

				</thead>

				<tbody class="tbody">
					<tr class="row">
						<td class="entry" valign="top" headers="d78191e1712 ">ppData</td>

						<td class="entry" valign="top" headers="d78191e1716 ">void**</td>

						<td class="entry" valign="top" headers="d78191e1720 ">IN</td>

						<td class="entry" valign="top" headers="d78191e1724 ">Pointer to the table entry to be moved</td>

					</tr>

				</tbody>

			</table>
</div>

		<p class="p"><strong class="ph b">Returns: </strong></p>

		<p class="p">One of the following:</p>

		<pre class="pre codeblock">gNVM_OK_c
gNVM_PointerOutOfRange_c
gNVM_IsMirroredDataSet_c
gNVM_InvalidTableEntry_c
gNVM_NoMemory_c 
gNVM_Error_c</pre>

		<p class="p"><strong class="ph b">NvErase</strong></p>

		<p class="p"><strong class="ph b">Prototype:</strong></p>

		<pre class="pre codeblock">NVM_Status_t NvErase
(
    void** ppData
);</pre>

		<p class="p"><strong class="ph b">Description:</strong></p>

		<p class="p">This function erases an unmirrored dataset from flash. It generally does not trigger a page copy, but writes a new record in the NVM memory that specifies that this element was removed. If the page is full, a page copy is triggered. It sets pData for the specified element to NULL. It can only erase a single element. If the specified element is in RAM, it is freed but no changes are made in flash. The unmirrored functionality must be enabled if this function is required.</p>

		<p class="p"><strong class="ph b">Parameters:</strong></p>

		
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="GUID-F5EFB25D-982B-4E82-B13D-65CF4C262833__TABLE_VVS_4VM_2Z" class="table" frame="border" border="1" rules="all">
				
				
				
				
				<thead class="thead" align="left">
					<tr class="row">
						<th class="entry" valign="top" id="d78191e1801"><strong class="ph b">Name</strong></th>

						<th class="entry" valign="top" id="d78191e1805"><strong class="ph b">Type</strong></th>

						<th class="entry" valign="top" id="d78191e1809"><strong class="ph b">Direction</strong></th>

						<th class="entry" valign="top" id="d78191e1813"><strong class="ph b">Description</strong></th>

					</tr>

				</thead>

				<tbody class="tbody">
					<tr class="row">
						<td class="entry" valign="top" headers="d78191e1801 ">ppData</td>

						<td class="entry" valign="top" headers="d78191e1805 ">void**</td>

						<td class="entry" valign="top" headers="d78191e1809 ">IN</td>

						<td class="entry" valign="top" headers="d78191e1813 ">Pointer to the table entry to be erased</td>

					</tr>

				</tbody>

			</table>
</div>

		<p class="p"><strong class="ph b">Returns: </strong></p>

		<p class="p">One of the following:</p>

		<pre class="pre codeblock">gNVM_OK_c
gNVM_PointerOutOfRange_c
gNVM_IsMirroredDataSet_c
gNVM_InvalidTableEntry_c </pre>

		<p class="p"><strong class="ph b">NvShutdown</strong></p>

		<p class="p"><strong class="ph b">Prototype:</strong></p>

		<pre class="pre codeblock">void NvShutdown
(
    void
);</pre>

		<p class="p"><strong class="ph b">Description:</strong></p>

		<p class="p">This function blocks until all the saves in queue, page copy operations, and interval saves have been processed to ensure that the MCU has the latest data before a reset.</p>

		<p class="p"><strong class="ph b">Parameters:</strong></p>

		<p class="p">None.</p>

		<p class="p"><strong class="ph b">Returns: </strong></p>

		<p class="p">None.</p>

		<p class="p"><strong class="ph b">CompletePendingOperations</strong></p>

		<p class="p"><strong class="ph b">Prototype:</strong></p>

		<pre class="pre codeblock">void NvCompletePendingOperations
(
    void 
);</pre>

		<p class="p"><strong class="ph b">Description:</strong></p>

		<p class="p">This function attempts to complete all the NVM related pending operations, like queued writes, page copy, page erase and save on interval requests.</p>

		<p class="p"><strong class="ph b">Parameters:</strong></p>

		<p class="p">None</p>

		<p class="p"><strong class="ph b">Returns: </strong></p>

		<p class="p">None</p>

	</div>

<div class="related-links">
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="GUID-0E23C916-82C8-415A-8469-773251C6D3F3.html">Flash Management and Non-Volatile Storage Module</a></div>
</div>
</div>

</body>
</html>