/* ------------------------------------------------------------------------ */
/* Copyright (c) 2018 by Cadence Design Systems, Inc. ALL RIGHTS RESERVED.  */
/* These coded instructions, statements, and computer programs ("Cadence    */
/* Libraries") are the copyrighted works of Cadence Design Systems Inc.	    */
/* Cadence IP is licensed for use with Cadence processor cores only and     */
/* must not be used for any other processors and platforms. Your use of the */
/* Cadence Libraries is subject to the terms of the license agreement you   */
/* have entered into with Cadence Design Systems, or a sublicense granted   */
/* to you by a direct Cadence licensee.                                     */
/* ------------------------------------------------------------------------ */
/*  IntegrIT, Ltd.   www.integrIT.com, info@integrIT.com                    */
/*                                                                          */
/* DSP Library                                                              */
/*                                                                          */
/* This library contains copyrighted materials, trade secrets and other     */
/* proprietary information of IntegrIT, Ltd. This software is licensed for  */
/* use with Cadence processor cores only and must not be used for any other */
/* processors and platforms. The license to use these sources was given to  */
/* Cadence, Inc. under Terms and Condition of a Software License Agreement  */
/* between Cadence, Inc. and IntegrIT, Ltd.                                 */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2015-2018 IntegrIT, Limited.                      */
/*                      All Rights Reserved.                                */
/* ------------------------------------------------------------------------ */
/*
 * Power spectrum, 32x32 precision
 * Code optimized for HiFi4 core
 */

#include "NatureDSP_Signal_fft.h"
#include "common.h"

/*-------------------------------------------------------------------------
  Power spectrum
  These functions compute a normalized power spectrum from the output signal 
  generated by an FFT function. The N argument specifies the size of the FFT 
  and must be a power of 2. The  mode argument is used to specify the type 
  of FFT function used to generate the x array. If the x array has been 
  generated from a frequency-domain complex input signal (output of complex 
  FFT function), the mode argument must be set to 0. Otherwise the mode 
  argument must be set to 1 to signify that the x array has been generated 
  from a frequency-domain real input signal (output of real FFT function).
  The block_exponent argument is used to control the normalization of the 
  power spectrum. It will usually be set to the block_exponent that is 
  returned by corresponding FFT functions.  If the input array was 
  generated by some other means, then the value specified for the 
  block_exponent argument will depend upon how the FFT was calculated. 
  If the function used to calculate the FFT did not scale the intermediate 
  results at any of the stages of the computation, then set block_exponent 
  to zero; if the FFT function scaled the intermediate results at each 
  stage of the computation, then set block_exponent to -1; otherwise set 
  block_exponent to the sum of negated base-2 logarithm of all scaling 
  factors applied to data at intermediate FFT stages. This value will be 
  in the range 0 to log2(N).
  fft_spectrum functions write the power spectrum to the output array y. 
  If mode is set to 0, then the length of the power spectrum will be N. If 
  mode is set to 1, then the length of the power spectrum will be (N/2+1)

  Precision:
  16x32   16-bit inputs, 32-bit outputs
  32x32   32-bit inputs/outputs
  f       floating point inputs/outputs. Requires VFPU/SFPU core option


  Input:
  for mode==0
  x[N]           input spectrum . Real and imaginary
                 data are interleaved and real data goes first:
  for mode==1
  x[N/2+1]       input spectrum (positive side). Real and imaginary
                 data are interleaved and real data goes first:
  block_exponent power spectrum normalization control
  N              FFT size
  mode           power spectrum mode:
                 0 – complex signal
                 1 – real signal

  twdstep               twiddle step
  scalingOpt            scaling option (see table above), not applicable 
                        to the floating point function
  Output:
  for mode==0
  y[N]           output power spectrum
  for mode==1
  y[N/2+1]       output power spectrum
  Returned value:  none

  Restrictions:
  x,y   should not overlap
  x,y   aligned on 8-bytes boundary
-------------------------------------------------------------------------*/
void fft_spectrum32x32( fract32 * y, const complex_fract32 * x, 
                         int N, int block_exponent, int mode )
{
#define SCR_SIZE ((MAX_ALLOCA_SZ/sizeof(int32_t))&~3)
    int32_t ALIGN(8) scr[SCR_SIZE];
    static const int32_t polysqrt[]={-1564282316, 0, -139612678, // Q29
                                     893795525, -832682052, // Q31
                                     1239415238};           // last coefficient+1, Q31
    const ae_int32x2* restrict pX=(const ae_int32x2*)x;
          ae_int32x2* restrict pScrWr;
    const ae_int32x2* restrict pScrRd;
          ae_int32x2* restrict pY;
    ae_valign aY,aX;
    int n, logN, M;
    NASSERT( x );
    NASSERT( y );

    logN = 30 - NSA( N );

    if ( N<2 || 0 != (N&(N-1)) || block_exponent < -1 || block_exponent > logN || ( mode != 0 && mode != 1 ) ) return;

    /* Negative block exponent value corresponds to static scaling, i.e. the spectrum
    * has been divided by N in the course of FFT computation. */
    if ( block_exponent<0 ) block_exponent = logN;
    N=( mode ? N/2+1 : N );
    while(N>0)
    {
        M=XT_MIN((SCR_SIZE/2),N);
        /* note: if N is odd, we have to make first iteration with 1 element 
           and all next iterations will be done with even number of elements 
           this does not cause reading above the upper bound of input array
           because number of input elements is always not less than 2
        */
        if (N&1) M=1;
        /* compute normalizaton shift amount */
        pX=(const ae_int32x2*)x;
        pScrWr=(      ae_int32x2*)scr;
        pY    =(      ae_int32x2*)y;
        aY = AE_ZALIGN64();
        for ( n=0; n<M; n+=2 )
        {
            ae_int32x2 xx,w;
            int nsa0,nsa1;
            ae_int64 a0,a1;
            /* Q2.62 <- |CQ31|^2 */
            AE_L32X2_IP(xx,pX,sizeof(ae_int32x2));
            a0=AE_MULZAAD32_HH_LL(xx,xx);
            AE_L32X2_IP(xx,pX,sizeof(ae_int32x2));
            a1=AE_MULZAAD32_HH_LL(xx,xx);
            /* Even normalization is required by sqrt algorithm. */
            nsa0 = ( AE_NSA64( a0 ) & ~1 );
            nsa1 = ( AE_NSA64( a1 ) & ~1 );
            /* Q(2.30+nsa) <- Q2.62 + nsa - 32 */
            w=AE_ROUND32X2F64SASYM(AE_SLAA64(a0,nsa0),AE_SLAA64(a1,nsa1));
            AE_SA32X2_IP(AE_MOVDA32X2(nsa0,nsa1),aY,pY);
            AE_S32X2_IP(w,pScrWr,2*sizeof(ae_int32x2));
        }
        AE_SA64POS_FP(aY,pY);
        /* compute normalized square root */
        __Pragma("no_reorder")
        pScrWr=((      ae_int32x2*)scr)+1;
        pScrRd=(const ae_int32x2*)scr;
        /* square root of normalized Q31 number in range 0.25...1 
            Reference Matlab code:
                x0=x;
                x=x-1610612736;
                % first approximation of 0.5/sqrt(x)-1, Q31
                % polynomial coefficients:
                % x=(0.25:pow2(1,-14):1);
                % y=0.5/sqrt(x)-1;
                % p=polyfit(x-0.75,y,5);
                % first 3 coefficients in Q29, all other in Q30
                p=[-1564282316 0 -139612678 ...
                    893795525 -832682052 -908068410];
                r=p(1); % q29
                r=sat32(p(2)+floor(pow2(x.*r+2^30,-31))); %q29*q31->q29
                r=sat32(p(3)+floor(pow2(x.*r+2^30,-31))); %q29*q31->q29
                r=r*4;
                r=sat32(p(4)+floor(pow2(x.*r+2^30,-31)));
                r=sat32(p(5)+floor(pow2(x.*r+2^30,-31)));
                r=sat32((2^31+p(6))+floor(pow2(x.*r+2^30,-31)));
                x=x0;
                % reiterate 0.5/sqrt(x)
                r2=floor(pow2(r.*r+2^30,-31));
                d=2*floor(pow2(x.*r2+2^30,-31));
                d=2^30-d;
                d=floor(pow2(d.*r+2^30,-31));
                r=r+d;
                % last iteration for sqrt(x) is done in higher precision
                y=floor(pow2(x.*r+2^29,-30));
                d=2^34-floor(pow2(y.*r,-27));
                d=floor(pow2(y.*d+2^31,-31));
                y=y+floor(pow2(d+2^3,-4));
        */
        for ( n=0; n<M; n+=2 )
        {
            ae_int32x2 w,x,r,t,d,r2;
            AE_L32X2_IP(w,pScrRd,2*sizeof(ae_int32x2));
            x=w;
            x=AE_SUB32(x,1610612736);
            r=polysqrt[0]; // q29
            r=AE_MULFP32X2RAS(x,r);
            t=polysqrt[2]; AE_MULAFP32X2RAS(t,x,r); r=t;
            r=AE_SLLI32(r,2);
            t=polysqrt[3]; AE_MULAFP32X2RAS(t,x,r); r=t;
            t=polysqrt[4]; AE_MULAFP32X2RAS(t,x,r); r=t;
            t=polysqrt[5]; AE_MULAFP32X2RAS(t,x,r); r=t;
            x=w;
            /* next iterate  0.5/sqrt(x) */
            r2=AE_MULFP32X2RAS(r,r);
            d =AE_MULFP32X2RAS(x,r2);
            d = AE_SUB32((1<<30),AE_SLLI32(d,1));
            AE_MULAFP32X2RAS(r,d,r); 
            AE_S32X2_IP(r,pScrWr,2*sizeof(ae_int32x2));
        }
        /* last iteration for sqrt(x) is done in higher precision */
        __Pragma("no_reorder")
        pScrWr=((      ae_int32x2*)scr)+1;
        pScrRd=(const ae_int32x2*)scr;
        for ( n=0; n<M; n+=2 )
        {
            ae_int64 a0,a1;
            ae_int32x2 x,y,r,d;
            AE_L32X2_IP(x,pScrRd,sizeof(ae_int32x2));
            AE_L32X2_IP(r,pScrRd,sizeof(ae_int32x2));
            y=AE_SLLI32S(AE_MULFP32X2RAS(x,r),1);
            a0=AE_SLLI64(AE_MUL32_HH(y,r),5);
            a1=AE_SLLI64(AE_MUL32_LL(y,r),5);
            d=AE_SEL32_HH(AE_MOVINT32X2_FROMINT64(a0),AE_MOVINT32X2_FROMINT64(a1));
            d=AE_MULFP32X2RAS(d,y);
            AE_MULSFP32X2RAS(y,d,0x08000000);
            AE_S32X2_IP(y,pScrWr,2*sizeof(ae_int32x2));
        }
        /* apply exponent */
        __Pragma("no_reorder")
        pScrRd=((const ae_int32x2*)scr)+1;
        pY=(      ae_int32x2*)y;
        pX=(      ae_int32x2*)y;
        aX=AE_LA64_PP(pX);
        aY=AE_ZALIGN64();
        for ( n=0; n<M; n+=2 )
        {
            ae_int64 a0,a1;
            ae_int32x2 w,nsa,sh;
            ae_ep acc_ep;
            AE_LA32X2_IP(nsa,aX,pX);
            sh=AE_SUB32(mode + block_exponent - logN + 1,AE_SRAI32(nsa,1));
            AE_L32X2_IP(w,pScrRd,2*sizeof(ae_int32x2));
            /* scale by sqrt(2) */
            AE_MUL32USEP_LH(acc_ep , a0, AE_MOVDA32(3037000500UL), w);
            AE_MUL32USEP_LL(acc_ep , a1, AE_MOVDA32(3037000500UL), w);
            a0=AE_SLAA64S(a0,AE_MOVAD32_H(sh));
            a1=AE_SLAA64S(a1,AE_MOVAD32_L(sh));
            AE_SA32X2_IP(AE_ROUND32X2F64SASYM(a0,a1),aY,pY);
        }
        AE_SA64POS_FP(aY,pY);
        y+=M;
        x+=M;
        N-=M;
    }
} /* fft_spectrum32x32 */
