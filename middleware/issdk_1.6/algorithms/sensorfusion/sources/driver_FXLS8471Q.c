/*
 * Copyright (c) 2015 - 2016, Freescale Semiconductor, Inc.
 * Copyright 2016-2017 NXP
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * o Redistributions of source code must retain the above copyright notice, this list
 *   of conditions and the following disclaimer.
 *
 * o Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 *
 * o Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from this
 *   software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*! \file driver_FXLS8471Q.c
    \brief Provides init() and read() functions for the FXLS8471Q 3-axis accel.

    Supports both I2C and SPI Interfaces.  Supply sensor address=0x00 when when
    installing sensor for SPI.  Supply I2C address otherwise.
*/

#include "board.h"                      // generated by Kinetis Expert.  Long term - merge sensor_board.h into this file
#include "sensor_fusion.h"              // Sensor fusion structures and types
#include "sensor_drv.h"                 // ISSDK - contains sensor state and error definitions
#include "register_io_spi.h"            // ISSDK - declares low-level interface functions for single-location reading
#include "sensor_io_spi.h"              // ISSDK - declares low-level interface functions for multi-location reading
#include "sensor_io_i2c.h"              // Required for registerreadlist_t / registerwritelist_t declarations
#include "fxls8471q.h"
#include "fxls8471q_drv.h"              // describes the FXLS8471Q ISSDK driver interface and structures
#include "drivers.h"                    // Device specific drivers supplied by NXP (can be replaced with user drivers)
#define FXLS8471Q_COUNTSPERG     8192.0
#define FXLS8471Q_ACCEL_FIFO_SIZE 32

// Command definition to read the WHO_AM_I value.
const registerreadlist_t    FXLS8471Q_WHO_AM_I_READ[] =
{
    { .readFrom = FXLS8471Q_WHO_AM_I, .numBytes = 1 }, __END_READ_DATA__
};

// Command definition to read the number of entries in the accel FIFO.
const registerreadlist_t    FXLS8471Q_F_STATUS_READ[] =
{
    { .readFrom = FXLS8471Q_F_STATUS, .numBytes = 1 }, __END_READ_DATA__
};

// Command definition to read the number of entries in the accel FIFO.
registerreadlist_t          FXLS8471Q_DATA_READ[] =
{
    { .readFrom = FXLS8471Q_OUT_X_MSB, .numBytes = 6 }, __END_READ_DATA__
};

// Each entry in a RegisterWriteList is composed of: register address, value to write, bit-mask to apply to write (0 enables)
const registerwritelist_t   FXLS8471Q_Initialization[] =
{
    // write 0000 0000 = 0x00 to CTRL_REG1 to place FXLS8471 into standby
    // [7-1] = 0000 000
    // [0]: active=00
    { FXLS8471Q_CTRL_REG1, 0x00, 0x00 },

    // Not applicable to the 8452/3.
    // OK: write 0100 0000 = 0x40 to F_SETUP to enable FIFO in continuous (circular) mode
    // [7-6]: F_MODE[1-0]=01 for FIFO continuous mode
    // [5-0]: F_WMRK[5-0]=000000 for no FIFO watermark
    { FXLS8471Q_F_SETUP, FXLS8471Q_F_SETUP_F_MODE_FIFOMOSTRECENT, 0x00 },

    // write 0000 0001 = 0x01 to XYZ_DATA_CFG register to set g range
    // [7-5]: reserved=000
    // [4]: HPF_OUT=0
    // [3-2]: reserved=00
    // [1-0]: FS=01 for +/-4g: 512 counts / g = 8192 counts / g after 4 bit left shift
    { FXLS8471Q_XYZ_DATA_CFG, FXLS8471Q_XYZ_DATA_CFG_FS_FS_RANGE_4G, 0x00 },

    // write 0000 0010 = 0x02 to CTRL_REG2 to set MODS bits
    // [7]: ST=0: self test disabled
    // [6]: RST=0: reset disabled
    // [5]: unused
    // [4-3]: SMODS=00
    // [2]: SLPE=0: auto sleep disabled
    // [1-0]: mods=10 for high resolution (maximum over sampling)
    { FXLS8471Q_CTRL_REG2, FXLS8471Q_CTRL_REG2_MODS_HIGHRES, 0x00 },

    // write 00XX X001 to CTRL_REG1 to set data rate and exit standby
    // [7-6]: aslp_rate=00
    // [5-3]: dr=111 for 1.56Hz data rate giving 0x39
    // [5-3]: dr=110 for 6.25Hz data rate giving 0x31
    // [5-3]: dr=101 for 12.5Hz data rate giving 0x29
    // [5-3]: dr=100 for 50Hz data rate giving 0x21
    // [5-3]: dr=011 for 100Hz data rate giving 0x19
    // [5-3]: dr=010 for 200Hz data rate giving 0x11
    // [5-3]: dr=001 for 400Hz data rate giving 0x09
    // [5-3]: dr=000 for 800Hz data rate giving 0x01
    // [2]: unused=0
    // [1]: f_read=0 for normal 16 bit reads
    // [0]: active=1 to take the part out of standby and enable sampling
#if (ACCEL_ODR_HZ <= 1)
    { FXLS8471Q_CTRL_REG1, FXLS8471Q_CTRL_REG1_MODE_ACTIVE | FXLS8471Q_CTRL_REG1_DR_1DOT56HZ, 0x00 }, // select 1.5625Hz ODR,
#elif (ACCEL_ODR_HZ <= 6)
    { FXLS8471Q_CTRL_REG1, FXLS8471Q_CTRL_REG1_MODE_ACTIVE | FXLS8471Q_CTRL_REG1_DR_6DOT25HZ, 0x00 }, // select 6.25Hz ODR
#elif (ACCEL_ODR_HZ <= 12)
    { FXLS8471Q_CTRL_REG1, FXLS8471Q_CTRL_REG1_MODE_ACTIVE | FXLS8471Q_CTRL_REG1_DR_12DOT5HZ, 0x00 }, // select 12.5Hz ODR
#elif (ACCEL_ODR_HZ <= 50)
    { FXLS8471Q_CTRL_REG1, FXLS8471Q_CTRL_REG1_MODE_ACTIVE | FXLS8471Q_CTRL_REG1_DR_50HZ, 0x00 }, // select 50Hz ODR
#elif (ACCEL_ODR_HZ <= 100)
    { FXLS8471Q_CTRL_REG1, FXLS8471Q_CTRL_REG1_MODE_ACTIVE | FXLS8471Q_CTRL_REG1_DR_100HZ, 0x00 }, // select 100Hz ODR
#elif (ACCEL_ODR_HZ <= 200)
    { FXLS8471Q_CTRL_REG1, FXLS8471Q_CTRL_REG1_MODE_ACTIVE | FXLS8471Q_CTRL_REG1_DR_200HZ, 0x00 }, // select 200Hz ODR
#elif (ACCEL_ODR_HZ <= 400)
    { FXLS8471Q_CTRL_REG1, FXLS8471Q_CTRL_REG1_MODE_ACTIVE | FXLS8471Q_CTRL_REG1_DR_400HZ, 0x00 }, // select 400Hz ODR
#else
    { FXLS8471Q_CTRL_REG1, FXLS8471Q_CTRL_REG1_MODE_ACTIVE , 0x00 }, // select 800Hz ODR
#endif
    __END_WRITE_DATA__
};

// All sensor drivers and initialization functions have the same prototype.
// sfg is a pointer to the master "global" sensor fusion structure.
// sensor = pointer to linked list element used by the sensor fusion subsystem to specify required sensors

// sfg = pointer to top level (generally global) data structure for sensor fusion
int8_t FXLS8471Q_Init(struct PhysicalSensor *sensor, SensorFusionGlobals *sfg)
{
    GENERIC_DRIVER_GPIO *pGPIODriver = &Driver_GPIO_KSDK;
    int32_t status;
    uint8_t reg;
    if (sensor->addr == SPI_ADDR) {
        // Initialize the Slave Select Pin.
        pGPIODriver->pin_init(&FXLS8471_SPI_CS, GPIO_DIRECTION_OUT, NULL, NULL, NULL);
        // Initialize SPI parameters used by ISSDK SPI routines
        sensor->slaveParams.pReadPreprocessFN  = FXLS8471Q_SPI_ReadPreprocess;
        sensor->slaveParams.pWritePreprocessFN = FXLS8471Q_SPI_WritePreprocess;
        sensor->slaveParams.pTargetSlavePinID = &FXLS8471_SPI_CS;
        sensor->slaveParams.spiCmdLen = FXLS8471Q_SPI_CMD_LEN;
        sensor->slaveParams.ssActiveValue = FXLS8471Q_SS_ACTIVE_VALUE;
        // Read the WhoAmI
        status = Register_SPI_Read(sensor->bus_driver, &sensor->deviceInfo, &(sensor->slaveParams), FXLS8471Q_WHO_AM_I, 1, &reg);
    } else {
        status = Register_I2C_Read(sensor->bus_driver, &sensor->deviceInfo, sensor->addr, FXLS8471Q_WHO_AM_I, 1, &reg);
    }
    if (status==SENSOR_ERROR_NONE) {
        sfg->Accel.iWhoAmI = reg;
        if (reg!=FXLS8471Q_WHO_AM_I_WHOAMI_VALUE) return(SENSOR_ERROR_INIT);
    } else {
       return(status);
    }

    // Configure and start the FXLS8471Q sensor.  This does multiple register writes
    if (sensor->addr == SPI_ADDR)
        status = Sensor_SPI_Write(sensor->bus_driver, &sensor->deviceInfo, &(sensor->slaveParams), FXLS8471Q_Initialization );
    else
        status = Sensor_I2C_Write(sensor->bus_driver, &sensor->deviceInfo, sensor->addr, FXLS8471Q_Initialization );

    // Stash some needed constants in the SF data structure for this sensor
    sfg->Accel.iCountsPerg = FXLS8471Q_COUNTSPERG;
    sfg->Accel.fgPerCount = 1.0F / FXLS8471Q_COUNTSPERG;

    sensor->isInitialized = F_USING_ACCEL;
    sfg->Accel.isEnabled = true;

    return (status);
}

int8_t FXLS8471Q_Read(struct PhysicalSensor *sensor, SensorFusionGlobals *sfg)
{
    uint8_t                     Data_Buffer[6 * FXLS8471Q_ACCEL_FIFO_SIZE];    // I2C read buffer
    int8_t                      status=0;       // I2C transaction status
    int8_t                      j;              // scratch
    uint16_t                     sensor_fifo_count = 1;
    int16_t                     sample[3];

    if(sensor->isInitialized != F_USING_ACCEL)
    {
        return SENSOR_ERROR_INIT;
    }

    // read the F_STATUS register (mapped to STATUS) and extract number of measurements available (lower 6 bits)
    if (sensor->addr == SPI_ADDR)
        status =  Sensor_SPI_Read(sensor->bus_driver, &sensor->deviceInfo, &(sensor->slaveParams), FXLS8471Q_F_STATUS_READ, Data_Buffer );
    else
        status =  Sensor_I2C_Read(sensor->bus_driver, &sensor->deviceInfo, sensor->addr, FXLS8471Q_F_STATUS_READ, Data_Buffer );

    sensor_fifo_count = Data_Buffer[0] & 0x3F;
    if (status==SENSOR_ERROR_NONE) {
        // return if there are no measurements in the sensor FIFO.
        // this will only occur when the FAST_LOOP_HZ equals or exceeds ACCEL_ODR_HZ
        if  (sensor_fifo_count == 0) return SENSOR_ERROR_READ;
    } else {
        return(status);
    }

    FXLS8471Q_DATA_READ->numBytes = 6 * sensor_fifo_count;
    if (sensor->addr == SPI_ADDR)
        status =  Sensor_SPI_Read(sensor->bus_driver, &sensor->deviceInfo, &sensor->slaveParams, FXLS8471Q_DATA_READ, &(Data_Buffer[0]) );
    else
        status =  Sensor_I2C_Read(sensor->bus_driver, &sensor->deviceInfo, sensor->addr, FXLS8471Q_DATA_READ, &(Data_Buffer[0]) );

    if (status==SENSOR_ERROR_NONE) {
        for (j=0; j<sensor_fifo_count; j++) {
            sample[CHX] = (Data_Buffer[6*j    ] << 8) | Data_Buffer[6*j + 1] ;
            sample[CHY] = (Data_Buffer[6*j + 2] << 8) | Data_Buffer[6*j + 3] ;
            sample[CHZ] = (Data_Buffer[6*j + 4] << 8) | Data_Buffer[6*j + 5] ;
            conditionSample(sample);  // truncate negative values to -32767
            addToFifo((union FifoSensor*) &(sfg->Accel), ACCEL_FIFO_SIZE, sample);
        }
    }

    return (status);
}


// Each entry in a RegisterWriteList is composed of: register address, value to write, bit-mask to apply to write (0 enables)
const registerwritelist_t   FXLS8471Q_IDLE[] =
{
  // Set ACTIVE = other bits unchanged
  { FXLS8471Q_CTRL_REG1, 0x00, 0x01 },
    __END_WRITE_DATA__
};

// FXLS8471Q_Idle places the sensor into Standby mode (wakeup time = 2/ODR+1ms)
int8_t FXLS8471Q_Idle(struct PhysicalSensor *sensor, SensorFusionGlobals *sfg)
{
    int32_t     status;
    if(sensor->isInitialized == F_USING_ACCEL) {
        if (sensor->addr == SPI_ADDR) {
            status = Sensor_SPI_Write(sensor->bus_driver, &sensor->deviceInfo, &(sensor->slaveParams), FXLS8471Q_IDLE );
        } else {
            status = Sensor_I2C_Write(sensor->bus_driver, &sensor->deviceInfo, sensor->addr, FXLS8471Q_IDLE );
        }
        sensor->isInitialized = 0;
        sfg->Accel.isEnabled = false;
    } else {
      return SENSOR_ERROR_INIT;
    }
    return status;
}
