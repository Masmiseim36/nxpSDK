<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Maestro Audio Framework: Maestro Audio Framework Programmer&#39;s Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="fs_logo.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Maestro Audio Framework<span id="projectnumber">&#160;v 1.5</span>
   </div>
   <div id="projectbrief">NXP Semiconductors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_ProgrammersGuide.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Maestro Audio Framework Programmer's Guide </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md21"></a>
Introduction</h1>
<p >Maestro audio framework provides instruments for playback and capture of different audio streams. In order to do that the framework uses API for creating various audio and voice pipelines with the support of media and track information. This document describes the framework in its detail, and the usage of API for pipeline creation using different elements. The framework needs an operating system in order to create different tasks for audio processing and communication with the application.</p>
<h1><a class="anchor" id="autotoc_md22"></a>
Architecture overview</h1>
<p >A high-level block diagram of the streamer used in Maestro is shown below. An element is the most important class of objects in the streamer (see <code><a class="el" href="streamer__element_8c.html" title="Implementation of streamer element.">streamer_element.c</a></code>). A chain of elements will be created and linked together when a <a href="pipeline_8c.html">pipeline</a> is created. Data flows through this chain of elements in form of data buffers. An element has one specific function, which can be the reading of data from a file, decoding of this data, or outputting this data to a sink device. By chaining together several such elements, a pipeline is created that can do a specific task, for example, the playback.</p>
<h1><a class="anchor" id="autotoc_md23"></a>
Pipeline</h1>
<p ><img src="maestro.svg" alt="" style="pointer-events: none;" class="inline" title="maestro overview"/></p>
<p >The pipeline itself is created within the <code>streamer_create</code> API using the <code>streamer_create_pipeline</code> call. In the underlying <code>streamer_msg_create_pipeline</code> call the correct pipeline type is selected and then the specific <code>streamer_build_pipeline</code> is used. In order to create a new user defined pipeline it is necessary to create a new source file in the pipeline folder. The new pipeline type needs to be added into the <code>StreamPipelineType</code> enum in the <code><a class="el" href="streamer__api_8h.html" title="Streamer API header. Public APIs for using the maestro streamer framework.">streamer_api.h</a></code> file. Then in the <code>streamer_msg_create_pipeline</code> function it is necessary to add a case for that particular pipeline in the <code>switch(streamer_msg-&gt;pipeline_type)</code> statement. The <code>streamer_build_new_pipeline</code> function needs to implement the building of the desired pipeline using following API:</p>
<ul>
<li><code>create_pipeline</code> - allocate memory for a new pipeline and initialize the maximum elements</li>
<li><code>create_element</code> - create an element with the desired type, initialize its source and sink pads</li>
<li><code>add_element_pipeline</code> - add the created elements into the pipeline</li>
<li><code>link_elements</code> - connect the elements together linking the source pads to sink pads and the other way round</li>
</ul>
<p >Then it is also necessary to implement a new function for destroying the pipeline and register it in the <code>streamer_msg_destroy_pipeline</code> function, i.e. <code>stream_destroy_new_pipeline</code> using following API:</p>
<ul>
<li><code>unlink_elements</code> - disconnect the elements</li>
<li><code>remove_element_pipeline</code> - remove the elements from the pipeline</li>
<li><code>destroy_element</code> - destroy the elements and free the memory</li>
<li><code>destroy_pipeline</code> - destroy the pipeline and free the memory</li>
</ul>
<h1><a class="anchor" id="autotoc_md24"></a>
Elements and Pads</h1>
<p >Pads are elements' inputs and outputs. A pad can be viewed as a "plug" or "port" on an element where links may be made with other elements, and through which data can flow to or from those elements. Data flows out of an element through a source pad, and elements accept incoming data through a sink pad. Source and sink elements have only source and sink pads, respectively. For detailed information about pads, please see the API reference from <code><a class="el" href="pad_8c.html" title="This file contains the streamer element pad implementation.">pad.c</a></code>.</p>
<p ><img src="elements.svg" alt="" style="pointer-events: none;" class="inline" title="data flow"/></p>
<h1><a class="anchor" id="autotoc_md25"></a>
Internal communication</h1>
<p >The streamer (the core of the framework) provides several mechanisms for communication and data exchange between the application, a pipeline, and pipeline elements:</p><ul>
<li>buffers are objects for passing streaming data between elements in the pipeline. Buffers always travel from sources to sinks (downstream).</li>
<li>messages are objects sent from the application to the streamer task to construct, configure, and control a streamer pipeline.</li>
<li>callbacks are used to transmit information such as errors, tags, state changes, etc. from the pipeline and elements to the application.</li>
<li>events are objects sent between elements. Events can travel upstream and downstream. Events may also be sent to the application</li>
<li>queries allow applications to request information such as duration or current playback position from the pipeline. Elements can also use queries to request information from their peer elements (such as the file size or duration). They can be used both ways within a pipeline, but upstream queries are more common</li>
</ul>
<h1><a class="anchor" id="autotoc_md26"></a>
Decoders and encoders</h1>
<p >Maestro framework uses a common codec interface for decoding purposes and a common encoder interface for encoding. Those interfaces encapsulate the usage of specific codecs.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
Common codec interface</h2>
<p >The Common Codec Interface is the intended interface for all used <b>decoders</b>. The framework will integrate a CCI decoder element into the streamer to interface with all decoders.</p>
<h2><a class="anchor" id="autotoc_md28"></a>
Using the CCI to interface with Metadata</h2>
<ul>
<li><code>cci_extract_meta_data</code> must be called before any other Codec Interface APIs. This API extracts the metadata information of the codec and fills this information in the <a class="el" href="structfile__meta__data__t.html" title="File Metadata Structure.">file_meta_data_t</a> structure. The <a class="el" href="structfile__meta__data__t.html" title="File Metadata Structure.">file_meta_data_t</a> structure must be allocated by the application.</li>
<li>This function first extracts the input file extension and based on that it calls the specific codec’s metadata extraction function. If it finds an invalid extension or unsupported extension then it returns with META_DATA_FILE_NOT_SUPPORTED code for any unsupported file format.</li>
<li>If this API finds the valid metadata then it returns with META_DATA_FOUND code. If this API does not find any metadata information then it returns with META_DATA_NOT_FOUND code. It also returns with META_DATA_FILE_NOT_SUPPORTED code for any unsupported file format.</li>
</ul>
<h2><a class="anchor" id="autotoc_md29"></a>
Using the CCI to interface with Decoders</h2>
<ul>
<li><code>codec_get_mem_info</code> gets the memory requirement based on the specific decoder stream type. It returns the size in bytes of the specific codec. The user of the decoders must allocate memory of this size and this memory is used by the initialization API. The user or application must pass this allocated memory pointer to the init API.</li>
<li><code>codec_init</code> must be called before the codec’s decode API. This API calls the codec-specific initialization function based on the codec stream type. This API allocates the memory to the codec main structure and also initializes the codec main structure parameters. It also registers the call back functions to the codec which will be used by the codec to read or seek the input stream.</li>
<li><code>codec_decode</code> is the main decoding API of the codec. This API calls the codec-specific decoding function based on the codec stream type. This API decodes the input raw stream and fills the PCM output samples into codec output PCM buffer. This API gives the information about the number of samples produced by the codec and also gives the pointer of the codec output PCM samples buffer.</li>
<li><code>codec_get_pcm_samples</code> must be called after the codec’s decode API. This API calls the codec specific Get PCM Sample API based on the codec stream type. This API gets the PCM samples from the codec in constant block size and fills them into the output PCM buffer. It returns the number of samples get from the codec and also gives the pointer of the output PCM buffer.</li>
<li><code>codec_reset</code> calls the codec specific reset API base on stream type and resets the codec.</li>
<li><code>codec_seek</code> accepts the seek bytes offset converted from the time by application. This API calls the decoder’s internal seek API to calculate the actual seek offset which frame boundary aligns. This API returns the actual seek offset.</li>
</ul>
<p >The basic sequence to use a decoder with the CCI is shown below:</p>
<p ><img src="codec_flow.png" alt="" class="inline" title="cci_decoder_flow"/></p>
<h2><a class="anchor" id="autotoc_md30"></a>
Adding new decoders to the CCI</h2>
<p >This section explains how to integrate a new decoder in the Common Codec Interface. The CCI assumes the decoder library to be used is in the <code>libs</code> folder of the maestro framework. The CCI is just a wrapper around a specific implementation. The decoder is expected to be extended as needed to meet the APIs described above.</p><ul>
<li>Register Decoder Top level APIs in Common Codec Interface<ul>
<li>Place the decoder lib in <code>libs</code> folder.</li>
<li>Add prototypes of the decoder top level APIs in <a class="el" href="codec__interface_8h.html" title="Contains codec interface definitions.">codec_interface.h</a> file (located at streamer/cci/include folder).</li>
<li>In <a class="el" href="codec__interface_8c.html" title="This file contains the CCI decoder interface APIs definitions.">codec_interface.c</a> file (located at streamer/decoders/cci_dec), add top level Decoder APIs in decoder function table.</li>
<li>Pseudo code for this is as described below.</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_struct" href="structcodec__interface__function__table__t.html">codec_interface_function_table_t</a> <a class="code hl_variable" href="codec__interface_8h.html#adbf65f9930616f17efccab5bc69e4121">g_codec_function_table</a>[<a class="code hl_enumvalue" href="codec__interface__public__api_8h.html#a617edfb76567ff93543b9ee637a07d5ca013ee54b5460e514f9559a138744f6f1">STREAM_TYPE_COUNT</a>] = {</div>
<div class="line"><span class="preprocessor">#ifdef VORBIS_CODEC</span></div>
<div class="line">    {</div>
<div class="line">        &amp;VORBISDecoderGetMemorySize,</div>
<div class="line">        &amp;VORBISDecoderInit,</div>
<div class="line">        &amp;VORBISDecoderDecode,</div>
<div class="line">        NULL,</div>
<div class="line">        NULL,</div>
<div class="line">        &amp;VORBISDecoderSeek,</div>
<div class="line">        &amp;VORBISDecoderGetIOFrameSize,</div>
<div class="line">    },</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    {</div>
<div class="line">        NULL,</div>
<div class="line">        NULL,</div>
<div class="line">        NULL,</div>
<div class="line">        NULL,</div>
<div class="line">        NULL,</div>
<div class="line">        NULL,</div>
<div class="line">        NULL,</div>
<div class="line">    }</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">};</span></div>
<div class="ttc" id="acodec__interface_8h_html_adbf65f9930616f17efccab5bc69e4121"><div class="ttname"><a href="codec__interface_8h.html#adbf65f9930616f17efccab5bc69e4121">g_codec_function_table</a></div><div class="ttdeci">const codec_interface_function_table_t g_codec_function_table[STREAM_TYPE_COUNT]</div><div class="ttdoc">Global table with function pointers for different codecs.</div><div class="ttdef"><b>Definition:</b> codec_interface.c:31</div></div>
<div class="ttc" id="acodec__interface__public__api_8h_html_a617edfb76567ff93543b9ee637a07d5ca013ee54b5460e514f9559a138744f6f1"><div class="ttname"><a href="codec__interface__public__api_8h.html#a617edfb76567ff93543b9ee637a07d5ca013ee54b5460e514f9559a138744f6f1">STREAM_TYPE_COUNT</a></div><div class="ttdeci">@ STREAM_TYPE_COUNT</div><div class="ttdoc">count of stream type</div><div class="ttdef"><b>Definition:</b> codec_interface_public_api.h:47</div></div>
<div class="ttc" id="astructcodec__interface__function__table__t_html"><div class="ttname"><a href="structcodec__interface__function__table__t.html">codec_interface_function_table_t</a></div><div class="ttdoc">Codec Interface Function Table.</div><div class="ttdef"><b>Definition:</b> codec_interface.h:70</div></div>
</div><!-- fragment --><ul>
<li>Enable or Disable Decoder<ul>
<li>Define <code>VORBIS_CODEC</code> macro in audio_cfg.h file.</li>
<li>Comment this macro if you want to disable VORBIS Decoder otherwise keep it defined in order to enable the decoder.</li>
</ul>
</li>
<li>Add Extract Metadata API for the decoder<ul>
<li>Add extract metadata API source file for the decoder at streamer/cci/metadata/src/vorbis folder.</li>
<li>Add this code in extract metadata lib project space.</li>
<li>Build the extract metadata lib and copy that lib to <code>libs</code> folder.</li>
<li>Add the desired stream type into <code>ccidec_extract_meta_data</code> API (in <a class="el" href="codecextractmetadata_8c.html" title="This file Contains functionality that determines the file type and then calls the proper extract meta...">codecextractmetadata.c</a> file) to call VORBIS Decoder extract metadata API.</li>
</ul>
</li>
<li>Add stream type of the new decoder in the stream type enum audio_stream_type_t in <a class="el" href="codec__interface__public__api_8h.html" title="Contains common codec interface APIs definitions.">codec_interface_public_api.h</a><ul>
<li>Stream type of the decoder in stream type enum and decoder APIs in decoder function table must be in the same sequence.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md31"></a>
Common encoder interface</h2>
<p >Please see the following section about the <a class="el" href="md_CeiEncoder.html">cei</a>.</p>
<h1><a class="anchor" id="autotoc_md32"></a>
Maestro performance</h1>
<h2><a class="anchor" id="autotoc_md33"></a>
Memory information</h2>
<p >The memory usage of the framework (data obtained from IAR compiler) in bytes is:</p><ul>
<li>Code/flash = 77678</li>
<li>RAM = 5013</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">Section   </th><th class="markdownTableHeadRight">Size    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">.text   </td><td class="markdownTableBodyRight">77678    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">.bss   </td><td class="markdownTableBodyRight">5013   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md34"></a>
CPU usage</h2>
<p >The performance of the decoder was measured using the real hardware platform (RT1060).</p><ul>
<li>CPU core clock in MHz: 600.</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Pipeline type   </th><th class="markdownTableHeadCenter">Performance MIPS of codec (in MHz)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">audio source -&gt; audio sink   </td><td class="markdownTableBodyCenter">~10.26 MHz    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">audio source -&gt; file sink   </td><td class="markdownTableBodyCenter">~9.84 MHz    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">file source (8-channel PCM) -&gt; audio sink   </td><td class="markdownTableBodyCenter">~16.5 MHz   </td></tr>
</table>
<p >For performance details about the supported codecs please see <a class="el" href="mp3dec_start.html#md_mp3dec">MP3 decoder</a> and <a class="el" href="md_wavdec.html">WAV decoder</a> documents.</p>
<h1><a class="anchor" id="autotoc_md35"></a>
Opus codec</h1>
<p >For opus decoder documentation please see following link: <a href="https://opus-codec.org/docs/opus_api-1.3.1/">opus</a>.</p>
<h1><a class="anchor" id="autotoc_md36"></a>
Opus file</h1>
<p >The following library is used for gaining information from the Ogg Opus audio streams: <a href="https://opus-codec.org/docs/opusfile_api-0.12/index.html">opusfile</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul class="foot">
    <li class="footer">&copy; 2020 NXP Semiconductors. All rights reserved.
    </li>
  </ul>
</div>
</body>
</html>
